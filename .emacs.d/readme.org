#+title:   Colin Jaffe's Literate Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :mkdirp yes :tangle init.el :padline yes

* Colin Jaffe's Literate Config
** Introduction

Emacs is a text editor. Or... is it?

Well, most people use it predominantly as a text editor, but at its nerdy awkward heart it's actually a Lisp programming environment. Setting Emacs' preferences and extending it with third-party code is all done through Lisp code that the Emacs user writes.

[[https://www.explainxkcd.com/wiki/index.php/297:_Lisp_Cycles][https://www.explainxkcd.com/wiki/images/e/eb/lisp_cycles.png]]

This is my code so far.

I'm basing this new config on the Emacs from Scratch repo, which is a lot more sparse. I'm currently changing this config considerably by:

1. Paring down the config I copied over from EFS.
2. Going through Doom Emacs' vast built-in modules, taking the code I want.

So that's where we started and where we're going. Let's look at some code!

** Literate Config Setup

Literate programming is an approach where, instead of putting comments in code to explain things, we put code in the middle of commentary. The document you’re reading right now is an example of literate programming, often called a literate config when its purpose is configuring apps. All of the code blocks in this document are “tangled”, which means that they are copied from this document to a code file. The code file itself is rarely edited directly—instead, the code is edited here, along with its explanation. This ensures that any code in here is documented… there’s always a reason for a block of code to exist. The documentation can’t fall behind the code—the documentation /is/ the code.

You can read more on this subject… and I’ll probably write more. But in the meantime: the function below simply ensures that any time this document is saved, its code is automatically tangled to the appropriate code files. It’s pretty sweet!

#+begin_src emacs-lisp
  (defun efs--org-babel-tangle-config ()
    "Automatically tangle our Emacs.org config file when we save it. Credit to Emacs From Scratch for this one!"
    (when (string-equal (buffer-file-name)
                        (expand-file-name "readme.org" user-emacs-directory))

      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs--org-babel-tangle-config)))
#+end_src

** Start The Emacs Server

Running an Emacs server means that every single Emacs frame (or "window" in operating system parlance) that you create isn't a new instance of Emacs, but belongs to the same Emacs as all the other frames. This makes opening a new Emacs frame lightning fast, reducing the cost of having lots of Emacs libraries and making the fact that Emacs initially takes 10 seconds to start up completely beside the point.

#+begin_src emacs-lisp
(server-start)
#+end_src

** Start With Messages

I usually want to see the startup log first, and I'm tired of manually switching to it. I also usually want to see the newest messages.

#+begin_src emacs-lisp
  (switch-to-buffer "*Messages*")
  (goto-char (point-max))
#+end_src

** Package System

Getting Emacs users' awesome libraries (called "packages") into Emacs.

Emacs has a built in package manager, but it doesn't make it easy to automatically install packages on a new system the first time you pull down your configuration. ~use-package~ and ~straight~ are a really helpful package combination that makes it a lot easier to automate the installation and configuration of everything else we use.

Let's install ~straight~.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

And turn off the built-in package manager. (This needs to go in ~early-init.el~, but I can tangle it to there from this document with a header arg, which you can see if you're looking at this document as a raw ~org-mode~ file. If that sounds like a whole thing, well... it's also not terribly important detail! But I included it anyway! Not sure why!)

#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

Use ~straight~ to install ~use-package~.

#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

Tell ~use-package~ to install packages using ~straight~ whenever I declare a ~use-package~ block.

#+begin_src emacs-lisp
(use-package straight
  :custom
  (straight-use-package-by-default t))
#+end_src

Now every time I configure a package with ~use-package~, ~use-package~ will use ~straight~ to install the package first.

This means that if you or I copy this configuration to another machine and launch Emacs, it will install the necessary packages automatically and configure them the exact same way. This is now a portable document capable of replicating my setup anywhere. And explaining it!

The only extra step necessary is that, because this file is actually an org document, you'll have to run Emacs, tangle this file, and then restart Emacs. But such is the price of being literate(ly configured).

** Keybindings

Like many Vimmers, I eventually realized that the things I personally liked about Vim were even more present in Emacs. This very much includes Vim keybindings, which are available through Evil Mode, In a lot of ways, Evil mode is /more Vim than Vim/. This is something I could argue at length, but... maybe not in this space. (Yet?)

*** Installing And Using General

Before we even get to the keybindings themselves, let's set up a good Vimmish system here. ~general~ is a great system for setting up keybindings. It integrates very well with ~use-package~, ~evil~, and ~which-key~.

We can use ~general-create-definer~ to define a pair of leader keys. A leader key is a key you can press that begins a keybinding. We'll see some examples in a sec.

#+begin_src emacs-lisp
  (use-package general
    :init
    (general-create-definer crj-leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "M-SPC"))
#+end_src

This code defines a /function/ called ~crj-leader-keys~ that we can use from now on to define keybindings. The important thing here is that we can define upfront what ~crj-leader-keys~ does—what Evil States it's active in, and that it will activate with either spacebar in Evil Normal State, or Meta-spacebar (Alt- or Option-spacebar) when spacebar would otherwise do something else (like print an actual space).

We can now very easily define another level of keybinding. We want ~SPC f~ to activate commands that have to do with files—thus the ~f~.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys "f" '(:ignore t :which-key "Files Menu")))
#+end_src

From now on, when you press the user presses the spacebar (or ~M-SPC~) and then ~f~, they'll have access to any commands that follow. And when we put ~which-key~ in there momentarily, when they press ~SPC~ they'll get a menu that will show them that ~f~ leads to commands labeled "files", and if they press ~f~ they'll see a list of letters they can press next and the commands that each will activate.

Let's define a few commands that open specific commonly accessed files as examples, and then bind them to keys using this system.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq org-directory "~/org-stuff")

    (defun crj-open-literate-config-file ()
      "Open the literate config file in the user directory."
      (interactive)
      (find-file (expand-file-name "readme.org" user-emacs-directory)))

    (defun crj-open-task-list ()
      "Open the master task list file."
      (interactive)
      (find-file (expand-file-name "readme.org" org-directory)))

    (defun crj-open-quick-note-file ()
      "Open the file used for quick notes."
      (interactive)
      (find-file (expand-file-name "quick-note.md" org-directory)))

    :general
    (crj-leader-keys
      "fc" '(crj-open-literate-config-file :which-key "Open literate config file.")
      "ft" '(crj-open-task-list :which-key "Open task list file.")
      "fq" '(crj-open-quick-note-file :which-key "Open quick notes file.")))
#+end_src

Now it's not much code to add fairly complex keybindings, and once we get ~which-key~ installed, they'll be discoverable as well!

Next we'll define a bunch more keybindings, as well as answer the question, /why leader keys at all?/

*** General Emacs' Keybindings

Many of my keybindings are taken from Doom Emacs' well-thought-through keybindings—although part of this is certainly that I'm just used to using them for the last couple of years.

In Vanilla Emacs' keybinding land, the focus is on often elaborate key "chords", where you use a series of modifier key-letter pairs, while in Vim/Evil, most commands use a "leader" key.

For example, opening a file in Vanilla Emacs keybindings would be ~C-x C-f~, which means to hold down the ~Control~ key, press ~x~, then, still holding down ~Control~ (or re-pressing and holding it), press ~f~. This can be a bit of a strain on your hand, although certainly less so if you follow best practices and swap ~Control~ and ~Caps Lock~.

In Evil-Mode-style keybindings, the same command might be something like ~SPC f o~, which means press the ~spacebar~, then press the ~f~ key, then press the ~o~ key.

This works because in a modal editing system like Vim and Evil, pressing keys doesn't type anything into a file, but activates commands instead. For example, ~/~ begins a text search (like ~C-f~ or ~Command-f~ in many apps), and ~dd~ deletes the line the cursor is on.  To enter a text insertion state and actually type text, you have to use a command—in Evil/Vim, the classic command is ~i~ (for ~i~nsert).

This system of different "modes" (Vim parlance) or "states" (Evil parlance, since "mode" has a different meaning in Emacs) gives you tons of freedom in your keybindings. If you /don't/ have non-typing states to unlock these fast editing commands, you need to use modifiers keys like ~Control~ and ~Alt~ and ~Command~ to differentiate commands from typing. In a modal system's "normal state"—so called because editing text is /more/ common than typing new text—you can use ~SPC f o~ to ~o~ pen a ~f~ ile. This opens you up to simpler keybindings that can be a little more mnemonic /without/ contorting your hands.

Let's see some examples!

The following binds ~SPC f s~ to save a file. It's nice and mnemonic, as well as just three quick presses.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
             "fs" '(save-buffer
                    :which-key "Save current buffer.")))
#+end_src

The ~:prefix "SPC"~ tells ~general~ that this is a "leader key", a key that leads off a set of commands. ~:keymaps normal~ indicates that this is a command for "normal state"—which makes sense, because in a typing state like insert state, you want the spacebar to actually type a space! The next line, the ~"f"~ one, creates a sort of menu for further commands, which will (soon) include keybound commands that have to do with files (maybe copy and rename/move will go there, for example). The ~:which-key~ keyword in that and the following line, where we finally bind the ~save-buffer~ command, tells ~which-key~ (see the "Which Key" section below) how to label the menu and commands for discoverability.

To see a good example of a menu with many commands in it, see the section on Helpful commands.

You don't always have to have commands in a deep hierarchy of sections. Here is a simple-if-not-mnemonic ~SPC .~ for opening or creating a file. (And you can also launch ~dired~ with it!) This is such a common command that it's good not to bury it in a menu.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys "." '(find-file :which-key "Open or create file.")))
#+end_src

I think you get the basics—as I did with learning and writing this section! Let's throw a bunch of commonly-used universal Emacs keybindings together now!

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (crj-leader-keys
      "," '(consult-buffer :which-key "Switch buffer or open recent file.")
      "<" '(consult-project-buffer :which-key "Switch to project-specific buffer.")
      "TAB" '(evil-switch-to-windows-last-buffer :which-key "Previous buffer.")
      ";" '(execute-extended-command :which-key "Run interactive command.")
      ":" '(eval-expression :which-key "Evaluate expression.")
      "y" '(consult-yank-from-kill-ring :which-key "Select from clipboard history.")))
#+end_src

Creating a buffers menu.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
      "b" '(:ignore t :which-key "Buffers Menu")))
#+end_src

And adding some buffer commands, including a custom one.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defconst crj--immortal-buffer-names '("*scratch*"
                                           "#emacs"
                                           "*Messages*"
                                           shell-command-buffer-name shell-command-buffer-name-async))

    (defun crj-kill-or-bury-current-buffer ()
      "Kill the current buffer.

  Unless it's a buffer we should always keep alive, in which case we just bury it in the buffer list."
      (interactive)
      (if (member (buffer-name (current-buffer)) crj--immortal-buffer-names)
          (bury-buffer)
        (kill-buffer (current-buffer))))
    :general
    (crj-leader-keys
      "bd" '(crj-kill-or-bury-current-buffer :which-key "Kill buffer.")
      "bz" '(bury-buffer :which-key "Bury buffer.")
      "br" '(revert-buffer :which-key "Revert buffer.")
      "bW" '(kill-buffer-and-window :which-key "Kill buffer and close window.")))
#+end_src

*** Or Maybe Redo Keybindings To Be More Readable?

Check out this (useful!) keybinding.

#+begin_src emacs-lisp :tangle no
  (use-package emacs
    :general
    (:states 'insert "<S-backspace>" #'just-one-space))
#+end_src

See the <S-backspace> mapping? Well, it took me a good while to find the right way to write shift-backspace in the same syntax as the rest of it, and in the process, I happened upon this alternate syntax:

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (:states 'insert [(shift backspace)] #'just-one-space))
#+end_src

 It's /not/ a short way to write it, but I'm agreeing more and more these days with the idea that short-hands are a real time-saver for when you're entering commands all by yourself (perfect example is installing something globally via ~npm~ with ~npm i -g [package name]~ on your own machine by yourself), but if something's in a document, where someone (even just you several weeks later) needs to read and understand it, it should have the long-hand version—so with the previous example, you'd write the command in a document as ~npm install --global [package name]~.

 So! Maybe this is how these mappings should be written? ~[(control d)]~ instead of ~"C-d"~? Maybe! Bears thinking about, for sure.

*** Which Key

Which key shows you a constantly updating list of what keys you can press next and what commands or menus they'll activate. It's helpful when you can't remember a shortcut, or even just when you want to explore what commands are under a certain menu.

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (setq which-key-idle-delay 2
          which-key-separator "→"
          which-key-show-operator-state-maps t
          which-key-sort-order #'which-key-prefix-then-key-order
          which-key-show-prefix nil
          which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL")))
#+end_src

**** A Which-Key Menu

This is as good a place as any to show how to make a menu with which-key!

#+begin_src emacs-lisp :lexical no
  (use-package which-key
    :general
    (crj-leader-keys "t" '(:ignore t :which-key "Toggle menu.")))
#+end_src

** Markup Documents

*** General Markup Keybindings

The overarching menu.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
      "m" '(:ignore t :which-key "Markup Menu")))
#+end_src

Searching a markup outline.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
      "m." '(consult-outline :which-key "Search markup outline.")))
#+end_src

*** Emmet Abbreviations

These abbreviations are a great tool for HTML, to the point where they're built into many editors now. But not Emacs, so they're a package.

If you don't know at least the simple Emmet abbreviations, and you write HTML, man, you're missing out. Check out the full docs, but here's [[https://docs.emmet.io/cheat-sheet/][a great Emmet cheat sheet]].

#+begin_src emacs-lisp :lexical no
  (use-package emmet-mode
    :ghook
    'sgml-mode-hook
    'css-mode-hook
    'html-mode-hook
    'web-mode-hook

    :init
    (setq emmet-move-cursor-between-quotes t
          emmet-self-closing-tag-style " /"))
#+end_src

*** Org Mode

[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

**** Install Newest Version

Org is built into Emacs, but you probably want the newest version.

#+begin_src emacs-lisp
  (use-package org)
#+end_src

**** Keybindings

Let's make Org keybindings a bit better.

***** Todos

****** Todos menu

#+begin_src emacs-lisp
  (use-package org
    :general
    (crj-leader-keys
      "mt" '(:ignore t :which-key "Todos Menu")))
#+end_src

****** General Bindings

Some general todo bindings.

#+begin_src emacs-lisp
  (use-package org
    :general
    (crj-leader-keys
      "mtt" '(org-todo :which-key "Change todo state.")))
#+end_src

******* TODO add bindings for:
- deadlines and schedules

***** Searching Org Documents

The search results for ~consult-org-heading~ are fantastic, as you can search the entire path of headings. So we overwrite the ~consult-outline~ keybinding when we're in Org Mode.

#+begin_src emacs-lisp
  (use-package org
    :general
    (crj-leader-keys
      :keymaps 'org-mode-map
      :states '(normal visual)
      "m/" '(consult-org-heading :which-key "Search current headings.")))
#+end_src

**** Org Mode Better Font Faces

The ~efs/org-font-setup~ function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in ~org-mode~.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp
  (defun my/buffer-face-mode-variable ()
    "Set font to a variable width (proportional) fonts in current buffer."
    (interactive)
    (setq buffer-face-mode-face '(:family crj--variable-pitch-font
                                          :height 1.0
                                          :width normal))
    (buffer-face-mode))

    (defun my/set-general-faces-org ()
      (my/buffer-face-mode-variable)
      (setq line-spacing 0.1
            org-pretty-entities t
            org-startup-indented t
            org-adapt-indentation nil)
      (variable-pitch-mode +1)
      (mapc
       (lambda (face) ;; Other fonts that require it are set to fixed-pitch.
         (set-face-attribute face nil :inherit 'fixed-pitch))
       (list 'org-block
             'org-table
             'org-verbatim
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-date
             'org-drawer
             'org-property-value
             'org-special-keyword
             'org-document-info-keyword))
      (mapc ;; This sets the fonts to a smaller size
       (lambda (face)
         (set-face-attribute face nil :height 0.8))
       (list 'org-document-info-keyword
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-drawer
             'org-property-value
             )))

      (defun efs/org-font-setup ()
        ;; Replace list hyphen with dot
        (font-lock-add-keywords 'org-mode
                                '(("^ *\\([-]\\) "
                                   (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

        ;; Ensure that anything that should be fixed-pitch in Org files appears that way
        (set-face-attribute 'org-block nil    :foreground nil :font crj--coding-font)
        (set-face-attribute 'org-table nil    :font crj--coding-font)
        (set-face-attribute 'org-formula nil  :font crj--coding-font)
        (set-face-attribute 'org-code nil     :font crj--coding-font)
        (set-face-attribute 'org-table nil    :font crj--coding-font)
        (set-face-attribute 'org-verbatim nil :font crj--coding-font)
        (set-face-attribute 'org-special-keyword nil :font crj--coding-font)
        (set-face-attribute 'org-meta-line nil :font crj--coding-font)
        (set-face-attribute 'org-checkbox nil  :font crj--coding-font))

#+end_src

**** Basic Config

This section contains the basic configuration for ~org-mode~ plus the configuration for Org agendas and capture templates.  There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.

#+begin_src emacs-lisp
  (defun efs/org-mode-setup ()
    (org-indent-mode)
    ;; (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :init
    (setq org-link-descriptive nil)
    :hook
    (org-mode . efs/org-mode-setup)
    (org-mode . my/set-general-faces-org)

    :general
    (:keymaps 'org-mode-map :states 'insert
              "M-h" #'org-promote-subtree
              "M-l" #'org-demote-subtree))

  ;; (use-package org
  ;;   :commands (org-capture org-agenda)
  ;;   :hook (org-mode . efs/org-mode-setup)
  ;;   :config
  ;;   (setq org-ellipsis " ▾")

  ;;   (setq org-agenda-start-with-log-mode t)
  ;;   (setq org-log-done 'time)
  ;;   (setq org-log-into-drawer t)

  ;;   (setq org-agenda-files
  ;;         '("~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org"
  ;;           "~/Projects/Code/emacs-from-scratch/OrgFiles/Habits.org"
  ;;           "~/Projects/Code/emacs-from-scratch/OrgFiles/Birthdays.org"))

  ;;   (require 'org-habit)
  ;;   (add-to-list 'org-modules 'org-habit)
  ;;   (setq org-habit-graph-column 60)

  ;;   (setq org-todo-keywords
  ;;         '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
  ;;           (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  ;;   (setq org-refile-targets
  ;;         '(("Archive.org" :maxlevel . 1)
  ;;           ("Tasks.org" :maxlevel . 1)))

  ;;   ;; Save Org buffers after refiling!
  ;;   (advice-add 'org-refile :after 'org-save-all-org-buffers)

  ;;   (setq org-tag-alist
  ;;         '((:startgroup)
  ;;                                         ; Put mutually exclusive tags here
  ;;           (:endgroup)
    ;;         ("@errand" . ?E)
    ;;         ("@home" . ?H)
    ;;         ("@work" . ?W)
    ;;         ("agenda" . ?a)
    ;;         ("planning" . ?p)
    ;;         ("publish" . ?P)
    ;;         ("batch" . ?b)
    ;;         ("note" . ?n)
    ;;         ("idea" . ?i)))

    ;; ;; Configure custom agenda views
    ;; (setq org-agenda-custom-commands
    ;;       '(("d" "Dashboard"
    ;;          ((agenda "" ((org-deadline-warning-days 7)))
    ;;           (todo "NEXT"
    ;;                 ((org-agenda-overriding-header "Next Tasks")))
    ;;           (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

    ;;         ("n" "Next Tasks"
    ;;          ((todo "NEXT"
    ;;                 ((org-agenda-overriding-header "Next Tasks")))))

    ;;         ("W" "Work Tasks" tags-todo "+work-email")

    ;;         ;; Low-effort next actions
    ;;         ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
    ;;          ((org-agenda-overriding-header "Low Effort Tasks")
    ;;           (org-agenda-max-todos 20)
    ;;           (org-agenda-files org-agenda-files)))

    ;;         ("w" "Workflow Status"
    ;;          ((todo "WAIT"
    ;;                 ((org-agenda-overriding-header "Waiting on External")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "REVIEW"
    ;;                 ((org-agenda-overriding-header "In Review")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "PLAN"
    ;;                 ((org-agenda-overriding-header "In Planning")
    ;;                  (org-agenda-todo-list-sublevels nil)
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "BACKLOG"
    ;;                 ((org-agenda-overriding-header "Project Backlog")
    ;;                  (org-agenda-todo-list-sublevels nil)
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "READY"
    ;;                 ((org-agenda-overriding-header "Ready for Work")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "ACTIVE"
    ;;                 ((org-agenda-overriding-header "Active Projects")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "COMPLETED"
    ;;                 ((org-agenda-overriding-header "Completed Projects")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "CANC"
    ;;                 ((org-agenda-overriding-header "Cancelled Projects")
    ;;                  (org-agenda-files org-agenda-files)))))))

    ;; (setq org-capture-templates
    ;;       `(("t" "Tasks / Projects")
    ;;         ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
    ;;          "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

    ;;         ("j" "Journal Entries")
    ;;         ("jj" "Journal" entry
    ;;          (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
    ;;          ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
    ;;          :clock-in :clock-resume
    ;;          :empty-lines 1)
    ;;         ("jm" "Meeting" entry
    ;;          (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
    ;;          :clock-in :clock-resume
    ;;          :empty-lines 1)

    ;;         ("w" "Workflows")
    ;;         ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

    ;;         ("m" "Metrics Capture")
    ;;         ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
    ;;          "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

    ;; (define-key global-map (kbd "C-c j")
    ;;   (lambda () (interactive) (org-capture nil "jj")))

    ;; (efs/org-font-setup)
    ;; )

#+end_src

***** Nicer Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in ~org-mode~ buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.

#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

**** Org Refiling

#+begin_src emacs-lisp :lexical no
  (use-package org
    :init
    (setq org-refile-use-outline-path t
          org-refile-targets
          '((org-agenda-files . (:maxlevel . 6))))

    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (defun crj-refile-in-current-buffer ()
      (interactive)
      (let ((org-refile-use-outline-path t)
            (org-refile-targets '((nil . (:maxlevel . 6)))))
        (org-refile))))
#+end_src

**** Org Exporting

Org mode can export to other formats—probably its strongest feature.

***** General Settings

Most of this is pretty standard, but I also do have my own CSS to make exporting a little better. It's dead simple, and I'm sure I will change it if I start exporting to HTML more seriously.

#+begin_src emacs-lisp :lexical no
  (use-package org
    :init
    (setq org-html-special-string-regexps nil
          org-html-postamble nil
          org-export-with-date nil
          org-export-with-section-numbers nil
          org-export-with-toc nil
          org-export-headline-levels 6
          org-babel-default-header-args `((:results . "verbatim pp replace output")
                                          (:exports . "both")
                                          (:noweb . "strip-export")
                                          (:session . "none")
                                          (:padline . "no"))

          org-html-head-extra
          "<style>.example::before {content: \"Results:\"; display: block; margin-bottom: 1em;}</style>"))

  #+end_src

***** Org Export to GFM

Org doesn't have at least one format I like using: Github Flavored Markdown. So let's add that with a package.

#+begin_src emacs-lisp :lexical no
  (use-package ox-gfm)
#+end_src

***** Importing Into Org Mode

Org Mode is great at exporting to other formats, but other formats usually don't export to Org. And there's no built-in way to do it, weirdly. So! Package time.

#+begin_src emacs-lisp :lexical no
  (use-package org-pandoc-import
    :straight (:host github
                     :repo "tecosaur/org-pandoc-import"
                     :files ("*.el" "filters" "preprocessors")))
#+end_src

**** Org Code Evaluation

Literate programming for fun and profit. Or... at least, for fun.

#+begin_src emacs-lisp :lexical no
  (use-package ob-racket
    :straight (:host github :repo "DEADB17/ob-racket"))

  (use-package emacs
    :init
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       ;; (sql-mode . t)
       (racket . t)
       ;; (python . t)
       ;; (ipython . t)
       ;; (bash . t)
       ;; (sh . t)
       ;; (js . t)
       ;; (javascript . t)
       ;; (sql . t)
       ;; (go . t)
       )))
#+end_src

*** Markdown

The not-quite-as-good-as-Org-but-more-universally-spoken markup language.

Now heavily customized!

Let's see if we can hit these quickly. We:

- set ~gfm-mode~ to be the main mode we use for Markdown files.
- set Variable Pitch mode to run in Markdown buffers
- set a bunch of markdown-mode's configuration variables you can check out yourself
- make sure our fonts scale appropriately
- add a command to add a new heading, similar to org mode's approach (should definitely be refactored at some point)
- set my favorite JS mode to run for JS code blocks: RJSX Mode
- allow promotion, demotion, and movement in insert state
- Add ~edit-indirect~, a package that allows you to edit an embedded code block in a dedicated code-oriented buffer in Markdown buffers, which is another, "Oh, cuuuute, it thinks it's Org Mode!" kind of feature.
- Add some Evil keybindings with Evil Markdown Mode.

And we're done at a mere 58 lines of code! (Though... again, I can probably simplify my little custom add-a-heading function.)

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode ("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . gfm-mode)

    :gfhook #'variable-pitch-mode

    :init
    (setq markdown-indent-on-enter 'indent-and-new-item
          markdown-list-indent-width 2
          markdown-fontify-code-blocks-natively t
          markdown-asymmetric-header t)

    (defun crj-add-markdown-header ()
      "Add a markdown header after the current one, at the same level."
      (interactive)
      (let ((level (crj--get-markdown-level)))
        (when (thing-at-point-looking-at markdown-regex-header)
          (forward-char))
        (if (re-search-forward markdown-regex-header nil t)
            (forward-line -1)
          (goto-char (point-max)))
        (markdown-insert-header level nil nil))
      (when (featurep 'evil)
        (evil-insert-state)))

    (defun crj--get-markdown-level ()
      "Helper function to get the current markdown heading level.

  Used by `crj-add-markdown-header'"
      (save-excursion
        (unless (thing-at-point-looking-at markdown-regex-header)
          (re-search-backward markdown-regex-header nil t))
        (markdown-outline-level)))

    :config
    (add-to-list 'markdown-code-lang-modes '("javascript" . rjsx-mode))

    :general
    (general-def 'insert markdown-mode-map
      "M-l" #'markdown-demote
      "M-h" #'markdown-promote
      "M-k" #'markdown-move-up
      "M-j" #'markdown-move-down)

    (general-def '(insert normal) markdown-mode-map
      "C-<return>" #'crj-add-markdown-header))

  (use-package edit-indirect)

  (use-package evil-markdown
    :straight (:host github
                       :repo "Somelauw/evil-markdown")

    :after markdown-mode

    :ghook ('(markdown-mode-hook gfm-mode-hook)))
#+end_src

*** HTML

The ugly-but-fully-featured markup language.

#+begin_src emacs-lisp
  (use-package web-mode
    :commands (web-mode)

    :mode (("\\.html" . web-mode)
           ("\\.htm" . web-mode)
           ("\\.sgml\\'" . web-mode))

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-comment-style 2))
#+end_src

** Evil Mode

Time to spend a vast amount of time thinking through Vim-style keybindings!

TODO Delete the ~gj~/~j~ bindings once I find the part of the Emacs For Scratch bindings where they're changing them.

*** Transposing Characters

Before we get to the Evil mode setup, this is a small function I wrote to transpose characters with one Vimmish atomic action. It's the first thing here in Evil Mode because, at some point, I want to get into why this is a very Vimmish function, since it might serve as a good introduction to this section.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun crj-evil-transpose-chars ()
      "Transpose characters as one vim-style action.

    Wraps the function `transpose-chars' so that it's more in the style of Evil
    Mode/Vim. (See info node `(evil)Overview')

    - Acts on the current character and the one to the right, which is more in line
    with Vim's Normal Mode style.
    - Adds the entire process as one action, adding undo/repeat ability.

    This differs greatly from the more Emacs-like `transpose-chars', which allows
    you to drag a character forward as far as you want, using a count, but this
    author found that he preferred the atomicity of Normal Mode.

    See `transpose-chars' for more info on the original function."
      (interactive)
      (evil-with-undo
        (forward-char)
        (transpose-chars 1)
        (backward-char 2)))

    :general
    (:keymaps 'normal :prefix "g"
              "b" '(crj-evil-transpose-chars :which-key "Transpose characters.")))

#+end_src

A title-case operator!

#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-define-operator evil-title-case (beg end type)
      "Convert text to title case."
      (if (eq type 'block)
          (evil-apply-on-block #'evil-titlecase beg end nil)
        (upcase-initials-region beg end)))

    :general
    (:keymaps 'motion :prefix "g"
                  "H" '(evil-title-case :which-key "Title-case operator.")))
#+end_src

*** Evil Mode Setup

There are just a ton of variables here that finely set how Evil Mode is configured. Look at the definition of any of them using ~describe-variable~ to see what they do and what their possible values are!

#+begin_src emacs-lisp
  (use-package evil
    :init
    (defun crj--escape-plus ()
      (evil-ex-nohighlight))

    (advice-add 'evil-force-normal-state :after #'crj--escape-plus)

    (global-subword-mode)
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-ex-search-persistent-highlight t
          evil-ex-substitute-global t
          sentence-end-double-space nil
          evil-want-C-u-scroll t
          evil-want-C-i-jump t
          evil-want-Y-yank-to-eol t
          evil-undo-system 'undo-redo
          evil-want-fine-undo t
          evil-mode-line-format 'nil
          evil-symbol-word-search t
          evil-visual-state-cursor 'hollow
          evil-ex-interactive-search-highlight 'selected-window
          evil-kbd-macro-suppress-motion-error t
          evil-respect-visual-line-mode nil)

    :config
    (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
    (evil-mode 1)
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-define-key 'motion 'global
      "j" #'evil-next-line
      "gj" #'evil-next-visual-line
      "k" #'evil-previous-line
      "gk" #'evil-previous-visual-line
      "$" #'evil-end-of-line
      "g$" #'evil-end-of-visual-line)

    (dolist (mode '(custom-mode
                    eshell-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode))

    :bind
    ("C-M-u" . universal-argument))
  #+end_src

**** Evil Collection

This library provides Evil Mode bindings for non-standard buffers, e.g. Magit.

I've reworked some of the ~evil-collection-unimpaired~ bindings to be a bit more mnemonic to me. ~[m~ and ~]m~ move text up and down by lines, while ~[e~ and ~]e~ should navigate to errors. ~[l~ and ~]l~ I will set later to some Lisp manipulation commands.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :init
    (evil-collection-init)
    (evil-collection-quickrun-setup)

    :general
    (general-unbind '(normal visual motion) evil-collection-unimpaired-mode-map
      "]l"
      "[l"
      "[m"
      "]m"
      "[e"
      "]e")

    (general-def '(normal visual motion) :prefix "["
              "m" '(evil-collection-unimpaired-move-text-up :which-key "Move text up.")
              "e" '(evil-collection-unimpaired-previous-error :which-key "Go to previous error."))
    (general-def '(normal visual motion) :prefix "]"
              "m" '(evil-collection-unimpaired-move-text-down :which-key "Move text down.")
              "e" '(evil-collection-unimpaired-next-error :which-key "Go to next error.")))
      #+end_src

*** Evil Keybindings for Org Mode

This library adds some basic Evil bindings. In addition to the "key themes"" you'll find in [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org][the Evil Org keythemes documentation]], I've included their awesome ~RET~ function, which continues list items and other such.

#+begin_src emacs-lisp
  (use-package evil-org
    :after (evil org)

    :init
    (add-hook 'org-mode-hook #'evil-org-mode)
    (setq org-return-follows-link t
          evil-org-use-additional-insert t)

    :config
    (evil-org-set-key-theme '(textobjects todo additional))

    :general
    (:keymaps 'org-mode-map :states 'insert
              "RET" #'evil-org-return)
    (:keymaps 'org-mode-map :states '(motion normal visual)
              "gl" #'org-down-element
              "gh" #'org-up-element
              "gk" #'org-backward-element
              "gj" #'org-forward-element))
#+end_src

*** Emacs In Vim In Emacs

Bringing back some Emacs commands to use in Insert State.

The short-range, simple Emacs commands are often easier to use when you don't want to switch to Normal State for editing and then back to Insert State to immediately get back to writing. Faster to type ~C-w~ to delete the word you're currently typing and then replace it, rather than ~ESC ciw~. Or, worse, a situation where your editing doesn't bring you back to insert mode in the right place, like when the word /before/ your current word should be deleted—now you're talking about ~ESC bb daw A~ using Vim, but simply ~M-b C-w C-e~ with Vanilla Emacs bindings.

I'm still a /big/ fan of modal editing, since you spend so much time straight up editing, but sometimes, particularly when writing prose, you don't want a minor edit to break your flow.

[[./assets/funky-flow.gif]]

Also included is a nifty function that deletes everything but one space before the cursor, super useful if you've accidentally got a bunch of accidental whitespace. Very occasionally super useful.

#+begin_src emacs-lisp
  (use-package evil
    :general
    (:states 'insert
             "C-n" #'next-line
             "C-p" #'previous-line
             "C-e" #'end-of-visual-line
             "C-a" #'beginning-of-visual-line
             "C-d" #'delete-char
             "<S-backspace>" #'just-one-space))
#+end_src

*** Visualizing Evil Commands

~evil-goggles~ helps you to visualize the text object you just worked on. Particularly useful for Evil yanks.

#+begin_src emacs-lisp
  (use-package evil-goggles
    :after evil

    :init
    (setq evil-goggles-duration 0.3
          evil-goggles-pulse nil
          evil-goggles-enable-delete nil
          evil-goggles-enable-change nil)

    :config
    (evil-goggles-mode))
#+end_src

*** Working With Surrounding Text In Evil

This library is amazing for working with surrounding text. Changing double quotes to single, parens to square brackets, etc., and also wrapping and unwrapping: surround this line with square brackets, surround the surrounding curly brackets with parens, delete the surrounding curly brackets, and so on. Huge efficiency saver.

#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil

    :config
    (global-evil-surround-mode 1))
#+end_src

**** TODO add Evil Embrace

*** Evil-Style Commenting

Really really great way to handle comments.

  #+begin_src emacs-lisp
    (use-package evil-nerd-commenter
      :after evil

      :config
      :general
      ([remap comment-line] #'evilnc-comment-or-uncomment-lines)
      (:keymaps 'normal :prefix "g"
                "c" '(evilnc-comment-operator :which-key "Toggle comment.")
                "C" '(evilnc-copy-and-comment-operator :which-key "Copy and comment.")
                "K" '(evilnc-comment-box :which-key "Create comment box."))

      (general-def 'normal evil-inner-text-objects-map
        "c" #'evilnc-inner-comment)
      (general-def 'normal evil-outer-text-objects-map
        "c" #'evilnc-outer-comment))
#+end_src

*** Replace With Clipboard In Evil

This is an invaluable command, especially since it's a motion I can combine with a text object.

Being able to type ~SPC r i )~ to say "replace what's in these parens with what I just copied to the kill ring" is amazingly efficient text editing.

#+begin_src emacs-lisp
  (use-package evil-replace-with-register
    :after evil

    :general
    (crj-leader-keys
              "r" '(evil-replace-with-register
                    :which-key "Replace text with register.")))
#+end_src

*** Evil Motion For Exchanging Text

Another efficient text editing library. This one exchanges two bits of text in an extremely Evilly way.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :after evil

    :general
    (:states '(normal visual)
             "gx" '(evil-exchange :which-key "Exchange text objects.")))
#+end_src

*** Evil Jump-To-Matching For Opening And Closing Delimiters

Normally, Evil jumps between brackets with ~%~. Here's one library for opening that up to things like ~if~ and ~else~ and HTML opening/closing tags and anything else you can imagine/configure.

#+begin_src emacs-lisp :lexical no
  (use-package evil-matchit
    :init
    (global-evil-matchit-mode 1))
#+end_src

*** Evil Text Objects

Text Objects are a powerful concept in Vim/Evil. Let's add our own!

**** HTML Attribute Evil Text Object

This package gives you an Evil text object for XML/HTML attributes. It's helpful!

#+begin_src emacs-lisp
(use-package exato
  :commands (evil-outer-xml-attr evil-inner-xml-attr))
#+end_src

**** Evil Argument Text Object

#+begin_src emacs-lisp :lexical no
  (use-package evil-args
    :general
    (general-def evil-inner-text-objects-map
  	    "a" 'evil-inner-arg)
    (general-def evil-outer-text-objects-map
  	    "a" 'evil-outer-arg))
#+end_src

**** Entire Buffer Evil Text Object

A surprisingly useful Evil text object for the entire buffer.

#+begin_src emacs-lisp
  (use-package evil-textobj-entire
    :after evil

    :straight (evil-textobj-entire
               :host github
               :repo "nscoder/evil-textobj-entire"))
  #+end_src

**** Between Characters Text Object

I'm pretty sure I'm going to find a use for this!

#+begin_src emacs-lisp :lexical no
  (use-package evil-textobj-between
    :straight (:host github
                     :repo "tarao/evil-plugins"
                     :files ("evil-textobj-between.el"))

    :custom
    (evil-textobj-between-a-key "t")
    (evil-textobj-between-i-key "t"))
#+end_src

**** Evil Text Object For A Line

This is a weird one, since Evil is /designed/ to work with lines—it's one of its central ways to work, to the point where repeating an operator like ~d~ or ~c~ or many third-party operators defaults to acting on the line.

Making it an official text object with an inner variant does, however, allow you to work on the /text/ of the line without any indentation or trailing whitespace.

And if you want the indentation or trailing whitespace, you can work with the outer variant. Or, again, just the standard work-on-a-line-by-default version of any command!

#+begin_src emacs-lisp :lexical no
  (use-package evil-textobj-line)
#+end_src

*** Evil Search From Visual Mode

Allows you to select some text in Visual State and then hit ~*~ or ~#~ to search for that text. Very occasionally very useful!

#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil

    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backward)
    :init
    (global-evil-visualstar-mode))
#+end_src
**** TODO add targets
**** TODO add Tree-sitter in Emacs 29

*** Evil Motion For Diffing Text

Shows you the difference between two different bits of text. Another very occasionally very useful trick.

#+begin_src emacs-lisp
  (use-package evil-quick-diff
    :after evil

    :init (evil-quick-diff-install)

    :straight (evil-quick-diff
               :type git
               :repo "https://github.com/rgrinberg/evil-quick-diff")

    :commands (evil-quick-diff evil-quick-diff-cancel))
#+end_src

*** Evil Evaluating

#+begin_src emacs-lisp :lexical no
  (use-package evil-extra-operator
    :general
    (crj-leader-keys
      "e" #'evil-operator-eval
      "E" #'evil-operator-eval-replace
      "C" #'evil-operator-clone))
#+end_src

*** Number Incrementing and Decrementing

#+begin_src emacs-lisp
  (use-package evil-numbers
    :general
    (:keymaps 'normal :prefix "g"
                  "=" '(evil-numbers/inc-at-pt :which-key "Increment operator.")
                  "-" '(evil-numbers/dec-at-pt :which-key "Decrement operator."))
    (:keymaps 'visual :prefix "g"
                  "=" '(evil-numbers/inc-at-pt-incremental :which-key "Increment operator.")
                  "-" '(evil-numbers/dec-at-pt-incremental :which-key "Decrement operator.")))
#+end_src

** Search

Searching is something Emacs does very, /very/ well.

We'll build in a search menu first.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys "s" '(:ignore t :which-key "Search Menu")))
#+end_src

  We'll use various ~consult~ commands to search through different sets of data.

  We'll also use a custom command for searching text in project files, though it's got a TODO to make it worth having the custom command at all. Consider it a placeholder for now, until such sanity checks are more of a priority.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun crj-search-project (&optional dir initial)
      "Search through text in project files.

  Searches with rg for files in DIR with INITIAL input.

  TODO add check for presence of ripgrep binary, falling back to grep."

      (interactive "P")
      (consult-ripgrep dir initial))

    :general
    (crj-leader-keys
      "sp" '(crj-search-project :which-key "Search text in project files.")
      "sd" '(consult-find :which-key "Search file names in directory.")
      "sm" '(consult-mark :which-key "Search the marks list.")
      "se" '(consult-flymake :which-key "Search through errors.")
      "sb" '(consult-bookmark :which-key "Search through bookmarks list.")
      "ss" '(consult-xref :which-key "Search symbols in project.")
      "sr" '(consult-register-load :which-key "Search registers (Evil clipboard).")
      "sy" '(consult-yank-from-kill-ring :which-key "Search kill ring (Emacs clipboard).")
      "sn" '(consult-goto-line :which-key "Search line numbers.")))
#+end_src

And finally, since I do this search so often, it's got a quicker shortcut of ~SPC SPC~.

#+begin_src emacs-lisp
      (use-package emacs
        :general
        (crj-leader-keys
          "SPC" '(project-find-file :which-key "Find file within current project.")))
#+end_src

*** TODO add more ~consult~ searches

** Look and Feel

*** Basic UI Configuration

These are some sane defaults for the UI.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq inhibit-startup-message t)
    (setq visible-bell t)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (set-fringe-mode 10)
    (menu-bar-mode -1)
    (global-visual-line-mode 1)
    (setq visible-bell t))
#+end_src

If you're just getting started in Emacs, the menu bar might be helpful so you can remove the ~(menu-bar-mode -1)~ line if you'd like to discover common commands. However, in terms of discovering things in Emacs, there are much better ways to do it, such as the ~describe~ functions, ~which-key~, and, when you et there, reading source code. The single best thing about Emacs is how completely effortless it is to peek at the source code for almost every single thing you can do here. Learn how to dive as far as you want into how something works, and you'll be able to grow in your knowledge at your own learning pace, whether it's slow and steady or voracious.

*** Fonts

First, some definitions of the fonts I use. For Emacs in code, eventually, and for you—and future me!—in this document.

My overly arcane setup includes /three/ fonts, all /very/ different in their style and usage.

The font I see in Emacs as I write this text looks like this:

[[./assets/variable-pitch.png]]

That font is IBM Plex Serif, which is a standard-style variable-pitch serif font. It's "serif" because it's /fancy/. If you look close, you can see that some of the letters have extra little curly bits, called serifs—look at the capital "T" in the "The quick brown fox" line for an example. And, most relevantly, it's a "variable-pitch" font, which means that the characters vary in pitch (a.k.a. width). This is easiest to see in the "nnnnn" and "mmmmm" lines: the "n" line is much shorter than the "m" line because the latter character is wider than the former. This type of font is perfect for writing prose, where the letters are given the breathing room we're used to seeing them in.

In my Emacs setup, this font is /only/ used in text and markup documents like Org Mode and Markdown, where I'm doing lots of classic writing and reading.

The second font I use is Hack, which is a "fixed pitch" font—more often called a "monospace" font. Here is a similar font in a terminal:

[[./assets/fixed-pitch.png]]

Most people use a fixed-pitch font for code for several reasons, but we'll get to those in a second. The main feature of a fixed-pitch font is that the width doesn't vary. You'll notice in the sample above that the "nnnnn" and "mmmmm" lines are the same length. Having all characters be the exact same width makes alignment easier, which many developers use to keep similar columns of code lined up just so.

The last font is Input, which is another variable pitch font, but one that's very, very different than most. You can see it in the Emacs terminal pictured below:

[[./assets/variable-pitch-coding-font.png]]

If you look closely at Input, it's variable-pitch, no question. The "mmmmm" line is longer than the "nnnnn" line, and the characters are generally less squished-in. Since developers swear by fixed-pitch coding fonts, no respected developer would use this font as a coding font.

I am not a respected developer.

I use Input for coding because when I head about a minority of developers using a variable pitch font for coding, I read up on it, and the few articles I read in defense of it were pretty convincing.

See, many developers will tell you that the big difference between the two types of fonts, besides alignment, is that a variable-pitch font doesn't give enough space to coding symbols like parentheses and curly brackets and ~!~ and ~:~ and ~/~,  characters that a fixed-pitch font gives equal width to (because fixed-pitch fonts give /everything/ the same length) And it's true that if I try to write code in my prose font (see first sample!), it's much harder to make out the important-to-code characters.

But variable-pitch fonts don't /have/ to give coding symbols short shrift. Look at the Input sample above—the coding characters are given plenty of width! You see, fixed-pitch fonts give everything the same width, whether it's a ~!~ or an ~n~ or an ~m~. In that way, they're making the decision that every character is equally important and needs the same amount of width. It's a shortcut solution, treating all characters the same to give coding characters with the space they need, but it's not making an actual /decision/ as to what to prioritize.

Coding fonts should prioritize code symbols, and prose fonts should prioritize letters more. But /why not both/.

[[./assets/why-not-both.gif]]

Why not a font that gives code symbols plenty of space to make them properly stand out for their syntactic meaning, without bizarrely deciding that alignment is more important than letter readability? Why not a font that makes /everything/ readable? When your wide letters like "m" and "w" and "c" are squished in while skinny letters like "t" and "l" and "i" are weirdly widened, what you get is a one-size-fits-all approach that prioritizes... nothing in particular. Except trying not to deprioritize anything.

When reading and writing, priorities matter. You want symbols to be readable, because you /definitely/ don't want to miss them as you're reading the code, but you /also/ want to be able to read those function and variable names. A variable-pitch font designed carefully to create a great coding experience unsurprisingly beats a font that is designed simply /not/ to deprioritize symbols.

There's actually even more to say about this than I thought going in, but I'll leave it here for now.

So how do I use these fonts? Well, I still do use my fixed-pitch Hack font for a few places, where alignment can super matter. For files where the columns matter, like spreadsheets and tables, I still use them. I also use them for line numbers, so as to keep the left margin aligned. Otherwise, though, it's Input for coding, and IBM Plex Mono (my variable-pitch serif font) for writing.

Final thing before I get to the code: yes, this is a lot of work for fonts. And I'm not even a font expert! I /do/ think readability matters quite a great deal. But I think there are two related elements of my character that have lead me down this path.

The desire to make my system my own. To craft an app I can live in every day, that I can not only code in but write emails in and use to check the weather and browse the web and manage my local files and manage my cloud files and write blog posts and chat with friends and organize my life, and to /keep/ crafting that personalized app, spending a fair amount of my valuable time making the rest of my work time fun enough to get me through the day.

But the other, and related reason, is that everyone likes to be a little different and weird and have opinions that make you feel smart, even if the end result is just that you have a bizarre font choice that on-lookers likely won't even notice.

The desire to be just a bit of an iconoclast.

[[./assets/iconoclast.gif]]

It's important to make fun of yourself for doing so, but that doesn't change the fact that it feels /good/ to be that weird guy who always wears hats or learned Esperanto or decided Vim was somehow /too mainstream/.

That guy's me, and you're welcome, and I'm sorry.

Here are my font settings.

#+begin_src emacs-lisp
  (defvar crj--fixed-pitch-font "Hack")
  (defvar crj--variable-pitch-coding-font "Input")
  (defvar crj--variable-pitch-font "IBM Plex Serif")
  (defvar crj--coding-font crj--variable-pitch-coding-font)
  (defvar crj--emoji-font "Noto Color Emoji")
  (defvar crj--default-font-size 110)

  (use-package emacs
    :config
    (when (member "Noto Color Emoji" (font-family-list))
      (set-fontset-font
       "fontset-default" 'unicode
       (font-spec :family "Noto Color Emoji")
       nil
       'prepend))

    (set-face-attribute 'default nil
                        :font crj--coding-font
                        :height crj--default-font-size)

    (set-face-attribute 'fixed-pitch nil
                        :font crj--coding-font
                        :height 1.0)

    (set-face-attribute 'variable-pitch nil
                        :font crj--variable-pitch-font
                        :height 1.0
                        :weight 'regular))
#+end_src

And a picture of what my setup actually looks like:

[[./assets/font-setup-screenshot.png]]

**** TODO redo font size as calculated based on resolution

**** Using Fixed Pitch In Some Buffers

#+begin_src emacs-lisp
  (defface crj--monospace
    '((t
       :family "Hack"
       :foundry unspecified
       :width normal
       :height 1.0
       :weight normal
       :slant normal
       :foreground "#505050"
       :distantForeground unspecified
       :background "#f8f8f8"
       :underline nil
       :overline nil
       :strike-through nil
       :box nil
       :inverse nil
       :stipple nil
       :font "Hack"
       :fontset unspecified
       :extend nil))

    "Face for monospace fonts.")

  (defun crj--use-fixed-pitch ()
    "Make the current buffer use a fixed pitch.

  Sometimes I really do want fixed-pitch for alignment, such as with terminals."
    (interactive)
    (set (make-local-variable 'buffer-face-mode-face) 'crj--monospace)
    (buffer-face-mode t))

  ;; Hooks for modes I want to use fixed pitch in.
  (setq crj--fixed-pitch-mode-hooks
        '(vterm-mode-hook
          calendar-mode-hook
          proced-mode-hook
          cfw:calendar-mode-hook
          minibuffer-setup-hook
          mu4e-headers-mode-hook
          magit-log-mode-hook))

  ;; Add the fixed-pitch function for each mode.
  (dolist (hook crj--fixed-pitch-mode-hooks)
    (add-hook hook #'crj--use-fixed-pitch))
#+end_src


*** Zooming Text

Zooming in and out in Emacs is... tricky. Part of this is because fonts in general are tricky! And part of it is that Emacs gives you so much control over your fonts that there are a /lot/ of moving parts, making it trickier still. And the last part is that Emacs' font system is hugely unintuitive.

Still, I've got a /pretty/ good system for zooming fonts up and down, here. It's split into zooming per-buffer and zooming globally, depending on your needs. It's easy to zoom more or less for fine-grained refinement, while also being easy to zoom by huge amounts in one go with a count.

There are some edge cases here, though, so I'll probably be returning to it.

First, some functions to zoom and reset one buffer:

#+begin_src emacs-lisp
  (defun crj-zoom-in (arg)
    "Incease text size in current buffer.

  ARG is a count—increase the count to zoom in more."
    (interactive "p")
    (text-scale-increase arg))

  (defun crj-zoom-out (arg)
    "Decrease text size in current buffer.

  ARG is a count—increase the count to zoom out more."
    (interactive "p")
    (text-scale-increase (* arg -1)))

  (defun crj-zoom-reset ()
    "Reset current buffer's text size to default."
    (interactive)
    (text-scale-increase 0))
#+end_src

From there, I can use those to zoom in on all current buffers. These functions simply loop through all the buffers in the ~buffer-list~ and run the above functions in each.

#+begin_src emacs-lisp
  ;; I will add these eventually if I work further on the current-zoom-level-as-a-global-variable idea.
  ;; (defvar current-text-scale 0)
  ;; (defun crj-match-new-buffer-to-current-text-scale ()
  ;;   (interactive)
  ;;   (text-scale-increase 0)
  ;;   (text-scale-increase text-scale-mode-amount))
  ;; (add-hook 'after-set-visited-file-name-hook #'crj-match-new-buffer-to-current-text-scale)

  (defun crj-zoom-in-all-buffers (arg)
    "Zooms in on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-in arg))))

  (defun crj-zoom-out-all-buffers (arg)
    "Zooms out on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-out arg))))

  (defun crj-zoom-reset-all-buffers ()
    "Resets zoom for all current buffers to default level."
    (interactive)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-reset))))
#+end_src

This package, ~default-text-scale~, can handle things more robustly than the homegrown situation above, in that it change the font size for other existing "frames" (what every other program would call a window), and for new frames moving forward.

#+begin_src emacs-lisp :tangle no
  (use-package default-text-scale
    :init (default-text-scale-mode))
#+end_src

But since their solution causes the default font size to reset, along with every font that inherits from it, every time it hits a font size for the first time in an Emacs session, there's a slowdown where the screen goes blank for a jarring second. (Possibly exacerbated by how many disparate fonts  I have going on—see the Fonts section below.) It also doesn't have the ability to take a count, though there's probably a way to wrap the functions to make that happen.

All of this is to say that the many many different ways you can manipulate and work with multiple fonts in Emacs, across as many frames and buffers and windows as you've got open, makes zooming a bit of a complex mess. ~default-text-scale~ is the most powerful system I've seen for it, but... although external libraries by accomplished Emacs Lisp programmers are almost always better than what an okay-ish programmer like me can do, I think I'm going to stick with my simple and flexible system this time.

Next, we make some keybindings for them.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
              "z" '(:ignore t :which-key "Zooming Menu")
              "zj" '(crj-zoom-in-all-buffers :which-key "Zoom in globally.")
              "zk" '(crj-zoom-out-all-buffers :which-key "Zoom out globally.")
              "zb" '(crj-zoom-reset-all-buffers :which-key "Reset zoom globally.")
              "zJ" '(crj-zoom-in :which-key "Zoom in.")
              "zK" '(crj-zoom-out :which-key "Zoom out.")
              "zB" '(crj-zoom-reset :which-key "Reset zoom.")))
#+end_src

And finally, there's a special type of Emacs interface I don't use often, a third-party package called Hydra, that's perfect for an activity like zooming text. Once you've decided to zoom, you're entering a kind of session where you'll be entering related commands. You'll be zooming in a couple times, then zooming out if you've gone too far. And at that point that can even repeat, if you change your mind as to what zoom level you act~ally want. What Hydra does is enter an interface perfect for this kind of situation.

With the below code, the user (almost definitely me!) can type ~SPC z z~, at which point, instead of entering complex keybindings, they can type ~j~ to zoom in, ~k~ to zoom out (these are meaningful letters to Vim users), do that as much as they want, and then get back to what they were doing by pressing ~escape~ or any other key that's not part of this system.

There are other, similar libraries (I've heard Transient is even better), but I highly recommend an interface like this. It's fantastic.

We'll install Hydra, define its interface, and then put that hydra command in our keybindings.

#+begin_src emacs-lisp
  (use-package hydra
    :config
    (defhydra crj-hydra/text-zoom (:hint nil :color red)
      "
  	Global zoom: _j_:zoom in, _k_:zoom out, _b_:reset
  	Buffer zoom: _J_:zoom in, _K_:zoom out, _B_:reset
  "
      ("J" crj-zoom-in)
      ("K" crj-zoom-out)
      ("B" crj-zoom-reset)
      ("j" crj-zoom-in-all-buffers)
      ("k" crj-zoom-out-all-buffers)
      ("b" crj-zoom-reset-all-buffers))
    :general
    (crj-leader-keys
      "zz" '(crj-hydra/text-zoom/body :which-key "Zoom hydra interface.")))
#+end_src

**** TODO add ability to zoom to preset big size.
**** TODO add to new-buffer-hook to adjust to current text scale?
**** TODO add "i" and "o" (or switch those with j/k?) to zoom in by larger increments

*** Scrolling

This package makes scrolling big distances easier to follow by flashing the new line you've moved to.

#+begin_src emacs-lisp
  (use-package pulsar
    :init
    (setq pulsar-pulse t)
    (setq pulsar-delay .01)
    (setq pulsar-iterations 30)
    (setq pulsar-face 'pulsar-generic)
    :config
    (setq crj--far-jumping-functions '(evil-scroll-up
                                       evil-scroll-down
                                       evil-goto-line
                                       evil-beginend-prog-mode-goto-beginning
                                       evil-beginend-prog-mode-goto-end
                                       evil-beginend-org-mode-goto-beginning
                                       evil-beginend-org-mode-goto-end
                                       evil-beginend-dired-mode-goto-beginning
                                       evil-beginend-dired-mode-goto-end
                                       evil-beginend-message-mode-goto-beginning
                                       evil-beginend-message-mode-goto-end
                                       evil-beginend-org-agenda-mode-goto-beginning
                                       evil-beginend-org-agenda-mode-goto-end
                                       evil-beginend-compilation-mode-goto-beginning
                                       evil-beginend-compilation-mode-goto-end
                                       evil-beginend-magit-status-mode-goto-beginning
                                       evil-beginend-magit-status-mode-goto-end
                                       evil-beginend-magit-revision-mode-goto-beginning
                                       evil-beginend-magit-revision-mode-goto-end
                                       evil-goto-first-line
                                       evil-goto-mark-line
                                       evil-scroll-page-up
                                       evil-scroll-page-down
                                       bury-buffer
                                       kill-buffer
                                       crj--toggle-presentation-mode
                                       delete-other-windows
                                       winner-undo
                                       evil-window-up
                                       evil-window-down
                                       evil-window-left
                                       evil-window-right
                                       evil-window-new
                                       evil-window-vnew))

    (dolist (function crj--far-jumping-functions)
      (add-to-list 'pulsar-pulse-functions function))

    (pulsar-global-mode 1))
#+end_src

*** Line Numbers

**** Basic Line Number Settings

Sets up line numbers to be (almost) everywhere, just not in some terminal modes.

I like to use relative line numbers, since they make line-wise work easier when using Evil Mode. Which I do.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq display-line-numbers-type 'relative
          magit-disable-line-numbers nil
          magit-section-disable-line-numbers nil)

    (global-display-line-numbers-mode t)

    (defun crj--turn-off-line-numbers ()
      (display-line-numbers-mode 0))

    (defconst crj--hooks-for-modes-without-line-numbers '(term-mode-hook
                                                        vterm-mode-hook
                                                        shell-mode-hook
                                                        treemacs-mode-hook
                                                        eshell-mode-hook))

    (dolist (hook crj--hooks-for-modes-without-line-numbers)
      (add-hook hook #'crj--turn-off-line-numbers)))
#+end_src

**** Make Line Numbers Use Fixed Pitch

This next part is for making line numbers use a fixed pitch font. I like a variable pitch coding font, but line numbers get janky if they're not fixed pitch.

And by setting line numbers to an absolute size, we also avoid having them increase in size with everything else. Ideally I would increase their size too when zooming, just at a lesser rate. But this is good enough for now.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq crj--line-number-faces '(line-number
                                   line-number-current-line
                                   line-number-major-tick
                                   line-number-minor-tick))

    (defun crj-make-line-number-face-monospace (&rest args)
      "Makes line numbers monospace and fixes them in size."
      (interactive)
      (dolist (face crj--line-number-faces)
        (set-face-attribute face nil
                            :family crj--fixed-pitch-font
                            :height 1.0))
      args)

    (add-hook 'emacs-startup-hook #'crj-make-line-number-face-monospace))
#+end_src

**** Cycle Line Numbers

When displaying code to others, it's often good to make the line numbers absolute. And hiding them can be nice sometimes, though if I'm doing that often, I should consider whether there are more modes I should turn line numbers off for.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (defun crj-cycle-line-numbers ()
      (interactive)
      (crj-cycle-setting 'display-line-numbers '(relative t nil)))

    :general
    (crj-leader-keys
      "tl" '(crj-cycle-line-numbers :which-key "Cycle line numbers globally.")))
#+end_src

**** TODO make line numbers increase in size at a lower rate. This command could be useful:

#+begin_src emacs-lisp
  (defun crj--reset-line-number-height ()
    (set-face-attribute 'line-number nil :height crj--default-font-size))
#+end_src

*** Indentation

**** Spaces Over Tabs

The eternal struggle.

(I'm referring of course to both the struggle between the two sides and the struggle between the user and Emacs.)

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq-default indent-tabs-mode nil)
    (setq standard-indent 2))
#+end_src

**** Visualize Indentation Level

Let's visualize our indentation!

#+begin_src emacs-lisp :lexical no
  (use-package highlight-indent-guides
    :ghook 'prog-mode-hook

    :custom
    (highlight-indent-guides-method 'bitmap))
#+end_src

*** Folding

#+begin_src emacs-lisp :lexical no
  (use-package vimish-fold)
  (use-package evil-vimish-fold
    :init
    (setq evil-vimish-fold-target-modes '(prog-mode text-mode))
    (global-evil-vimish-fold-mode))
#+end_src

** Applications

This section is for parts of Emacs that are well-integrated applications.

Let's set up a keybinding for applications, and then we can put these apps under it!

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
      "a" '(:ignore t :which-key "Applications Menu")))
#+end_src

*** Internet Radio with Eradio

I love this no-hassle don't-have-to-think-about-what-to-listen-to background music. I need need /need/ music to focus.

#+begin_src emacs-lisp
  (use-package eradio
    :init
    (setq eradio-channels '(("SomaFM - Fluid" . "https://somafm.com/fluid.pls")
                            ("LO FLY Radio" . "http://64.20.39.8:8421/listen.pls?sid=1&t=.pls")
                            ("SomaFM - Groove Salad." . "https://somafm.com/groovesalad.pls")
                            ("SomaFM - Secret Agent" . "https://somafm.com/secretagent.pls")))
    :general
    (crj-leader-keys
      "aM" '(eradio-play :which-key "Play internet radio.")
      "am" '(eradio-stop :which-key "Stop playing internet radio.")))
#+end_src

*** RSS with Elfeed

RSS might be a great technology? I'm only just getting into it with this package!

#+begin_src emacs-lisp
  (use-package elfeed
    :commands elfeed

    :init
    (setq elfeed-feeds '("https://planet.emacslife.com/atom.xml"))

    :general
    (crj-leader-keys
      "ar" '(elfeed :which-key "Launch RSS reader.")))
#+end_src

*** Vterm

Of the many types of terminals in Emacs, Vterm is the most faithful to the standard terminal emulator. Note that this does not mean it's the best, but it /does/ work the way folks expect if they're used to the standard terminal emulator experience.

Let's use a wrapper around it that allows multiple terminals.

#+begin_src emacs-lisp
  (use-package multi-vterm
    :init
    (setq vterm-shell "/usr/sbin/zsh"
          vterm-always-compile-module t
          vterm-max-scrollback 100000)

    :general
    (crj-leader-keys
      "av" '(multi-vterm :which-key "Open a Vterm terminal.")))
#+end_src

**** TODO configure Vterm Copy mode
**** TODO configure pass-through keys

*** Org Agenda

Org Agenda is an amazing application that can take task data from different sources and produce an overview of your current tasks. It's powerful and efficient and customizable. It's one of the best things in Emacs.

We set up an agenda view, and then we set it as the easier-to-reach keybinding (~SPC aa~). The dashboard, which has a bunch of different potential views, is still available on ~SPC aA~.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun crj-agenda () (interactive) (org-agenda t "g"))
    (setq org-agenda-start-day nil
          org-agenda-files '("~/org-stuff/inbox.org"
                             "~/org-stuff/readme.org"
                             "~/org-stuff/personal.org"
                             "~/org-stuff/archive.org"
                             "~/org-stuff/gcal/anniecannons.org")

          org-agenda-custom-commands '(("g" "Daily agenda and top priority tasks"
                                        ((todo "WAIT"
                                               ((org-agenda-overriding-header "Tasks On Hold\n")
                                                (org-agenda-block-separator nil)))
                                         (agenda ""
                                                 ((org-agenda-span 1)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-scheduled-past-days 0)
                                                  (org-agenda-day-face-function (lambda (_) 'org-agenda-date))
                                                  (org-agenda-format-date "%A %-e %B %Y")
                                                  (org-agenda-overriding-header "\n Today's Agenda\n")))
                                         (agenda ""
                                                 ((org-agenda-start-on-weekday nil)
                                                  (org-agenda-start-day "+1d")
                                                  (org-agenda-span 3)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                  (org-agenda-overriding-header "\n Next Three Days After\n")))
                                         (agenda ""
                                                 ((org-agenda-start-on-weekday nil)
                                                  (org-agenda-tag-filter-preset '("-EVENT"))
                                                  (org-agenda-start-day "+4d")
                                                  (org-agenda-span 3)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "EVENT"))
                                                  (org-agenda-overriding-header "\n Further Calendar Events\n")))
                                         (agenda ""
                                                 ((org-agenda-time-grid nil)
                                                  (org-agenda-start-on-weekday nil)
                                                  (org-agenda-start-day "+4d")
                                                  (org-agenda-span 14)
                                                  (org-agenda-show-all-dates nil)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-entry-types '(:deadline))
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                  (org-agenda-overriding-header "\n Upcoming Deadlines (+14d After)\n")))))))
    :general
    (crj-leader-keys
      "aA" '(org-agenda :which-key "Org Agenda dashboard.")
      "aa" '(crj-agenda :which-key "Custom Org Agenda view.")))

  (use-package evil-org
    :after (evil org)

    :init
    (add-hook 'org-agenda-mode-hook #'evil-org-mode)

    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src


*** Calendar

So you can wish everyone would leave you alone, but /within Emacs/.

**** A Calendar Menu

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys "ac" '(:ignore t :which-key "Calendar Menu")))
#+end_src

**** Google Calendar Integration

Although I'm exploring ways to cut out Google entirely from my life, my work uses Google Calendar, so I need to be able to see it. This is a way to do that.

There are a /lot/ of moving parts with ~org-gcal~, those parts are continuously evolving, and the parts are poorly documented. But here's some issues I've encountered:

- The client-id and ~client-secret~ are each pulled from the sources listed in ~org-gcal~'s readme originally, but I'm keeping them... well, I'm not saying here, but you (Colin) can figure it out when you need to set up a new machine.
- Once I have them on a new machine, I put them in ~password-store~ (aka ~pass~) and, below, pull them out with ~auth-source-pass-get~. This is a way to keep them out of the repo.
- The ~org-gcal-fetch-file-alist~ is a list of calendars to pull from. The first item in the pair is Google Calendar's id of the calendar (which seems to just be the associated email for the basic personal calendar), and the second is the file to put it in. I have a separate file for each calendar.
- For now, ~gnupg~ appears to have a bug that requires you to downgrade it to ~2.4~. If you run into an erro, this /may/ be the issue.
- I don't yet fully understand the interweaving auth systems in effect, but for now, when setting this up in Arch/i3wm, you /do/ want to use the ~gnome-keyring-daemon~ to "save the password in the keyring".
- And also for now, you do NOT want to check the box for killing the pstore buffer, and you'll do better if you quit Emacs, save that buffer, and then restart Emacs.

I hope to document a clear and simple way to set this up in the future (perhaps I could practice in a VM?), but for now: this is what I've got.

**** Google Calendar Menu

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys "acg" '(:ignore t :which-key "Google Calendar Menu")))
#+end_src

**** Google Calendar Setup

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq org-gcal-client-id (auth-source-pass-get
                              'secret
                              "cal/org-gcal/ac/client-id")

          org-gcal-client-secret (auth-source-pass-get
                                  'secret
                                  "cal/org-gcal/ac/client-secret")

          org-gcal-fetch-file-alist '(("colin@anniecannons.com"
                                       .
                                       "~/org-stuff/gcal/anniecannons.org"))))

  (use-package org-gcal
    :straight (:host github :repo "kidd/org-gcal.el")

    :init
    (require 'epa-file)
    (setq epg-pinentry-mode 'loopback)

    :general
    (crj-leader-keys
      "acgf" '(org-gcal-fetch :which-key "Fetch Gcal events.")))
#+end_src

*** Version Control With Magit

I could write a lot about Magit here.

I should write a lot about Magit here!

Not today though.


**** Version Control Menu

Let's set up a menu for Version Control.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys
      "g" '(:ignore t :which-key "Git Menu")))
#+end_src

**** Basic Magit Setup

Only some minor settings changes from the basic setup.

#+begin_src emacs-lisp
  (use-package magit
    :init
    (defun crj--set-up-git-commit-buffer ()
      (evil-insert-state)
      (copilot-mode -1))

    (add-hook 'git-commit-mode-hook 'crj--set-up-git-commit-buffer)
    (setq evil-collection-magit-want-horizontal-movement t)

    :commands magit-status

    :custom
    (magit-display-buffer-function
     #'magit-display-buffer-same-window-except-diff-v1)

    (magit-no-confirm nil)

    :general
    (crj-leader-keys
      "gg" '(magit-status :which-key "Launch Git interface.")
      "gm" '(magit-dispatch :which-key "Show Git HUD.")
      "gb" '(magit-branch-or-checkout :which-key "Switch or create Git branch.")
      "gc" '(magit-clone :which-key "Git clone.")))
#+end_src

**** Magit Error Workaround

This is an annoying thing where I'm getting an error that ~seq-keep~ is not defined. There's an issue on GitHub for it, and I'll see if it still persists when I next update Emacs.

In the meantime, the workaround is to define ~seq-keep~ ourselves.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (defun seq-keep (function sequence)
      "Apply FUNCTION to SEQUENCE and return the list of all the non-nil results."
      (delq nil (seq-map function sequence))))
#+end_src

**** Magit As A Simple Cloud Save Feature

Here, we'll adapt  Git for use not for its usual powerful version control abilities, but simply for saving to a remote repository. We're using Git, one of the most powerful and deep and flexible pieces of software ever created, as a dropbox.

Somewhere Linus Torvalds is crying, but, when you aren't really working on a serious project, this can be useful!

***** Our  Cloud Save Function

#+begin_src emacs-lisp :lexical no
  (defun crj-git-cloud-save ()
    "Adds, commits, and pushes without any further input from the user.

  Basically a way to use Git as an overpowered cloud save.

  Does 3 things:

  1. Adds all tracked files to the staging area.
  2. Creates a commit based on the project's root directory.
  3. Pushes the current branch to the push remote.

  Adapted from this SO answer: https://emacs.stackexchange.com/questions/21597/using-magit-for-the-most-basic-add-commit-push/64991#64991.

  Only changes made were:

  1. Removing the command to save all open buffers. We /could/ save the visited buffer only, though even that should likely be a discrete operation.
  2. Removing user input from the commit message altogether. It now composes a commit message using the current projectile project name.
  3. Disabling the pop-up git status window. (It still shows in the minibuffer, as well as the buffer `shell-command-buffer-name'.)"

    (interactive)
    (magit-stage-modified)
    (let
        ((display-buffer-alist
          '(shell-command-buffer-name '(#'display-buffer-no-window))))
      (shell-command
       (format "git commit -m \"Update %s.\""
               (project-root (project-current t))))
      (shell-command "git push")))
#+end_src

***** Some Shortcuts For This Workflow

Both the cloud save function above, as well as a simple git pull.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys
      "gp" '(crj-git-cloud-save :which-key "Add/commit/push tracked files to the remote.")
      "gf" '(magit-pull :which-key "Pull from the remote.")))
#+end_src

**** Magit Forge For Git Server Integration

This integrates Magit with Git servers like GitHub and GitLab.

Forge stores its data in a SQLite database, so we need to install that first.

This requires some Git configuration and storage of your credentials. See [[https://magit.vc/manual/forge/Getting-Started.html#Getting-Started][the Forge documentation]] for more details.

#+begin_src emacs-lisp
  (use-package sqlite3)

  (use-package forge
    :after magit)
#+end_src

**** YADM Integration

Yet Another Dotfiles Manager has been super helpful to managing my system configurations. It's a wrapper around Git that makes it easy to manage your dotfiles in a Git repo, and then use that repo to manage your dotfiles on a new machine.

Let's integrate it with Magit!

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (require 'tramp)
    (add-to-list 'tramp-methods
                 '("yadm"
                   (tramp-login-program "yadm")
                   (tramp-login-args (("enter")))
                   (tramp-login-env (("SHELL") ("/bin/sh")))
                   (tramp-remote-shell "/bin/sh")
                   (tramp-remote-shell-args ("-c"))))

    (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))

    (defun crj-yadm-magit-status ()
      (interactive (magit-status "/yadm::")))

    :general
    (crj-leader-keys
      "gd" '(crj-yadm-magit-status :which-key "Launch Magit in YADM repo.")))
#+end_src

*** Dired

Dired is the fast and powerful file explorer in Emacs. Let's configure it! We'll:

1. Set it to group directories first.
2. Skip double-checking if we want to copy or delete all of a directory's contents.
3. Set it to omit unimportant details.
4. Set it to re-use the same buffer for each directory.
5. Add icons.
6. Set it up with an extra command to hide dotfiles.

#+begin_src emacs-lisp
  (use-package emacs
    :commands (dired dired-jump)

    :init
    (setq dired-listing-switches "-al --group-directories-first"
          dired-recursive-copies 'always
          dired-recursive-deletes 'always)

    (add-hook 'dired-mode-hook #'dired-omit-mode)
    (add-hook 'dired-mode-hook #'dired-hide-details-mode))

  (use-package dired-single
    :general
    (:keymaps 'dired-mode-map
              [remap dired-find-file] #'dired-single-buffer
              [remap dired-mouse-find-file-other-window] #'dired-single-buffer-mouse
              [remap dired-up-directory] #'dired-single-up-directory))

  (use-package all-the-icons-dired
    :ghook #'all-the-icons-dired-mode-hook)

  (use-package dired-hide-dotfiles
    :general
    (:keymaps 'dired-mode-map
              "H" 'dired-hide-dotfiles-mode))
#+end_src

*** Email with Mu4e

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (require 'mu4e))
#+end_src

** Under The Hood

Always confirm with a quick ~y~ or ~n~ instead of requiring a ~yes~ or ~no~ followed by ~RET~.

And never confirm to open a symlinked file under source control, which you do a /lot/ when exploring Emacs packages.

#+begin_src emacs-lisp
    (use-package emacs
      :init
      (defalias 'yes-or-no-p 'y-or-n-p)
      (setq vc-follow-symlinks t))
#+end_src

Set Emacs to remember text copied to the system clipboard.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq save-interprogram-paste-before-kill t))

#+end_src

Set Emacs to remember recent files, as well as update buffers if the file changes on disk.

#+begin_src emacs-lisp
    (use-package emacs
      :init
      (recentf-mode 1)
      (global-auto-revert-mode 1)
      (setq global-auto-revert-non-file-buffers t))
#+end_src

Also remember our place in files.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (save-place-mode 1))
#+end_src

A better Emacs kill command binding to kill the Emacs server as well.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    ([remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)
    (crj-leader-keys
      "q" '(:ignore t :which-key "Quit Menu")
      "qq" '(save-buffers-kill-emacs :which-key "Quit emacs.")))
#+end_src

Save backups of files, every 10 idle seconds, to a backups folder in our  main emacs directory

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (auto-save-mode 1)
    (setq auto-save-timeout 10
          auto-save-no-message t
          backup-directory-alist
          `(("." . ,(concat user-emacs-directory "/backups")))))
#+end_src

Increase the size of the garbage collector.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 100 1000 1000))
#+end_src

Measure startup time using an excellent bit of code taken from Emacs From Scratch.

#+begin_src emacs-lisp
(defun efs/display-startup-time ()
  "Display how long it took to start Emacs."
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

*** Minibuffers

Save minibuffer history.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

Allow minibuffers within minibuffers.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq enable-recursive-minibuffers t))
#+end_src

Set the current keyboard shortcut I'm typing to only show up after 3 seconds of inactivity. This is slightly longer than the ~which-key~ setting of 2 seconds, since I need to be /more/ lost to be unsure of what I just typed.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq echo-keystrokes 3))
#+end_src

**** TODO possibly make this toggleable to nil for presenting code

*** Secrets

Oooh.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq auth-sources '("~/.netrc" "~/.authinfo.gpg")
          plstore-cache-passphrase-for-symmetric-encryption t)

    (setenv "SSH_ASKPASS" "x11-ssh-askpass"))

  (use-package ssh-agency
    :init
    (setq ssh-agency-askpass nil))

  (use-package password-store)

  (use-package auth-source-pass
    :init
    (auth-source-pass-enable))
#+end_src

** Color Theme

*** Themes

**** Modus Themes

Modus Operandi is a fantastic theme for readability and accessibility, and even though I don't experience deuteranopia, I use the variant for those who do. Modus Operandi is about the uncoolest theme you can use, but... if you're using Emacs to be hip, you're doing it wrong.

#+begin_src emacs-lisp
  (use-package modus-themes
    :config
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-org-blocks 'gray-background
          modus-themes-completions (quote
                                    ((matches . (intense background underline bold))
                                     (selection . (accented intense bold))))

          modus-themes-headings '((0 . (variable-pitch  1.8))
                                  (1 . (variable-pitch  1.8))
                                  (2 . (variable-pitch  1.6))
                                  (3 . (variable-pitch  1.4))
                                  (4 . (variable-pitch  1.2)))

          modus-themes-common-palette-overrides modus-themes-preset-overrides-intense)

    (dolist (face '(modus-themes-prose-code modus-themes-fixed-pitch))
      (set-face-attribute face nil :family crj--fixed-pitch-font :height 1.0))

    (mapc #'disable-theme custom-enabled-themes)
    (load-theme 'modus-operandi-deuteranopia :no-confirm))
#+end_src

**** Ef Themes

The Ef Themes are by the same prolific and brilliant author as the Modus Themes, Protesilaos Stavrou (who is kind enough to go by "Prot"). Their focus is on vividness over accessibility—they still support a high level of accessibility, just not the /highest/ level that Modus works with.

I'll still be using Modus Operandi Deuteronomy when presenting code, but I'm going to try some Ef Themes when working on my own and see how I feel about them!

#+begin_src emacs-lisp
    (use-package ef-themes
      :init
      (setq ef-themes-region '(intense)
            ef-themes-headings '((0 . (variable-pitch  1.8))
                                    (1 . (variable-pitch  1.8))
                                    (2 . (variable-pitch  1.6))
                                    (3 . (variable-pitch  1.4))
                                    (4 . (variable-pitch  1.2))))

      :config
      ;; (mapc #'disable-theme custom-enabled-themes)
      ;; (load-theme 'ef-light :no-confirm)
      )
#+end_src

*** Syntax Coloring

**** Highlight Numbers And Quoted Symbols

Add a bit more splash of color by highlighting numbers and quoted Lisp symbols.

#+begin_src emacs-lisp
  (use-package highlight-numbers
    :init
    (add-hook 'prog-mode-hook #'highlight-numbers-mode))

  (use-package highlight-quoted
    :init
    (add-hook 'prog-mode-hook #'highlight-quoted-mode))

#+end_src

** Projects

Although having such great ability to switch files and buffers obviates the need for so many other ways to navigate (like tabs or file trees), it's still nice to narrow that down to the concept of a project.

Although =projectile= is a popular 3rd-party package as well, we'll use Emacs' built-in =project.el= library.

*** Project Menu

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys "p" '(:ignore t :which-key "project Menu")))
#+end_src

*** Project Customizations

Only one so far is to automatically run =project-find-file= upon switching to a new project.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq project-switch-commands 'project-find-file))

#+end_src

*** Project Keybindings

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys
      "pp" '(project-switch-project :which-key "Switch to new project.")
      "pk" '(project-kill-buffers :which-key "Kill all current project buffers.")
      "p," '(project-switch-to-buffer :which-key "Switch buffers in current project.")
      "pd" '(project-dired :which-key "Run dired in current project root.")
      "p." '(project-find-file :which-key "Find file in current project.")
      "p$" '(project-async-shell-command :which-key "Run command in current project root.")
      "pr" '(project-forget-project :which-key "Forget project.")))
#+end_src

** Text Editing

*** General Text Editing

**** Whitespace

***** Tabs Vs. Spaces

We'll go with spaces!

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (indent-tabs-mode -1))
#+end_src

***** TODO
#+begin_src emacs-lisp :lexical no
  (setq indentation-to-check-out '(indent-tabs-mode
                                   tab-width
                                   markdown-list-indent-width
                                   evil-shift-width
                                   css-indent-offset))
#+end_src

***** Column Length

The default 70 is too low a number. I like 100, though this is arbitrary and /probably/ should be according to some accepted standard.

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (setq-default fill-column 100))
#+end_src

***** Whitespace Removal

This package removes whitespace from the ends of lines.

Conveniently, it only does it on lines you've edited. This way, if you're working with version control, you don't have a huge diff every time you save a file.

#+begin_src emacs-lisp
  (use-package ws-butler
    :config
    (ws-butler-global-mode))
#+end_src

**** Undoing

***** Saving Undo History

Losing undos if you quit your editor is kind of a pain. Saving your undo history is just a great great idea.

Undo Fu Session is my solution here—it's meant to work with the Undo Fu package, but works just fine with vanilla Emacs' undo system.

#+begin_src emacs-lisp :lexical no
  (use-package undo-fu-session
    :init
    (undo-fu-session-global-mode)

    :custom
    (undo-fu-session-file-limit 100000))
#+end_src

***** Visualizing Undo History

Vundo (Visualize Undo) takes Emac's very powerful and /very/ unintuitive undo system and gives you a nice navigable tree for it.

There are alternatives, but Vundo integrates nicely with Evil through the Evil Collection package, and also avoids changing anything about the actual undo system you use. Simple packages is better packages.

#+begin_src emacs-lisp :lexical no
  (use-package vundo)
#+end_src

**** Searching In Buffer

What I'm trying now is:

1. =evil-snipe= for short-range hops.
+2. =avy-goto-char-timer= for medium-range hops.+ (turns out I don't like Avy for in-buffer searches, but it might still be useful in the future for its more advanced features)
2. =evil-ex-search= for long-range hops.
3. =consult-line= for a more focused search.

Do I need +4+3 searches? /Probably not/. (I didn't!)

I'll figure out what workflow works for me in time.

***** Jumping By Character Pairs With Evil Snipe

I find that Evil-Snipe—an unfortunately named port of Vim-Sneak—is a great way to navigate over medium distances in an editor. You simply press ~s~ and then type in the two characters you want to jump to. Two characters is usually enough to identify where you want the cursor to be, at least over medium ranges. And when it isn't? You just press ~;~ to go to the next one.

Basically, it's a supercharged version of Vim's ~f~ command. It's fantastic, and I've missed it, and I'm only sorry I've taking this long to get to it.

#+begin_src emacs-lisp
  (use-package evil-snipe
    :after evil

    :init
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1)
    :config
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode)
    (setq evil-snipe-scope 'buffer
          evil-snipe-smart-case t
          evil-snipe-char-fold t))
#+end_src

***** Avy

Avy config will be kept around for now, but I'm disabling it. Consider it "archived".

#+begin_src emacs-lisp :lexical no
  (use-package avy
    :disabled
    :init
    (setq avy-timeout-seconds 0.5)

    :general
    (:keymaps '(evil-normal-state-map evil-motion-state-map)
              "/" #'avy-goto-char-timer
              "?" #'evil-ex-search-forward))
#+end_src

***** Evil Ex-Search and Consult

are configured elsewhere!

*** Writing

**** Spell-Check With Flyspell

Flyspell is an /amazing/ built-into-Emacs spell-checker.

~flyspell-correct~ makes it even better with a quick command to correct the last word. You can correct your spelling /so/ easily without losing your flow in the slightest bit.

I use the built-in binding of ~C-;~ for autocorrecting to the first suggestion without moving the cursor. Occasionally this is the wrong suggestion, in which case I can use the below ~C-:~ binding to choose from the full menu of options, including saving the word into my personal dictionary.

#+begin_src emacs-lisp
  (use-package flyspell
    :demand t
    :init
    (defun crj--turn-on-flyspell ()
      (flyspell-mode 1))

    (add-hook 'text-mode-hook #'crj--turn-on-flyspell)
    (add-hook 'prog-mode-hook #'flyspell-prog-mode)
    (add-hook 'git-commit-mode-hook #'crj--turn-on-flyspell)
    (setq ispell-program-name "hunspell")

    :config
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic "en_US,en_CA,en_AU,en_GB,es_ES")
    (ispell-change-dictionary "en_US,en_CA,en_AU,en_GB,es_ES" t))

  (use-package flyspell-correct
    :general (:states '(insert normal emacs)
                      "C-:" #'flyspell-correct-wrapper))
#+end_src

*** Coding

Settings for... coding.

**** General

***** A Code Menu

I don't use this very much yet. But I should!

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :init
    (crj-leader-keys
      "c" '(:ignore t :which-key "Code Menu")))
#+end_src

***** Coding Block Delimiters

Sometimes simply called "parens" or "brackets", delimiters are a big part of coding. This is particularly true in Lisp languages, but even the indentation-for-delimiting-code-blocks Python benefits from handling them well.

Whatever you call delimiters, let's make all these easy-to-mess-up character pairs easier to work with!

****** Auto-Close Delimiter Pairs

Use Emacs' built-in library for auto-closing your brackets, ~electric-pair-mode~. Auto-closing means that when you type an open-parens (or curly or square bracket), your editor adds a closing parens afterwards, keeping your cursor in the middle. The idea is to avoid ending up with unbalanced brackets.

Many experienced developers say auto-closing your brackets is counter-productive. Perhaps I'll give skipping it another go sometime, but every time I do, I miss it.

That said, I felt the same about using buffers as the main way to interact with text, but once I stopped relying on inefficient means like tabs, I saw how much better it was. And there are tons of other examples like that. So perhaps I'll someday see the light on this? We'll see!

Also, for some reason, electric pair mode /occasionally/ tries to auto-close an angle bracket (~<~) in Org Mode, which I never want—angle brackets are the start of shortcuts for source blocks in Org Mode, and I don't want them auto-closed. So I've added a predicate to disable that auto-closing in Org Mode.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defconst crj--electric-pair-char-and-mode-block-list '((org-mode . ?<)))

    (defun crj--should-avoid-auto-pairing-p (char)
      (and (assoc major-mode crj--electric-pair-char-and-mode-block-list)
           (eq char (cdr (assoc major-mode crj--electric-pair-char-and-mode-block-list)))))

    (setq electric-pair-inhibit-predicate #'crj--should-avoid-auto-pairing-p)

    (electric-pair-mode))
#+end_src

****** Highlighting Surrounding Delimiters

This next library highlights the delimiters of the block the cursor is currently in, providing a nice quick visual aid as to where you're /at/.

By default, it helps you see the blocks from your cursor to four delimiters outwards, but I find the next library we'll use a better fit for a larger-scale visual guide. Still, it's good to have a subtle visual indication as to exactly how deep you are currently, which is why I'm using a light Modus Theme color and it's matching light background.

  #+begin_src emacs-lisp
    (use-package highlight-parentheses
      :ghook 'prog-mode-hook
      :custom
      (highlight-parentheses-colors `(,(modus-themes-get-color-value 'fg-heading-4 t)))
      (highlight-parentheses-attributes `((:background ,(modus-themes-get-color-value 'bg-heading-4 t)))))
    #+end_src

****** Using Different Colors For Different Depths With Rainbow Delimiters

Rainbow Delimiters uses a different color for each depth of delimiter, regardless of where your cursor is. So, in mine, the outer delimiter is a kind of dark blue-ish purple, the next delimiter pair inwards is a pinkish purple, the next a lighter blue, the next a blue-ish green, he next an orange-red, the next an intense red, and it keeps going like that in complementary cycles.

The color choices aren't mine, but, rather, taken from the great Modus Themes, and specifically from their headings. The code below sets ~rainbow-delimiters-depth-n~ to the color of my current Modus theme's ~fg-heading-n~ (the foreground color of the heading), where ~n~ is each number from 1-8.

The code above and below were fun coding challenges for me as I learn a bit more Lisp. There's some good learnings to be taken from how they work, from the use of ~`~ and ~,~ for evaluating code in a list to the way the ~dotimes~ loop works to the use of ~intern~ to convert a string to a Lisp symbol. Maybe you'll take something from them too!

    #+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :after modus-themes

      :ghook 'prog-mode-hook

      :config
      (dotimes (num 8)
        (set-face-attribute
         (intern (concat "rainbow-delimiters-depth-" (number-to-string (1+ num)) "-face"))
         nil
         :foreground (modus-themes-get-color-value (intern (concat "fg-heading-" (number-to-string (1+ num)))) t))))
#+end_src

**** Languages

Configurations specific to certain languages.

***** Lisps

The greatest languages.

****** Keybindings

Some general Lisp bindings.

******* Lisp Modes

These are useful lists for mass configuration.

#+begin_src emacs-lisp :lexical no
  (defconst crj--lisp-modes '(emacs-lisp-mode racket-mode scheme-mode))
  (defconst crj--lisp-mode-hooks '(emacs-lisp-mode-hook racket-mode-hook scheme-mode-hook))
  (defconst crj--lisp-mode-maps '(emacs-lisp-mode-map racket-mode-map scheme-mode-map))
#+end_src

******* Improving Evil For Symexes

First off, what is a "symex"? Well, I'm not going to explain what a symbolic expression is here, but you'll see the shortening "sexp" thrown around a lot in Lisp circles, and it's just /awful/. It's a terrible, terrible name.

"Symex" is a far better term, coined by a friend of the maker of the [[https://github.com/drym-org/symex.el][Symex package]]. I'll be using that term from now on, and if it never catches on, well, at least /I'm/ not using a terrible name for them.

Anyway! I'm trying to find a way to navigate and manipulate symexes here, while keeping all of Evil's grammar.

We'll see how I do.

Changes I'm going for:

******** Move By Symbols

Set ~W~/~B~ movements ignore the many many delimiters Lisps use, so that we're not stopping on parens. If I want to go to a parens, ~f(~ is way clearer. I want to go by programming symbols!

This is part of the [[https://github.com/emacs-evil/evil-cleverparens][evil-cleverparens]] package.

******** Move Up And Down Trees

The Symex library gets away from Evil a little too much for me, but it has an /excellent/ way of moving up and down trees. See [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]] to see it in action!

This is what I'm thinking:

- ~+~ and ~-~ to move up and down trees
- ~M-h~ and ~M-l~ to move to the top and bottom of trees (already provbided by ~evil-cleverparens~)
- ~(~ and ~)~ to move up or down branches
- ~{~ and ~}~ to move to the start or end of a branch

#+begin_src emacs-lisp :lexical no
#+end_src

******** Keep Parens Balanced

For example, if I delete a line with Evil's ~dd~, I usually don't want to delete the closing parens that is needed by an earlier line.

~evil-cleverparens~ will do this for us.

It's a weird thing, though. You spend a while adapting Evil for using with a Lisp, and you get away from using ~dd~ anyway. It's worth a try seeing if balancing the parens automatically brings it back as a tool, but... I don't know if I like using a distinctly Evil command, and giving it different behavior in Lisp contexts.

I think it feels better to simply be more precise with my commands in such contexts.

So I'm still not positive I want it, but I'm giving it a try!

******** Manipulate Symexes

Probably going to use ~evil-cleverparens~ for this, though there may be better ones out there.

In particular, I like:

- ~evil-cp-drag-forward~ and its backwards version, for moving symbols around. These are set to ~M-j~ and ~M-k~ by ~evil-cleverparens~.
- ~evil-cp->~ and ~evil-cp-<~ for a symex to increase/decrease its scope ("barfing" and "slurping"), though they work most intuitively for me on the opening and closing delimiters. These are set to ~<~ and ~>~ by ~evil-cleverparens~, and I'm resetting manual indentation to ~g>~ and ~g<~ in Lisp modes—I don't manually indent in Lisp modes much anyway.
- ~evil-cp-insert-at-beginning-of-form~ and the end version, for inserting/appending symbols in forms. These are set automatically to ~M-i~ and ~M-a~.
- Quoting and unquoting via Symex commands (/not/ wrapping in quotes, but the special Lisp concept of quoting/unquoting). Unfortunately, these commands require point to be at the start of the symbol, or the start of the quote/unquote if it already has it.

******** Commands That Could Be Done Structurally

  I may at some point experiment with the following, all of which can be seen in [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]]

  - raising
  - splitting
  - merging

    These motions don't have easy ways to do them with Evil.

    For raise, I can probably do it with Evil Replace: I can yank the inner form, then go to the outer form, then run evil-replace. Not /too/ bad.

    Merging is relatively easy with Evil, just hunting the opening and closing parens and using ~x~ to delete them... but possibly a command would be nice for this, so that I'm working structurally.

    For splitting, I could... hmm... go to the place to split them (which you have to do with Symex's commands anyway), then enter insert state, type in the closing and opening parens, and exit back to normal state. And delete the extra parens if you have auto-pairing on.

    All of those are /okay/ solutions, but if I find myself doing them more often, it may make sense to use more structural commands on them.

******** Add More Text Objects

This is something that a more advanced solution could give you (maybe Treesitter?)), but for now, ~evil-cleverparens~ gives you the following text objects to manipulate:

- ~f~ for a form (aka symex)
- ~d~ for a defun (aka a top-level symex, like a function)

******** And, Finally, The Code That Does All That

#+begin_src emacs-lisp :lexical no
  (use-package evil-cleverparens
    :general
    (:states 'normal
             :keymaps crj--lisp-mode-maps
             "A" #'evil-cp-insert-at-end-of-form
             "I" #'evil-cp-insert-at-beginning-of-form
             "D" #'evil-cp-drag-forward
             "C" #'evil-cp-drag-backward)

    (general-def 'normal
      "W" #'evil-cp-forward-symbol-begin
      "E" #'evil-cp-forward-symbol-end
      "B" #'evil-cp-backward-symbol-begin
      "gE" #'evil-cp-backward-symbol-end)

    (general-def 'normal (evil-inner-text-objects-map evil-outer-text-objects-map)
      "f" #'evil-cp-inner-form
      "d" #'evil-cp-inner-defun))

  (use-package on-parens
    :general
    (:states 'normal
             "g<" #'evil-shift-left
             "g>" #'evil-shift-right)

    (:states '(normal motion operator)
             :keymaps crj--lisp-mode-maps
             "+" #'on-parens-down-sexp
             "-" #'on-parens-up-sexp
             "H" #'on-parens-backward-sexp-in-supersexp
             "L" #'on-parens-forward-sexp-in-supersexp
             "(" #'on-parens-backward-sexp
             ")" #'on-parens-forward-sexp
             "{" #'on-parens-backward-sexp-end
             "}" #'on-parens-forward-sexp-end
             "|" #'on-parens-split-supersexp
             "&" #'on-parens-join-neighbor-sexp
             "<" #'on-parens-backward-slurp
             ">" #'on-parens-forward-slurp
             "M-<" #'on-parens-backward-barf
             "M->" #'on-parens-forward-barf))
#+end_src

******** And some code to test it on

#+begin_src emacs-lisp :lexical no
  ;; (+ 1 2 (+ 3 4 5) (+ 6 7 8) (+ 9 10) 11 12)

  ;; (defconst my-message "hello")
  ;; (defconst failure-message "not equal")

  ;; (defun lisp-playground-test-fun ()
  ;;   "Just a test function to play with some code."
  ;;   (interactive)
  ;;   (if (string-equal "hello" my-message)
  ;;     (message "they're equal")
  ;;   (message failure-message)))

  ;; (defun should-have-sharp-quote ()
  ;;   "Just testing."
  ;;   (interactive)
  ;;   (message "this should have a sharp quote"))

  ;; (crj-leader-keys
  ;;   "l" #'lisp-playground-test-fun
  ;;   "k" 'should-have-sharp-quote
  ;;   "bm" (lambda () (interactive) (message "test lambda")))
#+end_src

******** So Where To Next On This?

Well, I've added some nice commands that are particular to Lisp that aren't easy to do in standard Evil, but it's still not very /Evil/. None of these are motions, and I've only added one text object I couldn't easily get elsewhere (the defun).

Basically, my choice appears to be:

- add some one-off shortcut commands, like the cycling quoting and the slurping/barfing. But these aren't integrated into the Evil editing language in any meaningful way.
- embrace a separate editing state to switch to for Evil, such as going full Symex, or the more popular [[https://github.com/noctuid/lispyville][Lispyville package]]. Again, not very Evil-y.

  I've chosen the first one, but what I /want/ to exist is this third option:

  - Evil motions and text objects for dealing with Lisp.

I'm really surprised and annoyed this doesn't exist, and I really want it to.

******** How An Evil Lisp Language /Should/ Work

I'm unlikely to have time ever to implement this, but here are some ideas:

*Motions*

- quote/unquote—this should probably be similar to the popular [[https://github.com/emacs-evil/evil-surround][Evil Surround package]], where we could change the quote on a symbol or form, or delete it. (It's possible this could simply be configured with Evil Surround.)
- traversing trees and branches as Symex does
- insert-at-start-of and append-at-end-of, but for forms
- change-rest, yank-rest, and delete-rest (like Evil's ~C~, ~D~, and ~Y~), but for forms
- emit/capture ("slurp" and "barf")
- merging
- transposing
- exchanging (possibly with evil-exchange)
- replacing (possibly with evil-replace)

*text objects*

- symbols
- lists
- defuns

*additional ideas*

- just like most text objects, a text object used without a motion should /default/  to traveling to the next such text object
- all motions should take counts
- we /could/ implement not just (i)n and (a)round but (o)uter
- and possibly (n)ext and (p)revious, as [[https://github.com/noctuid/targets.el][targets.el]] does.

*examples*

-

  More later...

****** Emacs Lisp

******* TODO configure elisp more

******** TODO configure keybindings
******** TODO figure out evil keybindings for movement

******* Emacs Lisp Documentation Lookup

Better go-to-definition function for Emacs Lisp.

#+begin_src emacs-lisp
      (use-package elisp-def
        :init
        (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook #'elisp-def-mode))

        :general
        (:keymaps 'org-mode-map :states 'normal
                  "gd" '(elisp-def :which-key "Go to definition.")))
#+end_src

******* TODO configure elisp more

****** Racket

#+begin_src emacs-lisp :lexical no
  (use-package geiser)

  (use-package geiser-racket)

  (use-package racket-mode
    :mode "\\.rkt\\'"

    :gfhook #'racket-xp-mode)

#+end_src

***** CSV

#+begin_src emacs-lisp :lexical no
  (use-package csv-mode)
#+end_src

***** JavaScript

Basic configuration for JS and JSX.

Only two things aren't easy to figure out here:

1. ~rjsx-mode~ and ~flyspell-mode~ are /not/ friends, so we turn ~flyspell-mode~ off in JS files. See [[https://github.com/felipeochoa/rjsx-mode/issues/68][this bug]].
2. The advice added to the ~rjsx-electric-gt~ function helps ~rjsx-mode~ to auto-close React JSX fragments. You can find [[https://github.com/felipeochoa/rjsx-mode/issues/112#issuecomment-773660200][the original code here]].

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq js-indent-level 2
          js2-strict-missing-semi-warning nil))

  (use-package rjsx-mode
    :gfhook #'turn-off-flyspell

    :init
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . rjsx-mode))

    :config
    (defun crj--rjsx-electric-gt-fragment-a (n)
      "Inserts matching JSX fragment.

      Credit: someone on the internet?"

      (if (or (/= n 1) (not (and (eq (char-before) ?<) (eq (char-after) ?/)))) 't
        (insert ?> ?<)
        (backward-char)))

    (defun crj--auto-close-jsx-fragments (n)
      (if (or (/= n 1) (not (and (eq (char-before) ?<) (eq (char-after) ?/)))) 't
        (insert ?> ?<)
        (backward-char)))

    (advice-add #'rjsx-electric-gt :before-while #'crj--auto-close-jsx-fragments))
#+end_src

***** TypeScript

#+begin_src emacs-lisp :lexical no
  (use-package typescript-mode
    :init
    (setq typescript-indent-level 2)
    :mode
    (("\\.ts\\'" . tsx-ts-mode)
     ("\\.tsx\\'" . tsx-ts-mode)))

#+end_src

***** Using Prettier To Format Buffers

#+begin_src emacs-lisp
  (use-package prettier
    :init
    (defun crj-prettify-js-org-src-block ()
      "Run prettier on source block at point."
      (interactive)
      (org-edit-src-code)
      (prettier-prettify)
      (org-edit-src-exit))

    :general
    (crj-leader-keys
      "bf" '(prettier-prettify :which-key "Format buffer."))
    (crj-leader-keys
      "mf" '(crj-prettify-js-org-src-block :which-key "Format markdown block.")))
#+end_src

** Completion

Because so much in Emacs is driven by text, good completion is the difference between hard-to-use and effortless.

*** Minibuffer Completion

Minibuffer completion is a different beast than in-buffer completion, which is what most people mean when they talk about completion in other apps. The minibuffer is a kind of menu you get in Emacs, and it usually serves as a place to search for something.

In Emacs, minibuffer menus can be used to search for:

- a command you're looking to run
- a command you're looking to get more info on
- a file or directory you're looking to open
- a project to open
- a buffer to choose
- a Git branch to switch to
- a wi-fi network to join
- an emoji to insert
- and lots of other things I use every day

Other apps now have this equivalent—the one people know most developers know these days is the Command Palette in VS Code, which offers very good menu completion, but there are similar examples in Slack and Discord and Vivaldi and many other apps. But in Emacs land, because you can search for practically anything you do, having /one/ interface for searching for what you want to do next is incredibly powerful, and one of the main unique selling points of Emacs.

**** Some Basic Minibuffer Search Settings

Set Emacs to only include commands that are relevant to the current "major mode" (what you would call a file type outside of Emacs).

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

**** Minibuffer Search Interface

Vertico and Marginalia together make an amazing interface for minibuffer search.

***** Marginalia

Marginalia gives you some more data in other columns in the list of results as you filter them. It's nice! Let's set it up!

#+begin_src emacs-lisp
  (use-package marginalia
    :general
    (:keymaps 'minibuffer-local-map
              "M-A" 'marginalia-cycle)

    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'right)

    :init
    (marginalia-mode))
#+end_src

***** Vertico

A popular Emacs minibuffer search interface is Vertico. It gives you a simple but powerful UI for accessing whatever you're looking to access, and it does it with a minimum of code, mostly focusing on extending the built-in Emacs interface. This makes it fast to use and, importantly, easy for the devs to debug.

What we'll do is:

- Install it.
- Turn it on.
- Tun on the ability to toggle interface setup.
- Set the results of searches to wrap from bottom to top.
- Set "reverse" as the default interface setup.
- Set Emacs to remember Vertico's history.
- Fix some weirdness caused by the interplay of directories and completion.
- Add the Vertico extension ~vertico-repeat~ and a keybinding to repeat previous searches.
- Add keybindings for more Vim-like ~j~/~k~ scrolling as well as scrolling by pages and going up a directory with a single delete.

Here that all is!

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    (vertico-multiform-mode)

    :config
    (setq vertico-cycle t
          vertico-multiform-categories '((t reverse)))

    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (with-eval-after-load 'savehist
      (add-to-list 'savehist-additional-variables 'vertico-repeat-history))

    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-repeat))

    :general
    (crj-leader-keys
      "'" '(vertico-repeat-select
            :which-key "Repeat previous vertico searches."))

    (:keymaps 'vertico-map
              "C-k" #'vertico-next
              "C-j" #'vertico-previous
              "C-S-p" #'vertico-scroll-up
              "C-S-n" #'vertico-scroll-down
              "C-S-k" #'vertico-scroll-up
              "C-S-j" #'vertico-scroll-down
              "RET" #'vertico-directory-enter
              "DEL" #'vertico-directory-delete-char
              "M-DEL" #'vertico-directory-delete-word))
#+end_src

**** Minibuffer Search Data Sets

~consult~ is a library containing a set of functions that each search a different set of data. That sounds dry, but it's really not!

What it enables you to do is decide whether your search will be of:

- lines in the current buffer
- lines in any file in your project or directory
- titles of currently open buffers
- paths to recent files
- text in Emacs' clipboard history (the "kill ring")
- headings in a markup file (how I get around this document!)
- color themes
- manual pages for Unix commands

And that's not even all of them! Minibuffer searches are a /huge/ part of how you use Emacs, and Consult is just one of many ways to decide what to search through.

#+begin_src emacs-lisp
  (use-package consult
  :commands consult-line
    :general
    (crj-leader-keys "/" '(consult-line :which-key "Search in current buffer.")))
#+end_src

***** TODO add bindings for Consult searches for grep and project search and maybe others?

**** Minibuffer Search Filtering

The Orderless package is powerful and fascinating. It decides the data you're searching is filtered as you type, and you can even search in different ways in the same search.

Here's an example using the setup below. I can start typing the path of a file I want to open in a minibuffer search, then notice that most of the results are in a directory I want to exclude. So I type in a ~!~ (a pretty universal developer symbol for "not" and the name of that directory, and those results are filtered out. Then I realize I want the path to begin with the home directory, excluding everything in the ~/usr~ and ~/tmp~ and such directories. So I type ~^~ (developer for "starts with") and ~~~ (the alias for the home directory). Finally, I want only JavaScript files, so I type ~$~ (developer for "ends with") and then type ~js~, and boom!

Once you're used to this speedy filtering process, it /greatly/ cuts down on the time spent searching for whatever it is you want to do.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (defun crj--vertico-orderless-dispatch (pattern _index _total)
      "The set of dispatch commands I use for filtering searches.

  Taken from the Doom Emacs project, which has added so much useful configuration code to the Emacs world. Thanks, Doom contributors!"
      (cond
       ;; Ensure $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
        `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Without literal
       ((string-prefix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 1)))
       ;; Character folding
       ((string-prefix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 1)))
       ((string-suffix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 0 -1)))
       ;; Initialism matching
       ((string-prefix-p "`" pattern) `(orderless-initialism . ,(substring pattern 1)))
       ((string-suffix-p "`" pattern) `(orderless-initialism . ,(substring pattern 0 -1)))
       ;; Literal matching
       ((string-prefix-p "=" pattern) `(orderless-literal . ,(substring pattern 1)))
       ((string-suffix-p "=" pattern) `(orderless-literal . ,(substring pattern 0 -1)))
       ;; Flex matching
       ((string-prefix-p "~" pattern) `(orderless-flex . ,(substring pattern 1)))
       ((string-suffix-p "~" pattern) `(orderless-flex . ,(substring pattern 0 -1)))))

    (setq completion-ignore-case t
          completion-styles '(orderless basic)
          completion-category-defaults nil
          orderless-component-separator "#"
          orderless-style-dispatchers '(crj--vertico-orderless-dispatch)
          orderless-matching-styles '(orderless-flex orderless-literal orderless-regexp)
          completion-category-overrides '((file (styles partial-completion)))))

#+end_src

**** Lots of completion settings to look over!

#+begin_src emacs-lisp
  ;; snippet settings

  ;; (defun crj--set-up-snippets ()
  ;;   (yas-global-mode)
  ;;   (setq yas-snippet-dirs '("~/.doom.d/snippets"))
  ;;   (yas-reload-all)
  ;;   ;; I like having a specific (non-tab) and easy key for expanding snippets
  ;;   (map! :i [M-tab] #'yas-expand
  ;; 	:map yas-keymap "TAB" nil
  ;; 	"<tab>" nil
  ;; 	[M-tab] #'yas-next-field-or-maybe-expand))

  ;; (require 'yasnippet)
  ;; (after! yasnippet (crj--set-up-snippets))

  ;; ;; don't add newlines to end of snippet files
  ;; (defun no-final-newline-in-buffer ()
  ;;   (setq-local require-final-newline nil))
  ;; (add-hook! 'snippet-mode-hook 'no-final-newline-in-buffer)

#+end_src

****** TODO set up Emmet

#+begin_src emacs-lisp
  ;; (map! :i [C-tab] nil)
  ;; (map! :i [C-tab] #'emmet-expand-line)
  ;; (map! :map emmet-mode-keymap "<tab>" nil)

#+end_src

This looks like something I'll want to implement too.

#+begin_src emacs-lisp
  ;; (defun toggle-eldoc-mode ()
  ;;   (interactive)
  ;;   (if eldoc-mode
  ;;       (eldoc-mode -1)
  ;;     (eldoc-mode 1)))

  ;; (map!
  ;;  :leader
  ;;  (:prefix ("t" . "toggle")
  ;; 	  :desc "eldoc for current symbol" :n "k" #'eldoc
  ;; 	  :desc "eldoc mode." :n "K" #'toggle-eldoc-mode))

  #+end_src

  Might be some useful Embark stuff here, since I'll be setting that up soon.
  #+begin_src emacs-lisp
  ;; (use-package vertico
  ;;   :config
  ;;   embark act and resume completion
  ;;   (defun crj--embark-act-without-quitting ()
  ;;     (interactive)
  ;;     (let ((embark-quit-after-action nil))
  ;;       (embark-act)))
  ;;   (map! :map vertico-map "C-:" #'crj--embark-act-without-quitting)
  ;;   (map! :leader
  ;; 	:desc "Select from previous completions." "\"" #'vertico-repeat-select)
  ;;   (map! :map vertico-map "C-S-P" #'vertico-scroll-down)
  ;;   (map! :map vertico-map "C-S-N" #'vertico-scroll-up))
#+end_src


These might be useful Corfu settings? check them out once I get Eglot going?

  #+begin_src emacs-lisp
	    ;; (use-package corfu
	    ;;   :config
	    ;;   (define-key corfu-map (kbd "M-g") #'corfu-quit)
	    ;;   (define-key corfu-map (kbd "C-n") #'corfu-next)
	    ;;   (define-key corfu-map (kbd "C-j") #'corfu-next)
	      ;; (define-key corfu-map (kbd "C-p") #'corfu-previous)
	      ;; (define-key corfu-map (kbd "C-k") #'corfu-previous)
	      ;; (define-key corfu-map (kbd "C-S-n") #'corfu-scroll-up)
	      ;; (define-key corfu-map (kbd "C-S-j") #'corfu-scroll-up)
	      ;; (define-key corfu-map (kbd "C-S-p") #'corfu-scroll-down)
	    ;;   (define-key corfu-map (kbd "C-S-k") #'corfu-scroll-down)
	    ;;   (define-key corfu-map (kbd "RET") nil)
	    ;;   (define-key corfu-map (kbd "RET") #'corfu-complete)
	    ;;   (define-key corfu-map (kbd "TAB") nil)
	    ;;   (define-key corfu-map (kbd "<tab>") nil)
	    ;;   (define-key corfu-map (kbd "<tab>") #'corfu-insert)
	    ;;   (define-key corfu-map (kbd "TAB") #'corfu-insert)
	      ;; (setq corfu-commit-predicate nil
	      ;; 	completion-category-overrides '((eglot (styles orderless)))
	    ;; 	corfu-auto t
	    ;; 	corfu-auto-prefix 1
	    ;; 	corfu-quit-no-match t
	    ;; 	corfu-cycle t))

	    ;; (after! projectile
	    ;; 	(add-to-list 'projectile-project-root-files ".git"))

	    ;; ;; I don't need the "symbol class" info in my documentation.
	    ;; (after! marginalia
	    ;; 	(setf (alist-get 'variable marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-variable builtin none))
	    ;; 	(setf (alist-get 'symbol marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-symbol builtin none))
	    ;; 	(setf (alist-get 'function marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-function none)))

	    ;; (org-babel-do-load-languages
	     ;; 'org-babel-load-languages
	     ;; '((emacs-lisp . t)))
	       ;; (sql-mode . t)
	       ;; (racket . t)
	       ;; (python . t)
	       ;; (ipython . t)
	       ;; (bash . t)
	       ;; (sh . t)
	       ;; (js . t)
	       ;; (javascript . t)
	       ;; (sql . t)
	       ;; (go . t)


	    ;; (map! :leader
	    ;;       :desc "Yank from kill ring with completion." :n "P" #'yank-from-kill-ring)

	    ;; ;; (map! :i "C-SPC" #'complete-symbol)

	    ;; (setq embark-prompter 'embark-completing-read-prompter)
  #+end_src
*** In-Buffer Completion

**** Corfu

Sets up:

- in-buffer completion
- cool icons for same

#+begin_src emacs-lisp
  (use-package corfu
    :config
    (general-unbind corfu-map "RET")
    :general
    (:keymaps 'corfu-map :states 'insert
              "C-n" #'corfu-next
              "C-p" #'corfu-previous
              "C-S-n" #'corfu-scroll-up
              "C-S-p" #'corfu-scroll-down
              "C-S-j" #'corfu-scroll-up
              "C-S-k" #'corfu-scroll-down
              "M-g" #'corfu-quit
              "TAB" #'corfu-next
              [tab] #'corfu-next
              "S-TAB" #'corfu-previous
              [backtab] #'corfu-previous
              "M-d" #'corfu-show-documentation
              "M-l" #'corfu-show-location)
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-separator ?#)
    (corfu-preview-current 'insert)
    (corfu-quit-at-boundary 'separator)
    (corfu-auto-prefix 1)
    (corfu-preselect 'prompt)
    (corfu-on-exact-match nil)

    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    :init
    (global-corfu-mode))

  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default)
    (kind-icon-blend-background nil)
    (kind-icon-blend-frac 0.08))

  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+end_src

And an extra package for completing Org blocks.

#+begin_src emacs-lisp
  (use-package org-block-capf
    :straight (:host github :repo "xenodium/org-block-capf")

    :init
    (add-hook 'org-mode-hook #'org-block-capf-add-to-completion-at-point-functions))
#+end_src

**** Eglot

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (setq completion-category-overrides '((eglot (styles orderless))))
    (add-to-list 'eglot-server-programs
                 '((typescript-mode)
                   "typescript-language-server"
                   "--stdio"))

    :general
    (crj-leader-keys
      "cc" '(eglot :which-key "Run eglot in project root.")))

  (use-package cape
    :after eglot

    :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster))
#+end_src

**** Copilot

GitHub Copilot provides AI-driven suggestions as to what you might want to insert next. This is absurdly powerful, but it's not always right. So we want to be able to accept or reject suggestions, do it granularly, and to see the suggestions in a separate window.

I also find it helpful to have a separate set of tab bindings for accepting Copilot suggestions, so I can use the normal tab bindings for standard completion.

Note that this feature only works if you have a GitHub Copilot account. If you have one, you can login using the ~copilot-login~ command.

#+begin_src emacs-lisp
  (use-package copilot
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :general
    (crj-leader-keys
      "tc" '(global-copilot-mode :which-key "Toggle copilot globally.")
      "tC" '(copilot-mode :which-key "Toggle copilot for current buffer."))
    (:keymaps 'copilot-mode-map
              "M-RET" #'copilot-accept-completion
              "M-<tab>" #'copilot-next-completion
              "M-<iso-lefttab>" #'copilot-previous-completion
              "M-o" #'copilot-panel-complete
              "M-w" #'copilot-accept-completion-by-word
              "M-l" #'copilot-accept-completion-by-line
              "M-p" #'copilot-accept-completion-by-paragraph))
#+end_src



*** Flymake

  A great error-navigation library

  #+begin_src emacs-lisp
    (use-package flymake
      :hook (prog-mode . flymake-mode)
      :general
      (:keymaps 'normal
    	    "]e" '(flymake-goto-next-error
    		   :which-key "Go to next error.")
    	    "[e" '(flymake-goto-prev-error
    		   :which-key "Go to previous error."))
      (crj-leader-keys
        "cX" '(flymake-show-project-diagnostics :which-key "Describe variable.")))
      #+end_src

** AI

It's the robots!

*** First, a simple function to get my password.

#+begin_src emacs-lisp :lexical no
  (defun crj--get-open-ai-api-key ()
    (auth-source-pass-get 'secret "ai/openai/key"))
#+end_src

*** An AI Menu

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys "ai" '(:ignore t :which-key "AI Menu")))
#+end_src

*** Bing Chat

**** A Bing Menu

#+begin_src emacs-lisp :lexical no
  (use-package emacs
    :general
    (crj-leader-keys "aib" '(:ignore t :which-key "Bing Chat Menu")))
#+end_src

**** Main Bing Setup

#+begin_src emacs-lisp :lexical no
  (use-package websocket)

  (use-package async-await)

  (use-package aichat
    :after '(websocket async-await)

    :straight (:host github :repo "xhcoding/emacs-aichat"))

  (use-package emacs
    :init
    (setq aichat-bingai-cookies-file "~/org-stuff/.bing-chat-cookies-file.json"
          aichat-bingai-chat-file "~/org-stuff/bing-chat.md")

    (defun crj-send-heading-to-bing-chat ()
      "Send the current heading to Bing chat.

    Additionally, perform some cleanup afterwards:

    - remove the now duplicative line we just sent (since `aichat-bingai-chat' prints the query)
    - and turn `markdown-hide-markup' back off."
      (interactive)
      (markdown-back-to-heading)
      (save-excursion
        (forward-word)
        (backward-word)
        (let ((query (buffer-substring (point) (line-end-position))))
          ;; (kill-whole-line -1)
          (aichat-bingai-chat query)))

      ;; (forward-line)

      (setq markdown-hide-markup nil))

    (defun crj-open-bing-chat-file ()
      (interactive)
      (find-file aichat-bingai-chat-file))

    :general
    (:keymaps 'markdown-mode-map
              "C-c C-c s" '(crj-send-heading-to-bing-chat :which-key "Send heading as Bing query."))

    (crj-leader-keys
      "aibs" '(crj-send-heading-to-bing-chat :which-key "Send heading as Bing query.")
      "aibf" '(crj-open-bing-chat-file :which-key "Open Bing chat file.")))
#+end_src

*** Simple queries in buffers with gptel

Interact with ChatGPT, either by sending text to query it with ~gptel-send~ or opening a dedicated buffer with ~gptel~ command. Requires an OpenAI API key.

#+begin_src emacs-lisp :lexical no
  (use-package gptel
    :init
    (setq gptel-api-key (crj--get-open-ai-api-key)))
#+end_src


*** A Terminal-Like Interaction With chatgpt-shell

This one opens a dedicated shell buffer for ChatGPT interactions.

#+begin_src emacs-lisp :lexical no
  (use-package shell-maker
    :straight (:host github
                     :repo "xenodium/chatgpt-shell"
                     :files ("shell-maker.el")))

  (use-package chatgpt-shell
    :requires shell-maker

    :straight (:host github
                     :repo "xenodium/chatgpt-shell"
                     :files ("chatgpt-shell.el"))

    :custom
    ((chatgpt-shell-openai-key (crj--get-open-ai-api-key))))
#+end_src

** Window Management

Emacs has windows, which are more like what you would call a "pane" anywhere else. Evil has some great keybindings, but they're on ~C-w~, and I also want them on my leader keys.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys "w" '(:keymap evil-window-map :which-key "window")))

  (use-package emacs
    :general
    (crj-leader-keys
      "wd" '(evil-window-delete :which-key "Close window.")
      "wB" '(kill-buffer-and-window :which-key "Kill buffer and close window.")))
#+end_src

** EFS/Better Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line configuration for Emacs.  The default configuration is quite good but you can check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that mode line icons display correctly.

#+begin_src emacs-lisp
  (use-package all-the-icons)
  ;; (use-package doom-modeline
  ;;   :init (doom-modeline-mode 1)
  ;;   :custom ((doom-modeline-height 15)))
#+end_src

** Improving Help Commands

Original description of Emacs From Scratch's equivalent section perfectly sums it up, so I'll let it do so:

#+begin_quote
[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' ~describe-~ command buffers.  For example, if you use ~describe-function~, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.
#+end_quote

Besides different keybindings, I've only added a couple extra configurations here:

- ~woman~ is for accessing Unix manual pages from within Emacs. Everything should be from within Emacs!
- ~helpful-at-point~ is a great quick Emacs Lisp documentation lookup. With Evil, I can just press ~K~ on a function or variable and get its documentation and source code. It makes Emacs' amazing introspectability even easier.
- ~consult-minor-mode-menu~ lets you search minor modes, both active and not, and even toggle them! It's not really for getting information /about/ the modes, but you can probably Embark-act to those? I'll think about setting that up when I configure Embark!

#+begin_src emacs-lisp
  (use-package helpful
    :init
    (defun crj--set-elisp-lookup-function ()
      "Sets the documentation function for Emacs Lisp."
      (setq evil-lookup-func #'helpful-at-point))
    (add-hook 'emacs-lisp-mode-hook #'crj--set-elisp-lookup-function)

    :commands (helpful-callable
               helpful-command
               helpful-variable
               helpful-at-point
               helpful-key
               helpful-face)

    :general
    (crj-leader-keys
              "h" '(:ignore t
                            :which-key "Help Menu")
              "hv" '(helpful-variable
                     :which-key "Describe variable.")
              "hf" '(helpful-callable
                     :which-key "Describe function.")
              "hF" '(describe-face
                     :which-key "Describe face.")
              "hk" '(helpful-key
                     :which-key "Describe key.")
              "hx" '(helpful-command
                     :which-key "Describe command.")
              "hW" '(woman
                     :which-key "Search for manual page.")
              "hg" '(customize-group
                     :which-key "Search for customize group.")
              "hm" '(consult-minor-mode-menu
                     :which-key "Search through minor modes.")
              "hM" '(describe-mode
                     :which-key "Describe currently active modes."))
    ([remap describe-function] #'helpful-callable)
    ([remap describe-command] #'helpful-command)
    ([remap describe-variable] #'helpful-variable)
    ([remap describe-key] #'helpful-key)
    ("C-h g" #'customize-group)
    ("C-h F" #'describe-face))
#+end_src

*** TODO set help commands on the help map

** EFS/Configure Babel Languages

To execute or export code in ~org-mode~ code blocks, you'll need to set up ~org-babel-load-languages~ for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with ~org-babel~.

#+begin_src emacs-lisp

  ;; (with-eval-after-load 'org
    ;; (org-babel-do-load-languages
     ;; 'org-babel-load-languages
     ;; '((emacs-lisp . t)
       ;; (python . t)))

    ;; (push '("conf-unix" . conf-unix) org-src-lang-modes))

#+end_src

** EFS/Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with ~org-tempo~ by typing ~<~ followed by the template name like ~el~ or ~py~ and then press ~TAB~.  For example, to insert an empty ~emacs-lisp~ block below, you can type ~<el~ and press ~TAB~ to expand into such a block.

You can add more ~src~ block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))

#+end_src

** EFS/Languages

*** Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp

  ;; (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
    ;; :commands dap-debug
    ;; :config
    ;; Set up Node debugging
    ;; (require 'dap-node)
    ;; (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    ;; Bind `C-c l d` to `dap-hydra` for easy access
    ;; (general-define-key
     ;; :keymaps 'lsp-mode-map
     ;; :prefix lsp-keymap-prefix
     ;; "d" '(dap-hydra t :wk "debugger")))

#+end_src

** EFS/Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (~ls~, ~rm~, ~mv~, ~grep~, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing ~vim~ to ~find-file~).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- ~C-c C-p~ / ~C-c C-n~ - go back and forward in the buffer's prompts (also ~[[~ and ~]]~ with evil-mode)
- ~M-p~ / ~M-n~ - go back and forward in the input history
- ~C-c C-u~ - delete the current input string backwards up to the cursor
- ~counsel-esh-history~ - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp

  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim"))))


#+end_src

** EFS/Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings

**** Navigation

*Emacs* / *Evil*
- ~n~ / ~j~ - next line
- ~p~ / ~k~ - previous line
- ~j~ / ~J~ - jump to file in buffer
- ~RET~ - select file or directory
- ~^~ - go to parent directory
- ~S-RET~ / ~g O~ - Open file in "other" window
- ~M-RET~ - Show file in other window without focusing (previewing files)
- ~g o~ (~dired-view-file~) - Open file but in a "preview" mode, close with ~q~
- ~g~ / ~g r~ Refresh the buffer with ~revert-buffer~ after changing configuration (and after filesystem changes!)

**** Marking files

- ~m~ - Marks a file
- ~u~ - Unmarks a file
- ~U~ - Unmarks all files in buffer
- ~* t~ / ~t~ - Inverts marked files in buffer
- ~% m~ - Mark files in buffer using regular expression
- ~*~ - Lots of other auto-marking functions
- ~k~ / ~K~ - "Kill" marked items (refresh buffer with ~g~ / ~g r~ to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- ~C~ - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- ~U~ - Unmark all files in buffer
- ~R~ - Rename marked files, renaming multiple is a move!
- ~% R~ - Rename based on regular expression: ~^test~ , ~old-\&~

*Power command*: ~C-x C-q~ (~dired-toggle-read-only~) - Makes all file names in the buffer editable directly to rename them!  Press ~Z Z~ to confirm renaming or ~Z Q~ to abort.

**** Deleting files

- ~D~ - Delete marked file
- ~d~ - Mark file for deletion
- ~x~ - Execute deletion for marks
- ~delete-by-moving-to-trash~ - Move to trash instead of deleting permanently

**** Creating and extracting archives

- ~Z~ - Compress or decompress a file or folder to (~.tar.gz~)
- ~c~ - Compress selection to a specific file
- ~dired-compress-files-alist~ - Bind compression commands to file extension

**** Other common operations

- ~T~ - Touch (change timestamp)
- ~M~ - Change file mode
- ~O~ - Change file owner
- ~G~ - Change file group
- ~S~ - Create a symbolic link to this file
- ~L~ - Load an Emacs Lisp file into Emacs

** Utility Functions
Making my life easier!

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun crj-cycle-setting (setting potential-values)
      "Cycle SETTING through POTENTIAL-VALUES.

      SETTING is a quoted symbol.

      POTENTIAL-VALUES is a list of values to cycle through.

  This is a very useful helper function for use when cycling a setting through potential values.

  See `crj-cycle-line-numbers' for an example usage."
      (let* ((i (cl-position (eval setting) potential-values))
             (next-i (1+ i))
             (new-value (if (eq next-i (length potential-values))
                            (car potential-values)
                          (nth next-i potential-values))))

        (set setting new-value))))
#+end_src

** Modeline

Not sure what to do about the modeline for now, although it's also... not very important!

I'd like to clean it up, and... maybe make Evil states more visible? Probably do some actual config here eventually!

** Config Changes Todo

*** timers

*** Add markup mode add-heading-above command

*** switch to msgs buffer cmd

*** targets

*** kill rest of line in insert state

*** get full emacs movements in minibuffer

*** evil show ex digraphs

*** ace link

*** file management

#+begin_src emacs-lisp :lexical no :tangle no
  (setq! auto-save-default t)
  (setq backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist '(("." . "~/.emacs.d/backups/"))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)       ; use versioned backups
  (setq auto-save-file-name-transforms
    `((".*" "~/.emacs.d/backups/" t)))
#+end_src

*** Better scratch buffers

#+begin_src emacs-lisp :lexical no :tangle no
  (defun crj--get-new-scratch-buffer-mode (previous-mode read-only-p desired-mode)
    (cond (desired-mode desired-mode)
          ((not read-only-p) previous-mode)
          (t 'emacs-lisp-mode)))

  (defun crj/open-scratch-buffer (&optional new-buffer-p project-p same-window-p desired-mode)
    "Open a scratch buffer with the current buffer's mode applied.

  Passes on arguments to `doom/open-scratch-buffer'. See that function's doc string for the arguments used.

  Setting `doom-scratch-initial-major-mode' to `t' was supposed to handle the \"use the same mode\" part, but it does not appear to be working. So: hack."
    (interactive)
    (let ((new-mode (crj--get-new-scratch-buffer-mode major-mode buffer-read-only desired-mode)))
      (doom/open-scratch-buffer new-buffer-p project-p same-window-p)
      (funcall new-mode)))

  (defun crj/switch-to-scratch-buffer ()
    "Switch to the scratch buffer with the current mode applied."
    (interactive)
    (crj/open-scratch-buffer nil nil t))

  ;; Currently unused, but... here's how I'd do it if I brought it back.
  (defun crj/open-new-scratch-buffer ()
    "View a new scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer t))

  (defun crj/open-project-scratch-buffer ()
    "Open a project-specific scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer nil t))

  (defun crj/open-project-scratch-buffer-in-new-window ()
    "View a project-specific scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer nil t t))

  (defun crj/open-scratch-buffer-in-emacs-lisp-mode ()
    "Open a scratch buffer in `emacs-lisp-mode.'"
    (interactive)
    (crj/open-scratch-buffer nil nil nil 'emacs-lisp-mode))

  (defun crj/open-scratch-buffer-in-a-js-mode ()
    "Open a scratch buffer in `rjsx-mode"
    (interactive)
    (crj/open-scratch-buffer nil nil nil 'rjsx-mode))

  (defun crj/switch-to-scratch-buffer-in-emacs-lisp-mode ()
    "Switch to a scratch buffer in `emacs-lisp-mode'."
    (interactive)
    (crj/open-scratch-buffer nil nil t 'emacs-lisp-mode))

  (defun crj/switch-to-scratch-buffer-in-a-js-mode ()
    "Switch to a scratch buffer in a JavaScript Mode

  Currently we're using `rjsx-mode'."
    (interactive)
    (crj/open-scratch-buffer nil nil t 'rjsx-mode))

  ;; Gotta remove doom's built-in ones first.
  (define-key doom-leader-map "x" nil)
  (define-key doom-leader-map "X" nil)

  (map! :leader
        (:prefix ("x" . "open scratch")
         :desc "Open a scratch buffer in current mode." :n "x" #'crj/open-scratch-buffer
         :desc "Open a scratch buffer in Emacs Lisp mode." :n "e" #'crj/open-scratch-buffer-in-emacs-lisp-mode
         :desc "Open a scratch buffer in a JS mode." :n "j" #'crj/open-scratch-buffer-in-a-js-mode)
        (:prefix ("X" . "switch to scratch")
         :desc "Open a scratch buffer in current mode." :n "x" #'crj/switch-to-scratch-buffer
         :desc "Open a scratch buffer in Emacs Lisp mode." :n "e" #'crj/switch-to-scratch-buffer-in-emacs-lisp-mode
         :desc "Open a scratch buffer in a JS mode." :n "j" #'crj/switch-to-scratch-buffer-in-a-js-mode))

  (setq doom-scratch-dir "~/Documents/work/playground/")
#+end_src

*** Save and kill buffer

#+begin_src emacs-lisp :lexical no :tangle no
  (setq crj/immortal-buffer-names '("*scratch*" "#emacs" "*Messages*" shell-command-buffer-name shell-command-buffer-name-async))

  (defun crj/kill-or-bury-current-buffer ()
    (interactive)
    (if (member (buffer-name (current-buffer)) crj/immortal-buffer-names)
        (bury-buffer)
      (kill-buffer (current-buffer))))

  (defun crj/save-and-kill-or-bury-current-buffer ()
    (interactive)
    (save-buffer)
    (if (member (buffer-name (current-buffer)) crj/immortal-buffer-names)
        (bury-buffer)
      (kill-buffer (current-buffer))))

  (map! :leader
        (:prefix ("b" . "+buffer")
         :desc "Save file and close buffer."
         :n "q"
         #'crj/save-and-kill-or-bury-current-buffer
         :desc "Kill buffer."
         :n "d"
         #'crj/kill-or-bury-current-buffer)
        (:prefix ("f" . "+file")
         :desc "Save file and close buffer."
         :n "q"
         #'crj/save-and-kill-or-bury-current-buffer))
#+end_src

*** mu4e

*** proced

*** Emacs as $EDITOR

And ~e~ in any terminal should open file in Emacs buffer.

*** Better window management

**** after window split, swap windows

**** windows wrap around

~windmove-wrap-around~

**** more window stuff

#+begin_src emacs-lisp :lexical no :tangle no
  (defun hydra-move-split-right-more (arg)
    "Move window split right by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 10)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'left))
          (shrink-window-horizontally movement-amount)
        (enlarge-window-horizontally movement-amount))))

  (defun hydra-move-split-left-more (arg)
    "Move window split left by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 10)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally movement-amount)
        (enlarge-window-horizontally movement-amount))))

  (defun hydra-move-split-up-more (arg)
    "Move window split up by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 5)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window movement-amount)
        (shrink-window movement-amount))))

  (defun hydra-move-split-down-more (arg)
    "Move window split down by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 5)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window movement-amount)
        (enlarge-window movement-amount))))

  (defhydra hydra/crj-window-nav (:hint nil)
    "
  Split: _v_ert  _s_:horz
  Delete: _c_lose  _o_nly
  Switch Window: _h_:left  _j_:down  _k_:up  _l_:right
  Resize: _H_:splitter left  _J_:splitter down  _K_:splitter up  _L_:splitter right
  Balance Windows: _=_
  Quit: _q_
  "

    ("s" +evil/window-split-and-follow)
    ("v" +evil/window-vsplit-and-follow)

    ("c" delete-window)
    ("o" delete-other-windows)

    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)

    ("H" hydra-move-split-left-more)
    ("J" hydra-move-split-down-more)
    ("K" hydra-move-split-up-more)
    ("L" hydra-move-split-right-more)

    ("=" balance-windows)
    ("q" nil))
#+end_src

*** setup bookmark

*** emacs-nm

*** parrot (rotate symbol at point)

*** add pulsar pulse command

*** keycast

*** search online

*** open file at point

*** org character marker toggle

*** ibuffer filters

*** kill all terms

*** jest mode

*** create wttrin library

*** eglot get info on symbol

*** show flymake project diagnostics

#+begin_src emacs-lisp :lexical no :tangle no
    (map! :leader
          (:prefix ("c" . "+code")
                   :desc "Show diagnostics in buffer." :n "x" #'+default/diagnostics
                   :desc "Show project diagnostics." :n "X" #'flymake-show-project-diagnostics))
#+end_src

*** Maybe some more vterm fixes?

#+begin_src emacs-lisp :lexical no :tangle no
  (require 'dwim-shell-commands)

  (setq vterm-max-scrollback 100000)

  (defun crj/toggle-eshell-scrollback ()
    (interactive)
    (if (equal eshell-scroll-to-bottom-on-output 'all)
        (setq eshell-scroll-to-bottom-on-output nil)
      (setq eshell-scroll-to-bottom-on-output 'all)))

  ;; command to toggle scroll-on-output on or off
  (map! :map evil-normal-state :leader
        (:prefix ("z" . "more toggling")
          :desc "toggle terminal auto-scroll" "s" #'crj/toggle-eshell-scrollback
         :desc "read eshell history in" "r" #'eshell/r))


  (setq vterm-always-compile-module t)

  (defun kill-terminals ()
    (interactive)
    (mapc (lambda (buffer)
            (when (string-match-p (regexp-quote "vterm") (buffer-name buffer))
              (kill-buffer buffer)))
          (buffer-list)))

  (map! :leader
        (:prefix ("q" . "quit/session")
         :desc "Kill all terminals."
         :n "t" #'kill-terminals))


  (map! :leader
        (:prefix ("v" . "view")
         :desc "View available eshell buffers." :n "e" #'+eshell/switch-to))

  ;; zsh baby
  (setq vterm-shell "/usr/sbin/zsh")

  (defun open-vterm-other-frame ()
    (interactive)
    (make-frame-command)
    (let ((buf (current-buffer)))
      (switch-to-buffer buf)
      (switch-to-buffer-other-frame buf))
    (+vterm/here nil))

  (defun open-eshell-other-frame ()
    (interactive)
    (make-frame-command)
    (let ((buf (current-buffer)))
      (switch-to-buffer buf)
      (switch-to-buffer-other-frame buf))
    (+eshell/here))

  (defun crj/vterm-in-current-directory ()
    (interactive)
    (+vterm/here t))

  ;; set up did-you-mean suggestions
  ; (eshell-did-you-mean-setup)

  ;; open terminals
  (map! :leader
        (:prefix ("o" . "open")
         :desc "Open vterm buffer in current directory"
         :n "v" #'crj/vterm-in-current-directory
         :desc "Open vterm in other frame"
         :n "V" #'open-vterm-other-frame
         :desc "Open eshell buffer"
         :n "e" #'+eshell/here
         :desc "Open eshell in other frame"
         :n "E" #'open-eshell-other-frame))

  ;;; Toggleable vterm/eshell popups
  (map! :map evil-normal-state :leader
        (:prefix ("t" . "toggle")
         :desc "eshell popup" "e" #'+eshell/toggle
         :desc "vterm popup" "v" #'+vterm/toggle))

  ;; TODO switch eshell buffers

  ;; remember moar better
  (setq eshell-history-size 100000)

  ;; Some
  (map! :map 'vterm-mode-map
        "C-c <escape>" #'vterm-send-escape
        "C-c :" #'vterm--self-insert)


  ;; turn off their history saving so we can do it more often
  (setq eshell-save-history-on-exit nil)

  (defun crj/eshell-update-history ()
    "Append to eshell's command history and read it everywhere."
    (when eshell-history-ring
      (let ((newest-cmd-ring (make-ring 1)))
        (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
        (let ((eshell-history-ring newest-cmd-ring))
          (eshell-write-history eshell-history-file-name t)))))

  ;; always write to eshell history after every command
  (add-hook 'eshell-pre-command-hook 'crj/eshell-update-history)
  ;; When creating a new terminal, get the history of all previous terminals.
  (add-hook 'eshell-hist-load-hook 'eshell-read-history)

  (setq async-shell-command-buffer 'new-buffer)

  (defun crj/async-shell-command-no-window ()
    "A version of `async-shell-command' that won't create a window to display its
  output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'async-shell-command
     shell-command-buffer-name-async))

  (defun crj/shell-command-no-window ()
    "A version of `shell-command' that won't create a window to display its output
  buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'shell-command
     shell-command-buffer-name))

  (defun crj/projectile-run-shell-command-in-root-no-window ()
    "A version of `projectile-run-shell-command-in-root' that won't create a
  window to display its output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'projectile-run-shell-command-in-root
     shell-command-buffer-name))

  (defun crj/projectile-run-async-shell-command-in-root-no-window ()
    "A version of `projectile-run-async-shell-command-in-root' that won't create a
  window to display its output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'projectile-run-async-shell-command-in-root
     shell-command-buffer-name-async))

  (map! :leader :n "7" #'crj/async-shell-command-no-window)
  (map! :leader :n "&" #'async-shell-command)
  (map! :leader :n "1" #'crj/shell-command-no-window)
  (map! :leader :n "!" #'shell-command)
  (map! :leader
        (:prefix "p"
         :desc "Run project async shell command without a window opening."
         :n "7" #'crj/projectile-run-async-shell-command-in-root-no-window
         :desc "Run project shell command without a window opening."
         :n "1" #'crj/projectile-run-shell-command-in-root-no-window))

  ;; TODO maybe this code can help?
  ;; (add-to-list 'display-buffer-alist
  ;; 	     (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
  (defun crj/call-and-bury-window-from-interactive-command (command window-name)
    "A helper function that calls COMMAND interactively while preventing any
    buffer with the name WINDOW-NAME from creating a window.

  This is useful for times when you want a command to create an output buffer
  without distracting the user."
    (let
        ((display-buffer-alist
          '(window-name '(#'display-buffer-no-window))))
      (call-interactively command)))

  ;; Good for playing nice with vi mode shell keybindings. See `crj/toggle-evil-in-vterm' for more info.
  (defun crj/set-up-vterm ()
    (turn-off-evil-mode))

  ;; Hook for running above function for each new vterm buffer.
  ;; Turned off for now.
  ;; (add-hook 'vterm-mode-hook #'crj/set-up-vterm)

  (defun crj/toggle-evil-in-vterm ()
    "Toggles evil mode in Vterm so as to leave ESC to the shell's keybindings.

  To use:

  ;; Start with evil turned off.
  (add-hook 'vterm-mode-hook #'turn-off-evil-mode)
  ;; Add to the copy-mode hook.
  ;; Which runs on entering /or/ leaving Vterm Copy Mode.
  (add-hook 'vterm-copy-mode-hook #'crj/toggle-evil-in-vterm)

  The problem we're trying to solve here is that if you want to use
  both Emacs' Evil Mode and your shell's Vim keybindings, then when
  you press ESC to switch to Normal Mode, do you want Evil Mode's
  Normal Mode or the shell's Normal Mode? Without a solution, Evil
  Mode will greedily gobble the ESC up and you'll be unable to
  enter your shell's Vim emulation. So we need to be able to
  disambiguate which Normal Mode we want to enter.

  This function provides a solution that leverages Vterm Copy Mode
  to give Emacs an alternative way to exit to Evil's Normal Mode,
  leaving ESC to the shell.

  An alternative solution is to keep ESC for Evil's Normal Mode and
  use a different keybinding for the shell's Normal Mode.

  Here are a couple ways to do that:

  1. Set a non-ESC keybinding for entering normal mode in your
  shell's config file.

  - You can do this in your bash configuration file:

  bind '\"jk\":vi-movement-mode'

  Source: URL'https://unix.stackexchange.com/a/303401'

  - For zsh, you can use the following in your config file:

  bindkey -M viins jk vi-cmd-mode

  Source: URL'https://unix.stackexchange.com/a/697026'

  - For zsh, you could also use the excellent zsh plugin Zsh Vim
    Mode (URL'https://github.com/softmoth/zsh-vim-mode'), which has
    many benefits including additional ways you can customize
    entering Normal Mode.

  2. An alternative method for keeping ESC reserved for Evil Mode
  is to leverage Vterm Mode's ability to send a key directly to the
  shell. You can do this, for example:

  (define-key vterm-mode-map (kbd \"C-c <escape>\") #'vterm-send-escape)

  This will mean that using ~C-c <escape>~ will send the escape key
  to your shell. ~ESC~ goes to Evil, while ~C-c ESC~ sends ESC to
  your shell. This means you can use ESC in other places in your
  shell besides the direct command line, which can be useful for
  interactive shell programs as well. (Thus, this is recommended
  even with this function's solution.)

  In short, this function's solution allows you to have the same
  exact experience in a Vterm as you do in a non-Emacs terminal
  emulator.

  The advantage of the other solutions is that you keep the same
  Emacs Evil keybinding of ESC even in Vterm Mode.

  Which solution works for you likely depends on which workflow you
  prioritize and which context you want to context-switch in."

    (interactive)
    (if (bound-and-true-p vterm-copy-mode)
        (progn
          (turn-on-evil-mode)
          (evil-normal-state))
      (evil-insert-state)
      (turn-off-evil-mode)))

  (map! :map vterm-mode-map
        "C-c t" #'vterm-copy-mode
        "C-c n" #'vterm-copy-mode)

  (map! :map vterm-copy-mode-map
        "C-c t" #'vterm-copy-mode
        "C-c i" #'vterm-copy-mode)

  ;; (add-hook 'vterm-copy-mode-hook #'crj/toggle-evil-in-vterm)
#+end_src

*** string inflection

#+begin_src emacs-lisp :lexical no :tangle no
  (map! :n "zc" nil)
  (map! (:prefix "z"
         :desc "Open all folds."
         :n "R" #'org-fold-show-all
         (:prefix ("c" . "Manage case")
          (:desc "Cycle Case" :n "z" #'string-inflection-all-cycle
           :desc "Switch to camelCase" :n "c" #'string-inflection-lower-camelcase
           :desc "Switch to PascalCase" :n "C" #'string-inflection-camelcase
           :desc "Switch to snake_case" :n "s" #'string-inflection-underscore
           :desc "Switch to kebab-case" :n "k" #'string-inflection-kebab-case))))
#+end_src

*** Forge PRs

#+begin_src emacs-lisp :lexical no :tangle no
  (map! :leader (:prefix "g" :desc "Checkout pull request." :n "v" #'forge-checkout-pullreq))
#+end_src

*** Elisp

#+begin_src emacs-lisp :lexical no :tangle no
  (defun crj/open-intro-to-elisp ()
    "Open the manual for \"An Introduction to Programming in Emacs Lisp\" (Info
    node '(eintr)'), re-using the current window."
    (interactive)
    (info "eintr")
    (delete-other-windows))

  (defun crj/open-elisp-reference-manual ()
    "Open the manual for the \"GNU Emacs Lisp Reference Manual\" (Info node
    '(elisp)'), re-using the current window."
    (interactive)
    (info "elisp")
    (delete-other-windows))

  (map!
   :leader
   (:prefix "o"
    :n "l" #'crj/open-elisp-reference-manual
    :n "L" #'crj/open-intro-to-elisp))

  ;;; Evaluating Elisp

  (map! :leader :n "e" #'+eval:region)
  (map! :leader :n "E" #'+eval:replace-region)

  (map!
   :leader
   (:prefix ("t" . "Toggle")
    :desc "debug during elisp errors."
    :n "B" #'toggle-debug-on-error))
#+end_src

*** check if org tangle now does what you want from your Doom Emacs config

*** automatically or at least easily add current project

*** rename buffers

**** add better shortcut for it

**** rename buffer with project name prefix

#+begin_src emacs-lisp :lexical no
  (defun rename-buffer-with-project-name-prefix ()
  "Prompts the user to rename the buffer, supplying the project prefix."
    (interactive)
    (let* ((project-prefix (concat (projectile-default-project-name (projectile-project-name)) "-"))
           (prompt (concat "New Buffer Name: " project-prefix))
           (name (concat project-prefix (read-string prompt))))
      (rename-buffer name)))
#+end_src

*** Check if THIS is a tangle we have natively now:

#+begin_src emacs-lisp :lexical no :tangle no
  (defun org-babel-tangle-single-block (block-counter &optional only-this-block)
    "Collect the tangled source for current block.
  Return the list of block attributes needed by
  `org-babel-tangle-collect-blocks'.  When ONLY-THIS-BLOCK is
  non-nil, return the full association list to be used by
  `org-babel-tangle' directly."
    (let* ((info (org-babel-get-src-block-info))
           (start-line
            (save-restriction (widen)
                              (+ 1 (line-number-at-pos (point)))))
           (file (buffer-file-name (buffer-base-buffer)))
           (src-lang (nth 0 info))
           (params (nth 2 info))
           (extra (nth 3 info))
           (coderef (nth 6 info))
           (cref-regexp (org-src-coderef-regexp coderef))
           (link (org-babel-tangle--unbracketed-link params))
           (source-name
            (or (nth 4 info)
                (format "%s:%d"
                        (or (ignore-errors (nth 4 (org-heading-components)))
                            "No heading")
                        block-counter)))
           (expand-cmd (intern (concat "org-babel-expand-body:" src-lang)))
           (assignments-cmd
            (intern (concat "org-babel-variable-assignments:" src-lang)))
           (body
            ;; Run the tangle-body-hook.
            (let ((body (if (org-babel-noweb-p params :tangle)
                            (if (string= "strip-tangle" (cdr (assq :noweb (nth 2
                                                                               info))))
                                (replace-regexp-in-string (org-babel-noweb-wrap)
                                                          "" (nth 1 info))
                              (org-babel-expand-noweb-references info))
                          (nth 1 info))))
              (with-temp-buffer
                (insert
                 ;; Expand body in language specific manner.
                 (cond ((assq :no-expand params) body)
                       ((fboundp expand-cmd) (funcall expand-cmd body params))
                       (t
                        (org-babel-expand-body:generic
                         body params (and (fboundp assignments-cmd)
                                          (funcall assignments-cmd params))))))
                (when (string-match "-r" extra)
                  (goto-char (point-min))
                  (while (re-search-forward cref-regexp nil t)
                    (replace-match "")))
                (run-hooks 'org-babel-tangle-body-hook)
                (buffer-string))))
           (comment
            (when (or (string= "both" (cdr (assq :comments params)))
                      (string= "org" (cdr (assq :comments params))))
              ;; From the previous heading or code-block end
              (funcall
               org-babel-process-comment-text
               (buffer-substring
                (max (condition-case nil
                         (save-excursion
                           (org-back-to-heading t) ; Sets match data
                           (match-end 0))
                       (error (point-min)))
                     (save-excursion
                       (if (re-search-backward
                            org-babel-src-block-regexp nil t)
                           (match-end 0)
                         (point-min))))
                (point)))))
           (src-tfile (cdr (assq :tangle params)))
           (result
            (list start-line
                  (if org-babel-tangle-use-relative-file-links
                      (file-relative-name file)
                    file)
                  link
                  source-name
                  params
                  (if org-src-preserve-indentation
                      (org-trim body t)
                    (org-trim (org-remove-indentation body)))
                  comment)))
      (if only-this-block
          (let* ((file-name (org-babel-effective-tangled-filename
                             (nth 1 result) src-lang src-tfile)))
            (list (cons file-name (list (cons src-lang result)))))
        result)))

  (defun org-babel-noweb-p (params context)
    "Check if PARAMS require expansion in CONTEXT.
  CONTEXT may be one of :tangle, :export or :eval."
    (let ((allowed-values (cl-case context
                            (:tangle '("yes" "tangle" "no-export" "strip-export"
                                       "strip-tangle"))
                            (:eval   '("yes" "no-export" "strip-export" "eval"
                                       "strip-tangle"))
                            (:export '("yes" "strip-tangle")))))
      (cl-some (lambda (v) (member v allowed-values))
               (split-string (or (cdr (assq :noweb params)) "")))))
#+end_src
