#+title: Colin Jaffe's Literate Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :mkdirp yes :tangle init.el :padline yes

* Colin Jaffe's Literate Config

** Introduction

This is my configuration for Emacs, the greatest text editor. Note that "greatest" doesn't necessarily mean "best for everyone"which we'll explore as we go!. It contains:

- *code for configuring Emacs*, including setting up a nice system for downloading and installing 3rd-party packages
- code to install and configure many, many *third-party packages*
- *custom functions* to get /just/ the behavior I want in a text editor
- my thinking on *why* these configurations, *why* these packages, and, especially, *why* Emacs

Per that last point: this document is, through the magic of "literate programming", both *the commentary* /and/ *the code itself*.

We'll explore that /too/ as we go!

** Why Emacs?

Well, most people use it predominantly as a text editor, but at its nerdy awkward heart it's actually a Lisp programming environment. Setting Emacs' preferences and extending it with third-party code is all done through Lisp code that the Emacs user writes.

[[https://www.explainxkcd.com/wiki/index.php/297:_Lisp_Cycles][https://www.explainxkcd.com/wiki/images/e/eb/lisp_cycles.png]]

This is my code so far.

I'm basing this new config on the Emacs from Scratch repo, which is a lot more sparse. I'm currently changing this config considerably by:

1. Paring down the config I copied over from EFS.
2. Going through Doom Emacs' vast built-in modules, taking the code I want.

So that's where we started and where we're going. Let's look at some code!

** Fixing Emacs Lisp

I mean, I'm just adding lexical scope here. But it's an important change!

#+NAME: lexical-binding
#+begin_src emacs-lisp :lexical yes
  ;;; -*- lexical-binding: t -*-
#+end_src

** Literate Config Setup

Literate programming is an approach where, instead of putting comments in code to explain things, we put code in the middle of commentary. The document you’re reading right now is an example of literate programming, often called a literate config when its purpose is configuring apps. All of the code blocks in this document are “tangled”, which means that they are copied from this document to a code file. The code file itself is rarely edited directly—instead, the code is edited here, along with its explanation. This ensures that any code in here is documented… there’s always a reason for a block of code to exist. The documentation can’t fall behind the code—the documentation /is/ the code.

You can read more on this subject… and I’ll probably write more. But in the meantime: the function below simply ensures that any time this document is saved, its code is automatically tangled to the appropriate code files. It’s pretty sweet!

#+NAME: tangle-on-save
#+begin_src emacs-lisp :lexical yes
  (defun efs--org-babel-tangle-config ()
    "Automatically tangle our Emacs.org config file when we save it. Credit to Emacs From Scratch for this one!"
    (when (string-equal (buffer-file-name)
                        (expand-file-name "readme.org" user-emacs-directory))

      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs--org-babel-tangle-config)))
#+end_src

** Start With Messages

I usually want to see the startup log first, and I'm tired of manually switching to it.

#+NAME: start-with-messages
#+begin_src emacs-lisp :lexical yes
  (switch-to-buffer "*Messages*")
#+end_src

** Package System

Getting Emacs users' awesome libraries (called "packages") into Emacs.

Emacs has a built in package manager, but it doesn't make it easy to automatically install packages on a new system the first time you pull down your configuration. ~use-package~ and ~straight~ are a really helpful package combination that makes it a lot easier to automate the installation and configuration of everything else we use.

Let's install ~straight~.

#+NAME: bootstrap-straight
#+begin_src emacs-lisp :lexical yes
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

And turn off the built-in package manager. (This needs to go in ~early-init.el~, but I can tangle it to there from this document with a header arg, which you can see if you're looking at this document as a raw ~org-mode~ file. If that sounds like a whole thing, well... it's also not terribly important detail! But I included it anyway! Not sure why!)

#+NAME: turn-off-package
#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

Use ~straight~ to install ~use-package~, with a quick tweak to add its declarations to ~imenu~.

#+NAME: use-package-imenu-integration
#+begin_src emacs-lisp :lexical yes
  (setq use-package-enable-imenu-support t)
  (straight-use-package 'use-package)
#+end_src

Tell ~use-package~ to install packages using ~straight~ whenever I declare a ~use-package~ block.

#+NAME: use-package-straight-integration
#+begin_src emacs-lisp :lexical yes
(use-package straight
  :custom
  (straight-use-package-by-default t))
#+end_src

Now every time I configure a package with ~use-package~, ~use-package~ will use ~straight~ to install the package first.

This means that if you or I copy this configuration to another machine and launch Emacs, it will install the necessary packages automatically and configure them the exact same way. This is now a portable document capable of replicating my setup anywhere. And explaining it!

The only extra step necessary is that, because this file is actually an org document, you'll have to run Emacs, tangle this file, and then restart Emacs. But such is the price of being literate(ly configured).

** Emacs OS Integration

*** Start The Emacs Server

Running an Emacs server means that every single Emacs frame (or "window" in operating system parlance) that you create isn't a new instance of Emacs, but belongs to the same Emacs as all the other frames. This makes opening a new Emacs frame lightning fast, reducing the cost of having lots of Emacs libraries and making the fact that Emacs initially takes 10 seconds to start up completely beside the point.

#+NAME: start-emacs-server
#+begin_src emacs-lisp :lexical yes
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

*** Set It As The Default Editor

Some of this is set in my terminal settings, but Emacs can also send commands to the shell, and has (many) shells of its own. We want to make sure that Emacs is the default editor any time that happens.

#+NAME: use-emacs-as-system-wide-editor-within-emacs-shells
#+begin_src emacs-lisp :lexical yes
  (use-package with-editor
    :init
    (require 'compat)
    (keymap-global-set "<remap> <async-shell-command>"
                       #'with-editor-async-shell-command)
    (keymap-global-set "<remap> <shell-command>"
                       #'with-editor-shell-command)

    (dolist (hook '(shell-mode-hook eshell-mode-hook term-exec-hook vterm-mode-hook))
      (add-hook hook #'with-editor-export-editor)))
#+end_src

** Cleaning Up The Modeline

This package removes minor mode names from the mode line.

Some minor mode names make themselves /very/ hard to remove through some "clever" programming. Those configs are usually with their modes, but i"ve got a couple here I didn't feel like putting anywhere. So here they are.

(I should probably move the org-src one to the org mode config, though.)

#+NAME: remove-minor-modes-from-mode-line
#+begin_src emacs-lisp :lexical yes
  (use-package diminish
    :init
    (defun crj--diminish-eldoc-mode ()
      (diminish 'eldoc-mode))

    (add-hook 'eldoc-mode-hook #'crj--diminish-eldoc-mode)

    (defun crj--diminish-org-src-mode ()
      (diminish 'org-src-mode))

    (add-hook 'org-src-mode-hook #'crj--diminish-org-src-mode))
#+end_src

** Keybindings

Like many Vimmers, I eventually realized that the things I personally liked about Vim were even more present in Emacs. This very much includes Vim keybindings, which are available through Evil Mode, In a lot of ways, Evil mode is /more Vim than Vim/. This is something I could argue at length, but... maybe not in this space. (Yet?)

*** Installing And Using General

Before we even get to the keybindings themselves, let's set up a good Vimmish system here. ~general~ is a great system for setting up keybindings. It integrates very well with ~use-package~, ~evil~, and ~which-key~.

We can use ~general-create-definer~ to define a pair of leader keys. A leader key is a key you can press that begins a keybinding. We'll see some examples in a sec.

#+NAME: define-leader-key
#+begin_src emacs-lisp :lexical yes
  (use-package general
    :init
    (general-create-definer leader
      :states '(normal motion emacs visual)
      :keymaps 'override
      :prefix "SPC"))
#+end_src

This code defines a /function/ called ~leader~ that we can use from now on to define keybindings. The important thing here is that we can define upfront what ~leader~ does—what Evil States it's active in, and that it will activate with either spacebar in Evil Normal State, or Meta-spacebar (Alt- or Option-spacebar) when spacebar would otherwise do something else (like print an actual space).

We can now very easily define another level of keybinding. We want ~SPC f~ to activate commands that have to do with files—thus the ~f~.

#+NAME: add-files-menu
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "f" '(:ignore t :which-key "Files Menu")))
#+end_src

From now on, when you press the user presses the spacebar (or ~M-SPC~) and then ~f~, they'll have access to any commands that follow. And when we put ~which-key~ in there momentarily, when they press ~SPC~ they'll get a menu that will show them that ~f~ leads to commands labeled "files", and if they press ~f~ they'll see a list of letters they can press next and the commands that each will activate.

Let's define a few commands that open specific commonly accessed files as examples, and then bind them to keys using this system.

#+NAME:commands-for-common-file-access
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq org-directory "~/org-stuff")

    (defun crj-open-literate-config-file ()
      "Open the literate config file in the user directory."
      (interactive)
      (find-file (expand-file-name "readme.org" user-emacs-directory)))

    (defun crj-open-task-list ()
      "Open the master task list file."
      (interactive)
      (find-file (expand-file-name "readme.org" org-directory)))

    (defun crj-open-quick-note-file ()
      "Open the file used for quick notes."
      (interactive)
      (find-file (expand-file-name "quick-note.md" org-directory)))

    :general
    (leader
      "fc" '(crj-open-literate-config-file :which-key "Open literate config file.")
      "ft" '(crj-open-task-list :which-key "Open task list file.")
      "fq" '(crj-open-quick-note-file :which-key "Open quick notes file.")))
#+end_src

Now it's not much code to add fairly complex keybindings, and once we get ~which-key~ installed, they'll be discoverable as well!

Next we'll define a bunch more keybindings, as well as answer the question, /why leader keys at all?/

*** Let's Define Some Menus!

I'll add to this section every time I have a new menu to add to the hierarchy.

I'm also mapping a new help command in a couple places, so that I can later remap ~C-h~ to deleting a character.

#+NAME: menus
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq embark-help-key "C-S-h")

    :general
    ("C-S-h" 'help-command)

    (leader
      "h" '(:keymap help-map :which-key "Help menu.")
      "w" '(evil-window-map :which-key "Window menu.")
      "m" '(:ignore t :which-key "Markup menu.")
      "mc" '(:ignore t :which-key "Markup clock menu.")
      "i" '(:ignore t :which-key "Insert menu.")
      "ic" '(:ignore t :which-key "Insert cursor menu.")
      "l" '(:ignore t :which-key "Lisp menu.")
      "b" '(:ignore t :which-key "Buffers menu.")
      "t" '(:ignore t :which-key "Toggle menu.")
      "s" '(:ignore t :which-key "Search menu.")
      "z" '(:ignore t :which-key "Zooming menu.")
      "c" '(:ignore t :which-key "Code menu.")
      "q" '(:ignore t :which-key "Quit menu.")
      "p" '(:ignore t :which-key "Project menu.")
      "v" '(:ignore t :which-key "Visualize menu.")
      "a" '(:ignore t :which-key "Applications menu.")
      "ac" '(:ignore t :which-key "Calendar menu.")
      "am" '(:ignore t :which-key "Music menu.")
      "ap" '(:ignore t :which-key "Process management menu.")
      "acg" '(:ignore t :which-key "Google Calendar menu.")
      "g" '(:ignore t :which-key "Git menu.")
      "ai" '(:ignore t :which-key "AI menu.")
      "aib" '(:ignore t :which-key "Bing Chat menu.")))
#+end_src

*** General Emacs' Keybindings

Many of my keybindings are taken from Doom Emacs' well-thought-through keybindings—although part of this is certainly that I'm just used to using them for the last couple of years.

In Vanilla Emacs' keybinding land, the focus is on often elaborate key "chords", where you use a series of modifier key-letter pairs, while in Vim/Evil, most commands use a "leader" key.

For example, opening a file in Vanilla Emacs keybindings would be ~C-x C-f~, which means to hold down the ~Control~ key, press ~x~, then, still holding down ~Control~ (or re-pressing and holding it), press ~f~. This can be a bit of a strain on your hand, although certainly less so if you follow best practices and swap ~Control~ and ~Caps Lock~.

In Evil-Mode-style keybindings, the same command might be something like ~SPC f o~, which means press the ~spacebar~, then press the ~f~ key, then press the ~o~ key.

This works because in a modal editing system like Vim and Evil, pressing keys doesn't type anything into a file, but activates commands instead. For example, ~/~ begins a text search (like ~C-f~ or ~Command-f~ in many apps), and ~dd~ deletes the line the cursor is on. To enter a text insertion state and actually type text, you have to use a command—in Evil/Vim, the classic command is ~i~ (for ~i~nsert).

This system of different "modes" (Vim parlance) or "states" (Evil parlance, since "mode" has a different meaning in Emacs) gives you tons of freedom in your keybindings. If you /don't/ have non-typing states to unlock these fast editing commands, you need to use modifiers keys like ~Control~ and ~Alt~ and ~Command~ to differentiate commands from typing. In a modal system's "normal state"—so called because editing text is /more/ common than typing new text—you can use ~SPC f o~ to ~o~ pen a ~f~ ile. This opens you up to simpler keybindings that can be a little more mnemonic /without/ contorting your hands.

Let's see some examples!

The following binds ~SPC f s~ to save a file. It's nice and mnemonic, as well as just three quick presses.

#+NAME: file-saving-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "fs" '(save-buffer :which-key "Save current buffer.")))
#+end_src

The ~:prefix "SPC"~ tells ~general~ that this is a "leader key", a key that leads off a set of commands. ~:keymaps normal~ indicates that this is a command for "normal state"—which makes sense, because in a typing state like insert state, you want the spacebar to actually type a space! The next line, the ~"f"~ one, creates a sort of menu for further commands, which will (soon) include keybound commands that have to do with files (maybe copy and rename/move will go there, for example). The ~:which-key~ keyword in that and the following line, where we finally bind the ~save-buffer~ command, tells ~which-key~ (see the "Which Key" section below) how to label the menu and commands for discoverability.

To see a good example of a menu with many commands in it, see the section on Helpful commands.

You don't always have to have commands in a deep hierarchy of sections. Here is a simple-if-not-mnemonic ~SPC .~ for opening or creating a file. (And you can also launch ~dired~ with it!) This is such a common command that it's good not to bury it in a menu.

#+NAME: open-or-create-file-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "." '(find-file :which-key "Open or create file.")))
#+end_src

I think you get the basics—as I did with learning and writing this section! Let's throw a bunch of commonly-used universal Emacs keybindings together now!

#+NAME: common-emacs-keybindings
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (leader
      "," '(consult-buffer :which-key "Switch buffer or open recent file.")
      "<" '(consult-project-buffer :which-key "Switch to project-specific buffer.")
      "TAB" '(evil-switch-to-windows-last-buffer :which-key "Previous buffer.")
      ";" '(execute-extended-command :which-key "Run interactive command.")
      ":" '(eval-expression :which-key "Evaluate expression.")
      "y" '(consult-yank-from-kill-ring :which-key "Select from clipboard history.")))
#+end_src

And adding some buffer commands, including a custom one.

#+NAME: common-buffer-command-keybindings
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defconst crj--immortal-buffer-names '("*scratch*"
                                           "#emacs"
                                           "*Messages*"
                                           shell-command-buffer-name shell-command-buffer-name-async))

    (defun crj-kill-or-bury-current-buffer ()
      "Kill the current buffer.

  Unless it's a buffer we should always keep alive, in which case we just bury it in the buffer list."
      (interactive)
      (if (member (buffer-name (current-buffer)) crj--immortal-buffer-names)
          (bury-buffer)
        (kill-buffer (current-buffer))))

    :general
    (leader
      "bd" '(crj-kill-or-bury-current-buffer :which-key "Kill buffer.")
      "bz" '(bury-buffer :which-key "Bury buffer.")
      "br" '(revert-buffer :which-key "Revert buffer.")
      "bW" '(kill-buffer-and-window :which-key "Kill buffer and close window.")))
#+end_src

*** Or Maybe Redo Keybindings To Be More Readable?

What makes keybindings readable?

Well, check out this (useful!) keybinding:

#+NAME: just-one-space-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (:states 'insert
     "<S-backspace>" #'just-one-space))
#+end_src

See the <S-backspace> mapping? Well, it took me a good while to find the right way to write shift-backspace in the same syntax as the rest of it, and in the process, I happened upon this alternate syntax:

#+NAME: just-one-space-alternate-keybinding
#+begin_src emacs-lisp :tangle no :lexical yes
  (use-package emacs
    :general
    (:states 'insert
     [(shift backspace)] #'just-one-space))
#+end_src

 It's /not/ a short way to write it, but I'm agreeing more and more these days with the idea that short-hands are a real time-saver for when you're entering commands all by yourself (perfect example is installing something globally via ~npm~ with ~npm i -g [package name]~ on your own machine by yourself), but if something's in a document, where someone (even just you several weeks later) needs to read and understand it, it should have the long-hand version—so with the previous example, you'd write the command in a document as ~npm install --global [package name]~.

 So! Maybe this is how these mappings should be written? ~[(control d)]~ instead of ~"C-d"~? Maybe! Bears thinking about, for sure.

*** Which Key

Which key shows you a constantly updating list of what keys you can press next and what commands or menus they'll activate. It's helpful when you can't remember a shortcut, or even just when you want to explore what commands are under a certain menu.

#+NAME: which-key
#+begin_src emacs-lisp :lexical yes
  (use-package which-key
    :diminish 'which-key-mode

    :config
    (which-key-mode)
    (setq which-key-idle-delay 2
          which-key-separator "→"
          which-key-show-operator-state-maps t
          which-key-sort-order #'which-key-prefix-then-key-order
          which-key-show-prefix nil
          which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL")))
#+end_src

** Markup Documents

*** General Markup Settings

Searching a markup outline.

#+NAME: markup-search-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "m." '(consult-outline :which-key "Search markup outline.")))
#+end_src

This is an Org Mode command, but it works everywhere!

#+NAME: markup-repair-numbered-list-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :general
    (leader "ml" '(org-list-repair :which-key "Repair numbered list.")))
#+end_src

*** Emmet Abbreviations

These abbreviations are a great tool for HTML, to the point where they're built into many editors now. But not Emacs, so they're a package.

If you don't know at least the simple Emmet abbreviations, and you write HTML... man, you're missing out. Check out the full docs, but here's [[https://docs.emmet.io/cheat-sheet/][a great Emmet cheat sheet]].

#+NAME: emmet-abbreviations
#+begin_src emacs-lisp :lexical yes
  (use-package emmet-mode
    :ghook
    'sgml-mode-hook
    'css-mode-hook
    'html-mode-hook
    'web-mode-hook

    :init
    (setq emmet-move-cursor-between-quotes t
          emmet-self-closing-tag-style " /"))
#+end_src

*** Org Mode

As Emacs From Scratch put it:

#+BEGIN_QUOTE
[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs. It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.
#+END_QUOTE

**** Install Newest Version

Org is built into Emacs, but you probably want the newest version.

#+NAME: newest-org-mode-version
#+begin_src emacs-lisp :lexical yes
  (use-package org)
#+end_src

**** Basic Setup

#+NAME: org-mode-basic-setup-1
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :init
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-refile-use-outline-path t
          org-link-descriptive nil
          org-startup-folded 'show2levels
          org-refile-targets '((org-agenda-files . (:maxlevel . 6))))

    (defun crj-refile-in-current-buffer ()
      (interactive)
      (let ((org-refile-use-outline-path t)
            (org-refile-targets '((nil . (:maxlevel . 6)))))
        (org-refile))))
#+end_src

**** Keybindings

Let's make Org keybindings a bit better.

***** Org Tasks

Configuring how we manage our tasks using Org Mode.

****** Scheduling

Some Evil keybindings for handling scheduling. Although I got used to the built-in keybindings enough that I may not use these that much!

#+NAME: org-mode-scheduling-keybindings
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :general
    (leader
      "mcs" '(org-schedule :which-key "Add schedule to headline.")
      "mcd" '(org-deadline :which-key "Add deadline to headline.")
      "mct" '(org-timestamp :which-key "Add timestamp to headline.")
      "mck" '(org-timestamp-up :which-key "Increment timestamp portion at point.")
      "mcj" '(org-timestamp-down :which-key "Decrement timestamp portion at point.")
      "mcK" '(org-timestamp-up-day :which-key "Increment timestamp day portion.")
      "mcJ" '(org-timestamp-down-day :which-key "Decrement timestamp day portion.")))
#+end_src

***** Searching Org Documents

The search results for ~consult-org-heading~ are fantastic, as you can search the entire path of headings. So we overwrite the ~consult-outline~ keybinding when we're in Org Mode.

#+NAME: org-mode-headings-search-keybinding
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :general
    (leader "m/" '(consult-org-heading :which-key "Search current headings.")))
#+end_src

**** Org Mode Better Font Faces

The ~efs/org-font-setup~ function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in ~org-mode~. We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+NAME: org-mode-better-font-faces
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :init
    (defun my/buffer-face-mode-variable ()
      "Set font to a variable width (proportional) fonts in current buffer."
      (interactive)
      (setq buffer-face-mode-face '(:family crj--variable-pitch-font
                                    :height 1.0
                                    :width normal))

      (buffer-face-mode))

    (defun my/set-general-faces-org ()
      (my/buffer-face-mode-variable)
      (setq line-spacing 0.1
            org-pretty-entities t
            org-startup-indented t
            org-adapt-indentation nil)
      (variable-pitch-mode +1)
      (diminish 'buffer-face-mode)
      (diminish 'variable-pitch-mode)
      (mapc
       (lambda (face) ;; Other fonts that require it are set to fixed-pitch.
         (set-face-attribute face nil :inherit 'fixed-pitch))
       (list 'org-block
             'org-table
             'org-verbatim
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-date
             'org-drawer
             'org-property-value
             'org-special-keyword
             'org-document-info-keyword))
      (mapc ;; This sets the fonts to a smaller size
       (lambda (face)
         (set-face-attribute face nil :height 0.8))
       (list 'org-document-info-keyword
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-drawer
             'org-property-value
             )))

    (defun efs/org-font-setup ()
      ;; Replace list hyphen with dot
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

      ;; Ensure that anything that should be fixed-pitch in Org files appears that way
      (set-face-attribute 'org-block nil    :foreground nil :font crj--coding-font)
      (set-face-attribute 'org-table nil    :font crj--coding-font)
      (set-face-attribute 'org-formula nil  :font crj--coding-font)
      (set-face-attribute 'org-code nil     :font crj--coding-font)
      (set-face-attribute 'org-table nil    :font crj--coding-font)
      (set-face-attribute 'org-verbatim nil :font crj--coding-font)
      (set-face-attribute 'org-special-keyword nil :font crj--coding-font)
      (set-face-attribute 'org-meta-line nil :font crj--coding-font)
      (set-face-attribute 'org-checkbox nil  :font crj--coding-font))

    (add-hook 'org-mode-hook #'my/set-general-faces-org))

#+end_src

**** Basic Config

Emacs' From Scratch's Commentary (this is one of the areas of my config I have edited but not rewritten):

#+BEGIN_QUOTE
This section contains the basic configuration for ~org-mode~ plus the configuration for Org agendas and capture templates. There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.
#+END_QUOTE

#+NAME: org-mode-basic-setup-2
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :init
    (setq org-link-descriptive nil)

    (defun crj--diminish-org-indent-mode ()
      (diminish 'org-indent-mode))

    (add-hook 'org-indent-mode-hook #'crj--diminish-org-indent-mode)

    (defun efs/org-mode-setup ()
      (org-indent-mode)
      ;; (variable-pitch-mode 1)
      (visual-line-mode 1))

    (add-hook 'org-mode-hook #'efs/org-mode-setup)

    :general
    (:keymaps 'org-mode-map
     :states '(normal insert)
     "M-h" #'org-metaleft
     "M-l" #'org-metaright))
#+end_src

**** Nicer Heading Bullets

Emacs From Scratch's commentary on this:

#+BEGIN_QUOTE
[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in ~org-mode~ buffers with nicer looking characters that you can control. Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.
#+END_QUOTE

#+NAME: org-mode-nicer-bullets
#+begin_src emacs-lisp :lexical yes :tangle no
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src


**** Org Exporting

Org mode can export to other formats—probably its strongest feature.

***** General Settings

Most of this is pretty standard, but I also do have my own CSS to make exporting a little better. It's dead simple, and I'm sure I will change it if I start exporting to HTML more seriously.

#+NAME: org-mode-export-settings
#+begin_src emacs-lisp :lexical yes
  (use-package org
    :init
    (setq org-html-special-string-regexps nil
          org-html-postamble nil
          org-export-with-date nil
          org-export-with-section-numbers nil
          org-export-with-toc nil
          org-export-headline-levels 6
          org-html-head-extra
          "<style>.example::before {content: \"Results:\"; display: block; margin-bottom: 1em;}</style>"))
  #+end_src

***** Org Export to GFM

Org doesn't have at least one format I like using: Github Flavored Markdown. So let's add that with a package.

#+NAME: org-mode-export-gfm
#+begin_src emacs-lisp :lexical yes
  (use-package ox-gfm)
#+end_src

***** Importing Into Org Mode

Org Mode is great at exporting to other formats, but other formats usually don't export to Org. And there's no built-in way to do it, weirdly. So! Package time.

#+NAME: org-mode-import
#+begin_src emacs-lisp :lexical yes
  (use-package org-pandoc-import
    :straight (:host github
               :repo "tecosaur/org-pandoc-import"
               :files ("*.el" "filters" "preprocessors")))
#+end_src

**** Org Code Editing And Evaluation

Literate programming for fun and profit. Or... at least, for fun.

#+NAME: org-mode-code-editing-and-evaluation
#+begin_src emacs-lisp :lexical yes
  (use-package ob-racket
    :straight (:host github :repo "DEADB17/ob-racket"))

  (use-package emacs
    :init
    (general-setq org-confirm-babel-evaluate nil
                  org-src-window-setup 'current-window
                  org-babel-default-header-args:elisp '((:lexical . "yes"))
                  org-edit-src-turn-on-auto-save t
                  org-src-ask-before-returning-to-edit-buffer nil)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       ;; (sql-mode . t)
       (racket . t)
       ;; (python . t)
       ;; (ipython . t)
       ;; (bash . t)
       ;; (sh . t)
       ;; (js . t)
       ;; (javascript . t)
       ;; (sql . t)
       ;; (go . t)
       ))

    :general
    (:keymaps 'org-src-mode-map
     "C-c n" '(org-babel-next-src-block :which-key "Go to next source block.")
     "C-c p" '(org-babel-previous-src-block :which-key "Go to previous source block.")
     "C-c '" '(org-edit-src-exit :which-key "Finish editing source block.")
     "C-c c" '(org-edit-src-exit :which-key "Finish editing source block.")
     "C-c C-c" '(org-edit-src-exit :which-key "Finish editing source block.")
     "C-c k" '(org-edit-src-abort :which-key "Cancel editing source block.")
     "C-c C-k" '(org-edit-src-abort :which-key "Cancel editing source block."))

    ('normal
     :keymaps 'org-mode-map
     "RET" #'org-ctrl-c-ctrl-c)

    ('normal
     :keymaps 'org-mode-map
     :prefix "SPC"
      "c'" #'(org-edit-special :which-key "Edit code block in its major mode."))

    (:keymaps 'org-mode-map
     :states '(normal emacs visual insert motion)
     "C-c C-v k" '(org-babel-remove-result :which-key "Remove results block of current block.")
     "C-c C-v C-k" '(org-babel-remove-result :which-key "Remove results block of current block.")
     "C-c C-v K" '((lambda ()
                     (interactive)
                     (org-babel-remove-result-one-or-many t))
                   :which-key "Remove results block of all blocks.")
     "C-c C-v C-K" '((lambda ()
                       (interactive)
                       (org-babel-remove-result-one-or-many t))
                     :which-key "Remove results block of all blocks.")))
#+end_src

**** Pomodoro Task Management

Pomodoro is a great way to manage your tasks! Or I think it /would/ be if I ever committed to it…

Here's a library that sets pomodoro timers and clocks your time on Org Mode tasks.

#+NAME: org-mode-pomodoro
#+begin_src emacs-lisp :lexical yes
  (use-package org-pomodoro
    :init
    (dolist (player-args-setting '(org-pomodoro-start-sound-args
                                   org-pomodoro-killed-sound-args
                                   org-pomodoro-ticking-sound-args
                                   org-pomodoro-finished-sound-args
                                   org-pomodoro-overtime-sound-args
                                   org-pomodoro-long-break-sound-args
                                   org-pomodoro-short-break-sound-args))
      (set player-args-setting "volume=15000"))

    (setq org-pomodoro-manual-break t
          org-pomodoro-audio-player "/usr/sbin/sox"
          org-pomodoro-keep-killed-pomodoro-time t
          org-pomodoro-format "P%s"
          org-pomodoro-time-format "%m"
          org-pomodoro-long-break-format "L~%s"
          org-pomodoro-short-break-format "S~%s")

    :general
    (leader "mcp" '(org-pomodoro :which-key "Toggle Org Pomodoro time tracking.")))
#+end_src

And another one where you set your own context:

#+begin_src emacs-lisp :lexical no
  (use-package pomm
    :commands (pomm pomm-third-time pomm-mode-line-mode)

    :init
    (pomm-mode-line-mode)
    (general-setq alert-default-style 'libnotify
                  pomm-audio-enabled t
                  pomm-audio-player-executable "/var/sbin/play -v 0.01"
                  pomm-ask-before-work t)

    :general
    (leader "at" '(pomm :which-key "Activate Pomodoro interface.")))
#+end_src

*** Markdown

The not-quite-as-good-as-Org-but-more-universally-spoken markup language.

Now heavily customized!

Let's see if we can hit these quickly. We:

- set ~gfm-mode~ to be the main mode we use for Markdown files.
- set Variable Pitch mode to run in Markdown buffers
- set a bunch of markdown-mode's configuration variables you can check out yourself
- make sure our fonts scale appropriately
- add a command to add a new heading, similar to org mode's approach (should definitely be refactored at some point)
- set my favorite JS mode to run for JS code blocks: RJSX Mode
- allow promotion, demotion, and movement in insert state
- Add ~edit-indirect~, a package that allows you to edit an embedded code block in a dedicated code-oriented buffer in Markdown buffers, which is another, "Oh, cuuuute, it thinks it's Org Mode!" kind of feature.
- Add some Evil keybindings with Evil Markdown Mode.

And we're done at a mere 58 lines of code! (Though... again, I can probably simplify my little custom add-a-heading function.)

#+NAME: markdown-mode
#+begin_src emacs-lisp :lexical yes
  (use-package markdown-mode
    :mode ("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . gfm-mode)

    :gfhook #'variable-pitch-mode

    :init
    (setq markdown-indent-on-enter 'indent-and-new-item
          markdown-list-indent-width 2
          markdown-fontify-code-blocks-natively t
          markdown-asymmetric-header t)

    (defun crj-add-markdown-header ()
      "Add a markdown header after the current one, at the same level."
      (interactive)
      (let ((level (crj--get-markdown-level)))
        (when (thing-at-point-looking-at markdown-regex-header)
          (forward-char))
        (if (re-search-forward markdown-regex-header nil t)
            (forward-line -1)
          (goto-char (point-max)))
        (markdown-insert-header level nil nil))
      (when (featurep 'evil)
        (evil-insert-state)))

    (defun crj--get-markdown-level ()
      "Helper function to get the current markdown heading level.

  Used by `crj-add-markdown-header'"
      (save-excursion
        (unless (thing-at-point-looking-at markdown-regex-header)
          (re-search-backward markdown-regex-header nil t))
        (markdown-outline-level)))

    :config
    (add-to-list 'markdown-code-lang-modes '("javascript" . rjsx-mode))

    :general
    (general-def 'insert markdown-mode-map
      "M-l" #'markdown-demote
      "M-h" #'markdown-promote
      "M-k" #'markdown-move-up
      "M-j" #'markdown-move-down)

    (general-def '(insert normal) markdown-mode-map
      "C-<return>" #'crj-add-markdown-header))

  (use-package edit-indirect)

  (use-package evil-markdown
    :straight (:host github
               :repo "Somelauw/evil-markdown")

    :after markdown-mode

    :ghook ('(markdown-mode-hook gfm-mode-hook))

    :general
    (:keymaps 'evil-markdown-mode-map
     :states '(insert emacs)
     "C-d" nil))
#+end_src

*** HTML

The ugly-but-fully-featured markup language.

#+NAME: html-mode
#+begin_src emacs-lisp :lexical yes
  (use-package web-mode
    :commands (web-mode)

    :mode (("\\.html" . web-mode)
           ("\\.htm" . web-mode)
           ("\\.sgml\\'" . web-mode))

    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-comment-style 2))
#+end_src

*** Info Mode

Info Mode is the special mode Emacs uses for manuals.

Only making one change so far: removing the shadowing of my leader key.

#+NAME: info-mode
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :after evil
    :init
    (define-key Info-mode-map (kbd "SPC") nil)
    (evil-define-key 'normal Info-mode-map (kbd "SPC") nil))
#+end_src

** Evil Mode

Time to spend a vast amount of time thinking through Vim-style keybindings!

*** Transposing Characters

Before we get to the Evil mode setup, this is a small function I wrote to transpose characters with one Vimmish atomic action. It's the first thing here in Evil Mode because, at some point, I want to get into why this is a very Vimmish function, since it might serve as a good introduction to this section.

#+NAME: evil-transpose-chars
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj-evil-transpose-chars ()
      "Transpose characters as one vim-style action.

    Wraps the function `transpose-chars' so that it's more in the style of Evil
    Mode/Vim. (See info node `(evil)Overview')

    - Acts on the current character and the one to the right, which is more in line
    with Vim's Normal Mode style.
    - Adds the entire process as one action, adding undo/repeat ability.

    This differs greatly from the more Emacs-like `transpose-chars', which allows
    you to drag a character forward as far as you want, using a count, but this
    author found that he preferred the atomicity of Normal Mode.

    See `transpose-chars' for more info on the original function."
      (interactive)
      (evil-with-undo
        (forward-char)
        (transpose-chars 1)
        (backward-char 2)))

    :general
    (:keymaps 'normal :prefix "g"
     "b" '(crj-evil-transpose-chars :which-key "Transpose characters.")))

#+end_src

A title-case operator!

#+NAME: evil-title-case-operator
#+begin_src emacs-lisp :lexical yes
  (use-package evil
    :config
    (evil-define-operator evil-title-case (beg end type)
      "Convert text to title case."
      (if (eq type 'block)
          (evil-apply-on-block #'evil-titlecase beg end nil)
        (upcase-initials-region beg end)))

    :general
    (:keymaps 'motion :prefix "g"
     "H" '(evil-title-case :which-key "Title-case operator.")))
#+end_src

*** Evil Mode Setup

There are just a ton of variables here that finely set how Evil Mode is configured. Look at the definition of any of them using ~describe-variable~ to see what they do and what their possible values are!

#+NAME: evil-mode-configuration
#+begin_src emacs-lisp :lexical yes
  (use-package evil
    :init
    (defun crj--escape-plus ()
      (evil-ex-nohighlight))

    (advice-add 'evil-force-normal-state :after #'crj--escape-plus)

    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-ex-search-persistent-highlight t
          evil-ex-substitute-global t
          sentence-end-double-space nil
          evil-want-C-u-scroll t
          evil-want-C-i-jump t
          evil-want-Y-yank-to-eol t
          evil-undo-system 'undo-redo
          evil-want-fine-undo t
          evil-mode-line-format 'nil
          evil-symbol-word-search t
          evil-visual-state-cursor 'hollow
          evil-ex-interactive-search-highlight 'selected-window
          evil-kbd-macro-suppress-motion-error t
          evil-respect-visual-line-mode nil)

    :config
    (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
    (evil-mode 1)
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-define-key '(motion global)
      "j" #'evil-next-line
      "gj" #'evil-next-visual-line
      "k" #'evil-previous-line
      "gk" #'evil-previous-visual-line
      "$" #'evil-end-of-line
      "g$" #'evil-end-of-visual-line)

    (dolist (mode '(custom-mode
                    eshell-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode))

    :bind
    ("C-M-u" . universal-argument))
  #+end_src

**** Evil Collection

This library provides Evil Mode bindings for non-standard buffers, e.g. Magit.

I've reworked some of the ~evil-collection-unimpaired~ bindings to be a bit more mnemonic to me. ~[m~ and ~]m~ move text up and down by lines, while ~[e~ and ~]e~ should navigate to errors. ~[l~ and ~]l~ I will set later to some Lisp manipulation commands.

#+NAME: evil-integration-for-third-party-packages
#+begin_src emacs-lisp :lexical yes
  (use-package evil-collection
    :diminish 'unimpaired
    :diminish 'evil-collection-unimpaired-mode

    :after evil

    :init
    (evil-collection-init)
    (evil-collection-quickrun-setup)

    :general
    (general-unbind '(normal visual motion) evil-collection-unimpaired-mode-map
      "]l"
      "[l"
      "[m"
      "]m"
      "[e"
      "]e")

    (general-def '(normal visual motion) :prefix "["
      "m" '(evil-collection-unimpaired-move-text-up :which-key "Move text up.")
      "e" '(evil-collection-unimpaired-previous-error :which-key "Go to previous error."))
    (general-def '(normal visual motion) :prefix "]"
      "m" '(evil-collection-unimpaired-move-text-down :which-key "Move text down.")
      "e" '(evil-collection-unimpaired-next-error :which-key "Go to next error.")))
    #+end_src

*** Evil Keybindings for Org Mode

This library adds some basic Evil bindings. In addition to the "key themes"" you'll find in [[https://github.com/Somelauw/evil-org-mode/blob/master/doc/keythemes.org][the Evil Org keythemes documentation]], I've included their awesome ~RET~ function, which continues list items and other such, while removing many of the other default keybindings in favor of my own slightly modified versions, such as removing their ~C-S-k~ binding, which I use for ~evil-insert-digraph~, having moved /that/ command's usual binding (~C-k~) to make room for the more Emacsy ~kill-line~.

Also added some good Evil-y movement bindings, as you can see at the bottom.

#+NAME: evil-org-mode-configuration
#+begin_src emacs-lisp :lexical yes
  (use-package evil-org
    :diminish

    :after (evil org)

    :init
    (add-hook 'org-mode-hook #'evil-org-mode)
    (setq org-return-follows-link t
          evil-org-use-additional-insert t)

    :config
    (evil-org-set-key-theme '(textobjects todo additional))
    (evil-define-key '(normal visual insert) 'evil-org-mode
      (kbd "C-S-k") nil
      (kbd "C-S-h") nil)

    :general
    (:keymaps 'org-mode-map
     :states 'insert
     "RET" #'evil-org-return)

    (:keymaps 'org-mode-map :states '(motion normal visual)
     "gl" #'org-down-element
     "gh" #'org-up-element
     "gk" #'org-backward-element
     "gj" #'org-forward-element))
#+end_src

Henrik Lissner's version may have some things I can grab if I want to play with them later. Not using the below block currently.

#+NAME: evil-org-mode-configuration-from-henrik-lissner-currently-disabled
#+begin_src emacs-lisp :lexical yes :tangle no
  (use-package evil-org
    :straight (evil-org-mode :type git :host github :repo "hlissner/evil-org-mode")

    :after org

    :init
    (add-hook 'org-mode-hook 'evil-org-mode)
    (setq org-return-follows-link t
          evil-org-use-additional-insert t)

    :config
    (evil-org-set-key-theme '(navigation insert textobjects additional calendar))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (evil-define-key '(normal visual insert) 'evil-org-mode
      (kbd "C-S-k") nil)

    :general
    (:keymaps 'org-mode-map :states 'insert
     "RET" #'evil-org-return)

    (:keymaps 'org-mode-map :states '(motion normal visual)
     "gl" #'org-down-element
     "gh" #'org-up-element
     "gk" #'org-backward-element
     "gj" #'org-forward-element))
#+end_src

*** Emacs In Vim In Emacs

Bringing back some Emacs commands to use in Insert State.

The short-range, simple Emacs commands are often easier to use when you don't want to switch to Normal State for editing and then back to Insert State to immediately get back to writing. Faster to type ~C-w~ to delete the word you're currently typing and then replace it, rather than ~ESC ciw~. Or, worse, a situation where your editing doesn't bring you back to insert mode in the right place, like when the word /before/ your current word should be deleted—now you're talking about ~ESC bb daw A~ using Vim, but simply ~M-b C-w C-e~ with Vanilla Emacs bindings.

I'm still a /big/ fan of modal editing, since you spend so much time straight up editing, but sometimes, particularly when writing prose, you don't want a minor edit to break your flow.

[[./assets/funky-flow.gif]]

Also included in generally surfacing more Emacsy insert-state commands:
- some readline commands that aren't in actual Emacs, like ~kill-line~ and ~backwards-kill-sentence~ and (sometimes excluded) ~backward-kill-word~.
- ~zap-up-to-char~, the Emacsy equivalent of Evil's ~dt[char]~, is not currently keybound. (~zap-to-char~, Emacs' ~df[char]~, has a keybinding already.)
- Backwards versions of those two zaps. I don't /love/ Emacs' way of doing this, which would be to use Control-dash to give the function a negative number, /then/ ~M-z~ to run the command. I'd rather just wrap the command, passing in a negative number, then set that to ~M-Z~.

#+NAME: emacs-in-vim-in-emacs
#+begin_src emacs-lisp :lexical yes
  (use-package evil
    :init
    (defun crj-zap-to-char-backwards (arg char)
      "A wrapped version of `zap-to-char' that goes backwards.

  Kill up to and including ARGth occurrence of CHAR, backwards.
  Case is ignored if `case-fold-search' is non-nil in the current buffer.
  See also `zap-up-to-char' and the wrapped `crj-zap-up-to-char-backwards'."
      (interactive (list (prefix-numeric-value current-prefix-arg)
                         (read-char-from-minibuffer "Zap back to char: "
                                                    nil 'read-char-history)))
      (zap-to-char (- arg) char))

    (defun crj-zap-up-to-char-backwards (arg char)
      "A wrapped version of `zap-up-to-char' that goes backwards.

  Kill up to, but not including ARGth occurrence of CHAR, backwards.

  Case is ignored if case-fold-search is non-nil in the current buffer.
  Goes backward if ARG is negative; error if CHAR not found.
  Ignores CHAR at point.

  See also `zap-to-char' and the wrapped `crj-zap-to-char-backwards'."
      (interactive (list (prefix-numeric-value current-prefix-arg)
                         (read-char-from-minibuffer "Zap back up to char: "
                                                    nil 'read-char-history)))
      (zap-up-to-char (- arg) char))

    :general
    (general-def global-map
      "C-h" #'backward-delete-char
      "C-u" #'evil-delete-back-to-indentation
      "C-w" #'evil-delete-backward-word)

    (:states '(insert emacs)
     "C-n" #'next-line
     "C-p" #'previous-line
     "C-e" #'end-of-visual-line
     "C-a" #'beginning-of-visual-line
     "C-d" #'delete-forward-char
     "C-S-k" #'evil-insert-digraph
     "C-k" #'evil-delete-line
     "C-u" #'evil-delete-back-to-indentation
     "C-w" #'evil-delete-backward-word
     "M-t" #'zap-up-to-char
     "M-Z" #'crj-zap-to-char-backwards
     "M-T" #'crj-zap-up-to-char-backwards))
#+end_src

*** Visualizing Evil Commands

~evil-goggles~ helps you to visualize the text object you just worked on. Particularly useful for Evil yanks.

#+NAME: evil-command-quick-visualization
#+begin_src emacs-lisp :lexical yes
  (use-package evil-goggles
    :diminish 'evil-goggles-mode

    :after evil

    :init
    (setq evil-goggles-duration 0.3
          evil-goggles-pulse nil
          evil-goggles-enable-delete nil
          evil-goggles-enable-change nil)

    :config
    (evil-goggles-mode))
#+end_src

*** Working With Surrounding Text In Evil

This library is amazing for working with surrounding text. Changing double quotes to single, parens to square brackets, etc., and also wrapping and unwrapping: surround this line with square brackets, surround the surrounding curly brackets with parens, delete the surrounding curly brackets, and so on. Huge efficiency saver.

#+NAME: working-with-surrounding-text-in-evil
#+begin_src emacs-lisp :lexical yes
  (use-package evil-surround
    :after evil

    :config
    (global-evil-surround-mode 1))
#+end_src

*** Evil-Style Commenting

Really really great way to handle comments.

#+NAME: evil-style-commenting
#+begin_src emacs-lisp :lexical yes
  (use-package evil-nerd-commenter
    :after evil

    :general
    ([remap comment-line] #'evilnc-comment-or-uncomment-lines)
    (:keymaps 'normal :prefix "g"
     "c" '(evilnc-comment-operator :which-key "Toggle comment.")
     "C" '(evilnc-copy-and-comment-operator :which-key "Copy and comment.")
     "K" '(evilnc-comment-box :which-key "Create comment box."))

    (general-def 'normal evil-inner-text-objects-map
      "c" #'evilnc-inner-comment)
    (general-def 'normal evil-outer-text-objects-map
      "c" #'evilnc-outer-comment))
#+end_src

*** Replace With Clipboard In Evil

This is an invaluable command, especially since it's a motion I can combine with a text object.

Being able to type ~SPC r i )~ to say "replace what's in these parens with what I just copied to the kill ring" is amazingly efficient text editing.

#+NAME: replace-with-clipboard-in-evil
#+begin_src emacs-lisp :lexical yes
  (use-package evil-replace-with-register
    :after evil

    :general
    (leader "r" '(evil-replace-with-register :which-key "Replace text with register.")))
#+end_src

*** Evil Motion For Exchanging Text

Another efficient text editing library. This one exchanges two bits of text in an extremely Evilly way.

#+NAME: evil-motion-for-exchanging-text
#+begin_src emacs-lisp :lexical yes
  (use-package evil-exchange
    :after evil

    :general
    (:states '(normal visual)
     "gx" '(evil-exchange :which-key "Exchange text objects.")))
#+end_src

*** Evil Word Wackiness
I think I have a lot more to write here about how weird Evil's word motions are. We don't use them as often as other text objects, but while they're basic, I think the reason we avoid them is that there are some serious flaws in their design. Like I said, I'll write some more on them, for sure.

In the meantime, here are some fixes!

**** First, A Basic Fix

Little words should include word "parts" in camelCase words, whether you're using Evil or not. This is a fix for that.

#+NAME: subwords-as-words
#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :diminish 'subword-mode

    :init
    (global-subword-mode))
#+end_src

**** Quick Word Deletion

Some surprisingly useful motions I wrote one evening. They're like Evil's `x` and `X`, but for words!

Variations on these also come in handy quite often in Lisps (for which there are symex-oriented versions somewhere below).

I'm binding them to ~v~ and ~V~, which is super weird I know, but I—and many other long-time Vim/Evil users—don't use the visual modes very often. (And I placed them far away on a distant binding for the rare times I do need them.)

#+NAME: quick-word-deletion
#+begin_src emacs-lisp :lexical yes
  (use-package evil
    :init
    (defun crj-delete-current-word ()
      "Delete current word.

  It's `evil-delete-char', but for words!

  This one's a bit hacky and probably has a ton of edge cases—most obviously,
  this won't work if it's the last word in the document.

  At some point I'll see if the edge cases ever really come up, in which case
  this will get refactored."
      (interactive)
      (evil-forward-word-begin)
      (crj-delete-previous-word))

    (defun crj-delete-previous-word ()
      "Delete previous word.

  It's `evil-delete-backward-char', but for words!"
      (interactive)
      (when (crj--point-is-past-start-of-thing-p 'word)
        (evil-backward-word-begin))
      (evil-delete-backward-word))

    (defun crj--point-is-past-start-of-thing-p (thing)
      "Returns whether point is past start of THING.

  For what THING can be, see `thing-at-point'.

  This function answers the age-old question:

  \"Was I just in the middle of something?\""
      (not (eq (point) (car (bounds-of-thing-at-point thing)))))

    :general
    (:states 'normal
      "v"  #'crj-delete-current-word
      "V" #'crj-delete-previous-word)

    (leader
      "tv" '(evil-visual-char :which-key "Evil visual state.")
      "tV" '(evil-visual-line :which-key "Evil visual line state.")))
#+end_src

**** Better Word Movement

For reasons I'll go into someday, these ~evil-cleverparens~ word motions are just closer to what you mean when you think of a word than Evil's/Vim's built-in ones.

Additionally, I'm binding the rarely-used ~H~ and ~L~ keys as additional forward/backward word motions, because they're somewhat in my muscle memory from the Lisp keybindings I currently use.

#+NAME: better-word-movement
#+begin_src emacs-lisp :lexical yes
  (use-package evil-cleverparens
    :general
    (:states 'normal
      "W" #'evil-cp-forward-symbol-begin
      "B" #'evil-cp-backward-symbol-begin
      "L" #'evil-cp-forward-symbol-begin
      "H" #'evil-cp-backward-symbol-begin
      "E" #'evil-cp-forward-symbol-end
      "gE" #'evil-cp-backward-symbol-end))
#+end_src

*** Evil Jump-To-Matching For Opening And Closing Delimiters

Normally, Evil jumps between brackets with ~%~. Here's one library for opening that up to things like ~if~ and ~else~ and HTML opening/closing tags and anything else you can imagine/configure.

#+NAME: matching-more-delimiters
#+begin_src emacs-lisp :lexical yes
  (use-package evil-matchit
    :init
    (global-evil-matchit-mode 1))
#+end_src

*** Evil Text Objects

Text Objects are a powerful concept in Vim/Evil. Let's add our own!

**** HTML Attribute Evil Text Object

This package gives you an Evil text object for XML/HTML attributes. It's helpful!

#+NAME: evil-text-object-for-html-attributes
#+begin_src emacs-lisp :lexical yes
  (use-package exato
    :commands (evil-outer-xml-attr evil-inner-xml-attr))
#+end_src

**** Evil Argument Text Object

#+NAME: evil-text-object-for-arguments
#+begin_src emacs-lisp :lexical yes
  (use-package evil-args
    :general
    (general-def evil-inner-text-objects-map
      "a" 'evil-inner-arg)
    (general-def evil-outer-text-objects-map
      "a" 'evil-outer-arg))
#+end_src

**** Entire Buffer Evil Text Object

A surprisingly useful Evil text object for the entire buffer.

#+NAME: evil-text-object-for-entire-buffer
#+begin_src emacs-lisp :lexical yes
  (use-package evil-textobj-entire
    :after evil

    :straight (evil-textobj-entire
               :host github
               :repo "nscoder/evil-textobj-entire"))
#+end_src

**** Between Characters Text Object

I'm pretty sure I'm going to find a use for this!

#+begin_src emacs-lisp :lexical yes
  (use-package evil-textobj-between
    :straight (:host github
               :repo "tarao/evil-plugins"
               :files ("evil-textobj-between.el"))

    :custom
    (evil-textobj-between-a-key "t")
    (evil-textobj-between-i-key "t"))
#+end_src

**** Evil Text Object For A Line

This is a weird one, since Evil is /designed/ to work with lines—it's one of its central ways to work, to the point where repeating an operator like ~d~ or ~c~ or many third-party operators defaults to acting on the line.

Making it an official text object with an inner variant does, however, allow you to work on the /text/ of the line without any indentation or trailing whitespace.

And if you want the indentation or trailing whitespace, you can work with the outer variant. Or, again, just the standard work-on-a-line-by-default version of any command!

#+begin_src emacs-lisp :lexical yes
  (use-package evil-textobj-line
    :init
    (setq evil-textobj-line-a-key "L"
          evil-textobj-line-i-key "L"))
#+end_src

*** Evil Search From Visual Mode

Allows you to select some text in Visual State and then hit ~*~ or ~#~ to search for that text. Very occasionally very useful!

#+begin_src emacs-lisp :lexical yes
  (use-package evil-visualstar
    :after evil

    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backward)

    :init
    (global-evil-visualstar-mode))
#+end_src

*** Evil Motion For Diffing Text

Shows you the difference between two different bits of text. Another very occasionally very useful trick.

#+begin_src emacs-lisp :lexical yes
  (use-package evil-quick-diff
    :after evil

    :init (evil-quick-diff-install)

    :straight (evil-quick-diff
               :type git
               :repo "https://github.com/rgrinberg/evil-quick-diff")

    :commands (evil-quick-diff evil-quick-diff-cancel))
#+end_src

*** Evil Evaluating

#+begin_src emacs-lisp :lexical yes
  (use-package evil-extra-operator
    :general
    (leader
      "e" #'(evil-operator-eval :which-key "Evaluate operator.")
      "E" #'(evil-operator-eval-replace :which-key "Evaluate and replace operator.")
      "C" #'(evil-operator-clone :which-key "Clone operator.")))
#+end_src

*** Number Incrementing and Decrementing

#+begin_src emacs-lisp :lexical yes
  (use-package evil-numbers
    :general
    (:keymaps 'normal :prefix "g"
     "=" '(evil-numbers/inc-at-pt :which-key "Increment operator.")
     "-" '(evil-numbers/dec-at-pt :which-key "Decrement operator."))
    (:keymaps 'visual :prefix "g"
     "=" '(evil-numbers/inc-at-pt-incremental :which-key "Increment operator.")
     "-" '(evil-numbers/dec-at-pt-incremental :which-key "Decrement operator.")))
#+end_src

** Search

Searching is something Emacs does very, /very/ well.

We'll use various ~consult~ commands to search through different sets of data.

We'll also use a custom command for searching text in project files, though it's got a TODO to make it worth having the custom command at all. Consider it a placeholder for now, until such sanity checks are more of a priority.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj-search-project (&optional dir initial)
      "Search through text in project files.

  Searches with rg for files in DIR with INITIAL input.

  TODO add check for presence of ripgrep binary, falling back to grep."

      (interactive "P")
      (consult-ripgrep dir initial))

    :general
    (leader
      "sp" '(crj-search-project :which-key "Search text in project files.")
      "sd" '(consult-find :which-key "Search file names in directory.")
      "sm" '(consult-mark :which-key "Search the marks list.")
      "se" '(consult-flymake :which-key "Search through errors.")
      "sb" '(consult-bookmark :which-key "Search through bookmarks list.")
      "ss" '(consult-xref :which-key "Search symbols in project.")
      "sr" '(consult-register-load :which-key "Search registers (Evil clipboard).")
      "sy" '(consult-yank-from-kill-ring :which-key "Search kill ring (Emacs clipboard).")
      "sn" '(consult-goto-line :which-key "Search line numbers.")))
#+end_src

And finally, since I do this search so often, it's got a quicker shortcut of ~SPC SPC~.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "SPC" '(project-find-file :which-key "Find file within current project.")))
#+end_src

*** Editing Results

We can edit filtered results live with wgrep.

#+begin_src emacs-lisp :lexical yes
  (use-package wgrep
    :commands wgrep-change-to-wgrep-mode

    :config (setq wgrep-auto-save-buffer t)

    :general
    (general-def grep-mode-map
      "C-c C-e" '(wgrep-change-to-wgrep-mode :which-key "Switch to writable search results.")))

  (use-package emacs
    :init
    (defun crj-vertico-embark-export-write ()
      "Export the current vertico results to a writable buffer if possible.

  Supports exporting consult-grep to wgrep, file to wdired, and consult-location to occur-edit.

  Credit to Doom Emacs."
      (interactive)
      (require 'embark)
      (require 'wgrep)
      (let* ((edit-command
              (pcase-let ((`(,type . ,candidates)
                           (run-hook-with-args-until-success 'embark-candidate-collectors)))
                (pcase type
                  ('consult-grep #'wgrep-change-to-wgrep-mode)
                  ('file #'wdired-change-to-wdired-mode)
                  ('consult-location #'occur-edit-mode)
                  (x (user-error "embark category %S doesn't support writable export" x)))))
             (embark-after-export-hook `(,@embark-after-export-hook ,edit-command)))
        (embark-export)))

    :general
    (general-def minibuffer-local-map
      "C-c C-e" '(crj-vertico-embark-export-write :which-key "Switch to writable search results."))
    (general-def dired-mode-map
      "C-c C-e" '(wdired-change-to-wdired-mode :which-key "Switch to writable search results.")))
#+end_src

** Look and Feel

*** Basic UI Configuration

These are some sane defaults for the UI.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :diminish 'visual-line-mode

    :init
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (menu-bar-mode -1)
    (global-visual-line-mode 1)
    (set-fringe-mode 10)
    (setq inhibit-startup-message t
          visible-bell t))
#+end_src

If you're just getting started in Emacs, the menu bar might be helpful so you can remove the ~(menu-bar-mode -1)~ line if you'd like to discover common commands. However, in terms of discovering things in Emacs, there are much better ways to do it, such as the ~describe~ functions, ~which-key~, and, when you et there, reading source code. The single best thing about Emacs is how completely effortless it is to peek at the source code for almost every single thing you can do here. Learn how to dive as far as you want into how something works, and you'll be able to grow in your knowledge at your own learning pace, whether it's slow and steady or voracious.

*** File Management

There will be more here someday, but for now, I got annoyed enough at the process for editing a file with elevated permissions needed, so:

#+begin_src emacs-lisp :lexical yes
  (use-package sudo-edit
    :general
    (leader "fu" '(sudo-edit :which-key "Edit current file with sudo.")))
#+end_src

*** Fonts

First, some definitions of the fonts I use. For Emacs in code, eventually, and for you—and future me!—in this document.

My overly arcane setup includes /three/ fonts, all /very/ different in their style and usage.

The font I see in Emacs as I write this text looks like this:

[[./assets/variable-pitch.png]]

That font is IBM Plex Serif, which is a standard-style variable-pitch serif font. It's "serif" because it's /fancy/. If you look close, you can see that some of the letters have extra little curly bits, called serifs—look at the capital "T" in the "The quick brown fox" line for an example. And, most relevantly, it's a "variable-pitch" font, which means that the characters vary in pitch (a.k.a. width). This is easiest to see in the "nnnnn" and "mmmmm" lines: the "n" line is much shorter than the "m" line because the latter character is wider than the former. This type of font is perfect for writing prose, where the letters are given the breathing room we're used to seeing them in.

In my Emacs setup, this font is /only/ used in text and markup documents like Org Mode and Markdown, where I'm doing lots of classic writing and reading.

The second font I use is Hack, which is a "fixed pitch" font—more often called a "monospace" font. Here is a similar font in a terminal:

[[./assets/fixed-pitch.png]]

Most people use a fixed-pitch font for code for several reasons, but we'll get to those in a second. The main feature of a fixed-pitch font is that the width doesn't vary. You'll notice in the sample above that the "nnnnn" and "mmmmm" lines are the same length. Having all characters be the exact same width makes alignment easier, which many developers use to keep similar columns of code lined up just so.

The last font is Input, which is another variable pitch font, but one that's very, very different than most. You can see it in the Emacs terminal pictured below:

[[./assets/variable-pitch-coding-font.png]]

If you look closely at Input, it's variable-pitch, no question. The "mmmmm" line is longer than the "nnnnn" line, and the characters are generally less squished-in. Since developers swear by fixed-pitch coding fonts, no respected developer would use this font as a coding font.

I am not a respected developer.

I use Input for coding because when I head about a minority of developers using a variable pitch font for coding, I read up on it, and the few articles I read in defense of it were pretty convincing.

See, many developers will tell you that the big difference between the two types of fonts, besides alignment, is that a variable-pitch font doesn't give enough space to coding symbols like parentheses and curly brackets and ~!~ and ~:~ and ~/~, characters that a fixed-pitch font gives equal width to (because fixed-pitch fonts give /everything/ the same length) And it's true that if I try to write code in my prose font (see first sample!), it's much harder to make out the important-to-code characters.

But variable-pitch fonts don't /have/ to give coding symbols short shrift. Look at the Input sample above—the coding characters are given plenty of width! You see, fixed-pitch fonts give everything the same width, whether it's a ~!~ or an ~n~ or an ~m~. In that way, they're making the decision that every character is equally important and needs the same amount of width. It's a shortcut solution, treating all characters the same to give coding characters with the space they need, but it's not making an actual /decision/ as to what to prioritize.

Coding fonts should prioritize code symbols, and prose fonts should prioritize letters more. But /why not both/.

[[./assets/why-not-both.gif]]

Why not a font that gives code symbols plenty of space to make them properly stand out for their syntactic meaning, without bizarrely deciding that alignment is more important than letter readability? Why not a font that makes /everything/ readable? When your wide letters like "m" and "w" and "c" are squished in while skinny letters like "t" and "l" and "i" are weirdly widened, what you get is a one-size-fits-all approach that prioritizes... nothing in particular. Except trying not to deprioritize anything.

When reading and writing, priorities matter. You want symbols to be readable, because you /definitely/ don't want to miss them as you're reading the code, but you /also/ want to be able to read those function and variable names. A variable-pitch font designed carefully to create a great coding experience unsurprisingly beats a font that is designed simply /not/ to deprioritize symbols.

There's actually even more to say about this than I thought going in, but I'll leave it here for now.

So how do I use these fonts? Well, I still do use my fixed-pitch Hack font for a few places, where alignment can super matter. For files where the columns matter, like spreadsheets and tables, I still use them. I also use them for line numbers, so as to keep the left margin aligned. Otherwise, though, it's Input for coding, and IBM Plex Mono (my variable-pitch serif font) for writing.

Final thing before I get to the code: yes, this is a lot of work for fonts. And I'm not even a font expert! I /do/ think readability matters quite a great deal. But I think there are two related elements of my character that have lead me down this path.

The desire to make my system my own. To craft an app I can live in every day, that I can not only code in but write emails in and use to check the weather and browse the web and manage my local files and manage my cloud files and write blog posts and chat with friends and organize my life, and to /keep/ crafting that personalized app, spending a fair amount of my valuable time making the rest of my work time fun enough to get me through the day.

But the other, and related reason, is that everyone likes to be a little different and weird and have opinions that make you feel smart, even if the end result is just that you have a bizarre font choice that on-lookers likely won't even notice.

The desire to be just a bit of an iconoclast.

[[./assets/iconoclast.gif]]

It's important to make fun of yourself for doing so, but that doesn't change the fact that it feels /good/ to be that weird guy who always wears hats or learned Esperanto or decided Vim was somehow /too mainstream/.

That guy's me, and you're welcome, and I'm sorry.

Here are my font settings.

#+begin_src emacs-lisp :lexical yes
  (defvar crj--fixed-pitch-font "Hack")
  (defvar crj--variable-pitch-coding-font "Input")
  (defvar crj--variable-pitch-font "IBM Plex Serif")
  (defvar crj--coding-font crj--variable-pitch-coding-font)
  (defvar crj--emoji-font "Noto Color Emoji")
  (defvar crj--default-font-size 110)

  (use-package emacs
    :config
    (when (member "Noto Color Emoji" (font-family-list))
      (set-fontset-font
       "fontset-default" 'unicode
       (font-spec :family "Noto Color Emoji")
       nil
       'prepend))

    (set-face-attribute 'default nil
                        :font crj--coding-font
                        :height crj--default-font-size)

    (set-face-attribute 'fixed-pitch nil
                        :font crj--coding-font
                        :height 1.0)

    (set-face-attribute 'variable-pitch nil
                        :font crj--variable-pitch-font
                        :height 1.0
                        :weight 'regular))
#+end_src

And a picture of what my setup actually looks like:

[[./assets/font-setup-screenshot.png]]

**** Using Fixed Pitch In Some Buffers

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defface crj--monospace
      '((t
         :family "Hack"
         :foundry unspecified
         :width normal
         :height 1.0
         :weight normal
         :slant normal
         :foreground "#505050"
         :distantForeground unspecified
         :background "#f8f8f8"
         :underline nil
         :overline nil
         :strike-through nil
         :box nil
         :inverse nil
         :stipple nil
         :font "Hack"
         :fontset unspecified
         :extend nil))

      "Face for monospace fonts.")

    (defun crj--use-fixed-pitch ()
      "Make the current buffer use a fixed pitch.

  Sometimes I really do want fixed-pitch for alignment, such as with terminals."
      (interactive)
      (set (make-local-variable 'buffer-face-mode-face) 'crj--monospace)
      (buffer-face-mode t))

    ;; Hooks for modes I want to use fixed pitch in.
    (setq crj--fixed-pitch-mode-hooks
          '(vterm-mode-hook
            calendar-mode-hook
            proced-mode-hook
            cfw:calendar-mode-hook
            minibuffer-setup-hook
            mu4e-headers-mode-hook
            magit-log-mode-hook))

    ;; Add the fixed-pitch function for each mode.
    (dolist (hook crj--fixed-pitch-mode-hooks)
      (add-hook hook #'crj--use-fixed-pitch)))
#+end_src

*** Whitespace

Let's visualize it in prog mode so we get rid of it.

(But please remember to keep whitespace removal its own separate commit so as not to pollute your diffs.)

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj--show-trailing-whitespace () (setq show-trailing-whitespace t))

    (add-hook 'prog-mode-hook #'crj--show-trailing-whitespace))
#+end_src

*** Zooming Text

Zooming in and out in Emacs is... tricky. Part of this is because fonts in general are tricky! And part of it is that Emacs gives you so much control over your fonts that there are a /lot/ of moving parts, making it trickier still. And the last part is that Emacs' font system is hugely unintuitive.

Still, I've got a /pretty/ good system for zooming fonts up and down, here. It's split into zooming per-buffer and zooming globally, depending on your needs. It's easy to zoom more or less for fine-grained refinement, while also being easy to zoom by huge amounts in one go with a count.

There are some edge cases here, though, so I'll probably be returning to it.

First, some functions to zoom and reset one buffer:

#+begin_src emacs-lisp :lexical yes
  (defun crj-zoom-in (arg)
    "Incease text size in current buffer.

  ARG is a count—increase the count to zoom in more."
    (interactive "p")
    (text-scale-increase arg))

  (defun crj-zoom-out (arg)
    "Decrease text size in current buffer.

  ARG is a count—increase the count to zoom out more."
    (interactive "p")
    (text-scale-increase (* arg -1)))

  (defun crj-zoom-reset ()
    "Reset current buffer's text size to default."
    (interactive)
    (text-scale-increase 0))
#+end_src

From there, I can use those to zoom in on all current buffers. These functions simply loop through all the buffers in the ~buffer-list~ and run the above functions in each.

#+begin_src emacs-lisp :lexical yes
  ;; I will add these eventually if I work further on the current-zoom-level-as-a-global-variable idea.
  ;; (defvar current-text-scale 0)
  ;; (defun crj-match-new-buffer-to-current-text-scale ()
  ;;   (interactive)
  ;;   (text-scale-increase 0)
  ;;   (text-scale-increase text-scale-mode-amount))
  ;; (add-hook 'after-set-visited-file-name-hook #'crj-match-new-buffer-to-current-text-scale)

  (defun crj-zoom-in-all-buffers (arg)
    "Zooms in on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-in arg))))

  (defun crj-zoom-out-all-buffers (arg)
    "Zooms out on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-out arg))))

  (defun crj-zoom-reset-all-buffers ()
    "Resets zoom for all current buffers to default level."
    (interactive)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj-zoom-reset))))
#+end_src

This package, ~default-text-scale~, can handle things more robustly than the homegrown situation above, in that it change the font size for other existing "frames" (what every other program would call a window), and for new frames moving forward.

I'm not using it, but it's worth exploring at some point.

#+begin_src emacs-lisp :tangle no :lexical yes
  (use-package default-text-scale
    :init (default-text-scale-mode))
#+end_src

But since their solution causes the default font size to reset, along with every font that inherits from it, every time it hits a font size for the first time in an Emacs session, there's a slowdown where the screen goes blank for a jarring second. (Possibly exacerbated by how many disparate fonts I have going on—see the Fonts section below.) It also doesn't have the ability to take a count, though there's probably a way to wrap the functions to make that happen.

All of this is to say that the many many different ways you can manipulate and work with multiple fonts in Emacs, across as many frames and buffers and windows as you've got open, makes zooming a bit of a complex mess. ~default-text-scale~ is the most powerful system I've seen for it, but... although external libraries by accomplished Emacs Lisp programmers are almost always better than what an okay-ish programmer like me can do, I think I'm going to stick with my simple and flexible system this time.

Next, we make some keybindings for them.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader
      "zj" '(crj-zoom-in-all-buffers :which-key "Zoom in globally.")
      "zk" '(crj-zoom-out-all-buffers :which-key "Zoom out globally.")
      "zb" '(crj-zoom-reset-all-buffers :which-key "Reset zoom globally.")
      "zJ" '(crj-zoom-in :which-key "Zoom in.")
      "zK" '(crj-zoom-out :which-key "Zoom out.")
      "zB" '(crj-zoom-reset :which-key "Reset zoom.")))
#+end_src

And finally, there's a special type of Emacs interface I don't use often, a third-party package called Hydra, that's perfect for an activity like zooming text. Once you've decided to zoom, you're entering a kind of session where you'll be entering related commands. You'll be zooming in a couple times, then zooming out if you've gone too far. And at that point that can even repeat, if you change your mind as to what zoom level you act~ally want. What Hydra does is enter an interface perfect for this kind of situation.

With the below code, the user (almost definitely me!) can type ~SPC z z~, at which point, instead of entering complex keybindings, they can type ~j~ to zoom in, ~k~ to zoom out (these are meaningful letters to Vim users), do that as much as they want, and then get back to what they were doing by pressing ~escape~ or any other key that's not part of this system.

There are other, similar libraries (I've heard Transient is even better), but I highly recommend an interface like this. It's fantastic.

We'll install Hydra, define its interface, and then put that hydra command in our keybindings.

#+begin_src emacs-lisp :lexical yes
  (use-package hydra
    :config
    (defhydra crj-hydra/text-zoom (:hint nil :color red)
      "
        Global zoom: _j_:zoom in, _k_:zoom out, _b_:reset
        Buffer zoom: _J_:zoom in, _K_:zoom out, _B_:reset
  "
      ("J" crj-zoom-in)
      ("K" crj-zoom-out)
      ("B" crj-zoom-reset)
      ("j" crj-zoom-in-all-buffers)
      ("k" crj-zoom-out-all-buffers)
      ("b" crj-zoom-reset-all-buffers))

    :general
    (leader "zz" '(crj-hydra/text-zoom/body :which-key "Zoom hydra interface.")))
#+end_src

*** Scrolling

This package makes scrolling big distances easier to follow by flashing the new line you've moved to.

#+begin_src emacs-lisp :lexical yes
  (use-package pulsar
    :init
    (setq pulsar-pulse t)
    (setq pulsar-delay .01)
    (setq pulsar-iterations 30)
    (setq pulsar-face 'pulsar-generic)
    :config
    (setq crj--far-jumping-functions '(evil-scroll-up
                                       evil-scroll-down
                                       evil-goto-line
                                       evil-beginend-prog-mode-goto-beginning
                                       evil-beginend-prog-mode-goto-end
                                       evil-beginend-org-mode-goto-beginning
                                       evil-beginend-org-mode-goto-end
                                       evil-beginend-dired-mode-goto-beginning
                                       evil-beginend-dired-mode-goto-end
                                       evil-beginend-message-mode-goto-beginning
                                       evil-beginend-message-mode-goto-end
                                       evil-beginend-org-agenda-mode-goto-beginning
                                       evil-beginend-org-agenda-mode-goto-end
                                       evil-beginend-compilation-mode-goto-beginning
                                       evil-beginend-compilation-mode-goto-end
                                       evil-beginend-magit-status-mode-goto-beginning
                                       evil-beginend-magit-status-mode-goto-end
                                       evil-beginend-magit-revision-mode-goto-beginning
                                       evil-beginend-magit-revision-mode-goto-end
                                       evil-goto-first-line
                                       evil-goto-mark-line
                                       evil-scroll-page-up
                                       evil-scroll-page-down
                                       bury-buffer
                                       kill-buffer
                                       crj--toggle-presentation-mode
                                       delete-other-windows
                                       winner-undo
                                       evil-window-up
                                       evil-window-down
                                       evil-window-left
                                       evil-window-right
                                       evil-window-new
                                       evil-window-vnew))

    (dolist (function crj--far-jumping-functions)
      (add-to-list 'pulsar-pulse-functions function))

    (pulsar-global-mode 1))
#+end_src

*** Line Numbers

**** Basic Line Number Settings

Sets up line numbers to be (almost) everywhere, just not in some terminal modes.

I like to use relative line numbers, since they make line-wise work easier when using Evil Mode. Which I do.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq display-line-numbers-type 'relative
          magit-disable-line-numbers nil
          magit-section-disable-line-numbers nil)

    (global-display-line-numbers-mode t)

    (defun crj--turn-off-line-numbers ()
      (display-line-numbers-mode 0))

    (defconst crj--hooks-for-modes-without-line-numbers '(term-mode-hook
                                                          vterm-mode-hook
                                                          shell-mode-hook
                                                          treemacs-mode-hook
                                                          eshell-mode-hook))

    (dolist (hook crj--hooks-for-modes-without-line-numbers)
      (add-hook hook #'crj--turn-off-line-numbers)))
#+end_src

**** Make Line Numbers Use Fixed Pitch

This next part is for making line numbers use a fixed pitch font. I like a variable pitch coding font, but line numbers get janky if they're not fixed pitch.

And by setting line numbers to an absolute size, we also avoid having them increase in size with everything else. Ideally I would increase their size too when zooming, just at a lesser rate. But this is good enough for now.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq crj--line-number-faces '(line-number
                                   line-number-current-line
                                   line-number-major-tick
                                   line-number-minor-tick))

    (defun crj-make-line-number-face-monospace (&rest args)
      "Makes line numbers monospace and fixes them in size."
      (interactive)
      (dolist (face crj--line-number-faces)
        (set-face-attribute face nil
                            :family crj--fixed-pitch-font
                            :height 1.0))
      args)

    (add-hook 'emacs-startup-hook #'crj-make-line-number-face-monospace))
#+end_src

**** Cycle Line Numbers

When displaying code to others, it's often good to make the line numbers absolute. And hiding them can be nice sometimes, though if I'm doing that often, I should consider whether there are more modes I should turn line numbers off for.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj-cycle-line-numbers ()
      (interactive)
      (crj-cycle-setting 'display-line-numbers '(relative t nil)))

    :general
    (leader "tl" '(crj-cycle-line-numbers :which-key "Cycle line numbers globally.")))
#+end_src

*** Indentation

**** Spaces Over Tabs

The eternal struggle.

(I'm referring of course to both the struggle between the two sides and the struggle between the user and Emacs.)

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq-default indent-tabs-mode nil))
#+end_src

**** General Indentation

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq-default standard-indent 2
                  sh-basic-offset 2
                  tab-width 2))
#+end_src

**** Visualize Indentation Level

Let's visualize our indentation!

#+begin_src emacs-lisp :lexical yes
  (use-package highlight-indent-guides
    :diminish 'highlight-indent-guides-mode

    :ghook 'prog-mode-hook

    :custom
    (highlight-indent-guides-method 'bitmap))
#+end_src

*** Folding

Folding code is sometimes useful. Lots of people swear by it!

#+begin_src emacs-lisp :lexical yes
  (use-package fold-this)

  (use-package evil-extra-operator
    :after fold-this

    :general
    ('normal
     "gs" #'(evil-operator-fold :which-key "Fold operator.")
     "gS" #'(fold-this-unfold-all :which-key "Unfold all folds.")))
#+end_src

*** Don't Show Me Bookmarks

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq bookmark-set-fringe-mark nil))

#+end_src

** Applications

This section is for parts of Emacs that are well-integrated applications.

*** Internet Radio with Eradio

I love this no-hassle don't-have-to-think-about-what-to-listen-to background music. I need need /need/ music to focus.

#+begin_src emacs-lisp :lexical yes
  (use-package eradio
    :init
    (setq eradio-channels '(("SomaFM - Fluid" . "https://somafm.com/fluid.pls")
                            ("LO FLY Radio" . "http://64.20.39.8:8421/listen.pls?sid=1&t=.pls")
                            ("SomaFM - Groove Salad." . "https://somafm.com/groovesalad.pls")
                            ("SomaFM - Secret Agent" . "https://somafm.com/secretagent.pls")))
    :general
    (leader
      "amr" '(eradio-play :which-key "Play internet radio.")
      "amR" '(eradio-stop :which-key "Stop playing internet radio.")))
#+end_src

*** RSS with Elfeed

RSS might be a great technology? I'm only just getting into it with this package!

#+begin_src emacs-lisp :lexical yes
  (use-package elfeed
    :commands elfeed

    :init
    (setq elfeed-feeds '("https://planet.emacslife.com/atom.xml"))

    :general
    (leader "ar" '(elfeed :which-key "Launch RSS reader.")))
#+end_src

*** Process Management

**** Monitor System Processes With Proced

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "apm" '(proced :which-key "Run system process manager.")))
#+end_src

**** Create and Monitor Custom Commands With Prodigy

#+begin_src emacs-lisp :lexical yes
  (use-package prodigy
    :init
    (general-setq prodigy-completion-system 'default)

    (setq crj--live-server-ports '(3263))

    (defun crj--get-new-live-server-port ()
      (let ((new-port (1+ (car crj--live-server-ports))))
        (add-to-list 'crj--live-server-ports new-port)
        (number-to-string new-port)))

    (defun crj--run-live-server-in-project-root ()
      "Run web live server in the current project's root directory."
      (interactive)
      (let ((port (crj--get-new-live-server-port))
            (dir (project-root (project-current t)))
            (name (concat "Live server for " (project-name (project-current nil)))))
        (message (format "port: %s, dir: %s, name: %s" port dir name))
        (prodigy-define-service
          :name name
          :command "live-server"
          :args (list "--no-browser" (concat "--port=" port))
          :init (lambda () (cd dir))
          :stop-signal 'quit
          :url (concat "http://127.0.01:" port))))

    :general
    (leader "app" '(prodigy :which-key "Launch custom process manager.")))
#+end_src

*** Org Agenda

Org Agenda is an amazing application that can take task data from different sources and produce an overview of your current tasks. It's powerful and efficient and customizable. It's one of the best things in Emacs.

We set up an agenda view, and then we set it as the easier-to-reach keybinding (~SPC aa~). The dashboard, which has a bunch of different potential views, is still available on ~SPC aA~.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj--shrink-org-agenda-modeline-name ()
      (setq mode-name "Org Agenda"))

    (add-hook 'org-agenda-finalize-hook #'crj--shrink-org-agenda-modeline-name)

    (defun crj-is-sunday-monday-tuesday-wednesday-thursday (date)
      "Return `t` if DATE is a Monday, Tuesday, Wednesday, or Thusday.

  For use in agenda buffers like so:

  <%%(crj-is-sunday-monday-tuesday-wednesday-thursday date)>

  It may be helpful to put a timestamp in the heading, if it happens at a specific time."
    (let ((day-of-week (calendar-day-of-week date)))
      (member day-of-week '(0 1 2 3))))

    (defun crj-agenda () (interactive) (org-agenda t "g"))

    (setq org-agenda-start-day nil
          org-agenda-window-setup 'only-window
          org-agenda-files '("~/org-stuff/inbox.org"
                             "~/org-stuff/readme.org"
                             "~/org-stuff/personal.org"
                             "~/org-stuff/archive.org"
                             "~/org-stuff/gcal/anniecannons.org")

          org-agenda-custom-commands '(("g" "Daily agenda and top priority tasks"
                                        ((todo "WAIT"
                                               ((org-agenda-overriding-header "Tasks On Hold\n")
                                                (org-agenda-block-separator nil)))
                                         (agenda ""
                                                 ((org-agenda-span 1)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-scheduled-past-days 0)
                                                  (org-agenda-day-face-function (lambda (_) 'org-agenda-date))
                                                  (org-agenda-format-date "%A %-e %B %Y")
                                                  (org-agenda-overriding-header "\n Today's Agenda\n")))
                                         (agenda ""
                                                 ((org-agenda-start-on-weekday nil)
                                                  (org-agenda-start-day "+1d")
                                                  (org-agenda-span 3)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                  (org-agenda-overriding-header "\n Next Three Days After\n")))
                                         (agenda ""
                                                 ((org-agenda-start-on-weekday nil)
                                                  (org-agenda-tag-filter-preset '("-EVENT"))
                                                  (org-agenda-start-day "+4d")
                                                  (org-agenda-span 3)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "EVENT"))
                                                  (org-agenda-overriding-header "\n Further Calendar Events\n")))
                                         (agenda ""
                                                 ((org-agenda-time-grid nil)
                                                  (org-agenda-start-on-weekday nil)
                                                  (org-agenda-start-day "+4d")
                                                  (org-agenda-span 14)
                                                  (org-agenda-show-all-dates nil)
                                                  (org-deadline-warning-days 0)
                                                  (org-agenda-block-separator nil)
                                                  (org-agenda-entry-types '(:deadline))
                                                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                  (org-agenda-overriding-header "\n Upcoming Deadlines (+14d After)\n")))))))

    :general
    (leader
      "aA" '(org-agenda :which-key "Org Agenda dashboard.")
      "aa" '(crj-agenda :which-key "Custom Org Agenda view.")))

  (use-package evil-org
    :after (evil org)

    :init
    (add-hook 'org-agenda-mode-hook #'evil-org-mode)

    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)

    :general
    (general-def
      (org-agenda-mode-map org-agenda-keymap)
      "C-S-H" nil)

    (general-def 'motion
      (org-agenda-mode-map org-agenda-keymap)
      "C-S-H" nil))
#+end_src

*** Terminals

I'll configure other terminals soon! For now, just shell commands and Vterm.
Perhaps I'll set up Eshell and Eat sometime.

**** Vterm

Of the many types of terminals in Emacs, Vterm is the most faithful to the standard terminal emulator. Note that this does not mean it's the best, but it /does/ work the way folks expect if they're used to the standard terminal emulator experience.

#+begin_src emacs-lisp :lexical yes
  (use-package vterm
    :init
    (setq vterm-shell "/usr/sbin/zsh"
          vterm-always-compile-module t
          vterm-max-scrollback 100000)

    (defun crj-kill-unnamed-vterm-terminals ()
      "Kill all vterm buffers that still have their default buffer names.

  It temporarily removes confirmation of killing modified buffers.

  So please be sure you want to kill all modified vterm buffers before
  you run this command."
      (interactive)
      (let ((kill-buffer-query-functions
             (remq 'process-kill-buffer-query-function kill-buffer-query-functions)))
        (mapc (lambda (buffer)
                (when (string-match-p (regexp-quote "vterm") (buffer-name buffer))
                  (kill-buffer buffer)))
              (buffer-list))))

    :general
    (leader "qv" '(crj-kill-unnamed-vterm-terminals :which-key "Kill all unnamed vterm buffers."))

    (:keymaps 'vterm-mode-map
     "C-c <escape>" '(vterm-send-escape :which-key "Send escape key to underlying shell.")
     "C-c :" '(vterm--self-insert :which-key "Send colon key to underlying shell."))

    (:keymaps 'vterm-mode-map
     "C-c n" '(vterm-copy-mode :which-key "Switch to Vterm Copy Mode.")
     "C-c C-t" '(vterm-copy-mode :which-key "Switch to Vterm Copy Mode."))

    (:keymaps 'vterm-copy-mode-map
     "C-c i" '(vterm-copy-mode :which-key "Turn off Vterm Copy Mode.")
     "C-c C-t" '(vterm-copy-mode :which-key "Turn off Vterm Copy Mode.")))
#+end_src

Let's also use a wrapper around vterm that allows multiple terminals.

#+begin_src emacs-lisp :lexical yes
  (use-package multi-vterm
    :general
    (leader "av" '(multi-vterm :which-key "Open a Vterm terminal.")))
#+end_src

**** Shell Commands

Added some evil bindings, and did a weird thing from [[https://www.reddit.com/r/emacs/comments/17aekjs/how_to_autofill_asyncshellcommand_with_last/][a Reddit discussion I was in]] where we found a way to make the minibuffer prompt start with the last shell command. Some fun hacking!

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj--auto-fill-shell-commands (args)
      "Auto-fill the mini-buffer with the most recent shell command.

  This advice for `read-shell-command' takes the original ARGS
  and substitutes more ergonomic ones for quick repetition of past commands.

  Its main objective is to pass the most recent item in `shell-command-history' as
  the initial output.

  It also passes the shell command history starting at index 1 as the
  history to use, so that navigating to the next option doesn't repeat the most
  recent command, which would give you the most recent option twice."
      (cl-destructuring-bind (prompt _1 _2 extra-args) args
        (list prompt (car shell-command-history) '(shell-command-history . 1) extra-args)))

    (advice-add 'read-shell-command :filter-args #'crj--auto-fill-shell-commands)

    :general
    (leader
      "!" #'(shell-command :which-key "Run a shell command.")
      "&" #'(async-shell-command :which-key "Run an asynchronous shell command.")))
#+end_src

*** Calendar

So you can wish everyone would leave you alone, but /within Emacs/.

**** View Calendar

#+begin_src emacs-lisp :lexical yes
  (use-package calfw)

  (use-package calfw-org
    :general
    (:keymaps 'cfw:org-schedule-map "RET" #'cfw:org-open-agenda-day)

    (leader "acv" '(cfw:open-org-calendar :which-key "View calendar.")))
#+end_src

**** Google Calendar Integration

Although I'm exploring ways to cut out Google entirely from my life, my work uses Google Calendar, so I need to be able to see it. This is a way to do that.

There are a /lot/ of moving parts with ~org-gcal~, those parts are continuously evolving, and the parts are poorly documented. But here's some issues I've encountered:

- The client-id and ~client-secret~ are each pulled from the sources listed in ~org-gcal~'s readme originally, but I'm keeping them... well, I'm not saying here, but you (Colin) can figure it out when you need to set up a new machine.
- Once I have them on a new machine, I put them in ~password-store~ (aka ~pass~) and, below, pull them out with ~auth-source-pass-get~. This is a way to keep them out of the repo.
- The ~org-gcal-fetch-file-alist~ is a list of calendars to pull from. The first item in the pair is Google Calendar's id of the calendar (which seems to just be the associated email for the basic personal calendar), and the second is the file to put it in. I have a separate file for each calendar.
- For now, ~gnupg~ appears to have a bug that requires you to downgrade it to ~2.4~. If you run into an erro, this /may/ be the issue.
- I don't yet fully understand the interweaving auth systems in effect, but for now, when setting this up in Arch/i3wm, you /do/ want to use the ~gnome-keyring-daemon~ to "save the password in the keyring".
- And also for now, you do NOT want to check the box for killing the pstore buffer, and you'll do better if you quit Emacs, save that buffer, and then restart Emacs.

I hope to document a clear and simple way to set this up in the future (perhaps I could practice in a VM?), but for now: this is what I've got.

**** Google Calendar Setup

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq org-gcal-client-id (auth-source-pass-get
                              'secret
                              "cal/org-gcal/ac/client-id")

          org-gcal-client-secret (auth-source-pass-get
                                  'secret
                                  "cal/org-gcal/ac/client-secret")

          org-gcal-fetch-file-alist '(("colin@anniecannons.com"
                                       .
                                       "~/org-stuff/gcal/anniecannons.org"))))

  (use-package org-gcal
    :straight (:host github :repo "kidd/org-gcal.el")

    :init
    (require 'epa-file)
    (setq epg-pinentry-mode 'loopback)

    :general
    (leader "acgf" '(org-gcal-fetch :which-key "Fetch Gcal events.")))
#+end_src

*** Version Control With Magit

I could write a lot about Magit here.

I should write a lot about Magit here!

Not today though.

**** Basic Magit Setup

Only some minor settings changes from the basic setup.

- Turn on insert state and off Copilot mode when writing Git commits. Though I know there are some AI features focused on commit messages and maybe I should check them out, plain Copilot is /really/ bad at commit messages.
- Make Magit a little more Evil by reclaiming the leader key, ~h~ and ~l~, and the low-digit count keys.
- Turn on confirmation.
- Make the window setup a little tidier.
- And add some shortcuts to both the general Magit menus and things I do more often, like clone and switch/create branches.

#+begin_src emacs-lisp :lexical yes
  (use-package magit
    :init
    (defun crj--set-up-git-commit-buffer ()
      (evil-insert-state)
      (copilot-mode -1))

    (add-hook 'git-commit-mode-hook 'crj--set-up-git-commit-buffer)
    (general-setq evil-collection-magit-want-horizontal-movement t
                  magit-bury-buffer-function #'magit-restore-window-configuration
                  magit-no-confirm nil
                  magit-display-buffer-function
                  #'magit-display-buffer-fullframe-status-v1)

    :commands
    magit-status

    :general
    (general-def
      (magit-mode-map
       magit-blame-read-only-mode-map
       magit-section-mode-map
       magit-diff-mode-map)
      "1" #'digit-argument
      "2" #'digit-argument
      "3" #'digit-argument
      "4" #'digit-argument)

    (:keymaps 'with-editor-mode-map
     "C-c C-c" '(with-editor-finish :which-key "Finish editing.")
     "C-c c" '(with-editor-finish :which-key "Finish editing.")
     "C-c '" '(with-editor-finish :which-key "Finish editing.")
     "C-c k" '(with-editor-cancel :which-key "Cancel editing.")
     "C-c C-k" '(with-editor-cancel :which-key "Cancel editing."))

    (leader
      "gg" '(magit-status :which-key "Launch Git interface.")
      "gm" '(magit-dispatch :which-key "Show Git HUD.")
      "gb" '(magit-branch-or-checkout :which-key "Switch or create Git branch.")
      "gc" '(magit-clone :which-key "Git clone.")))

  (use-package browse-at-remote
    :general
    (leader "gr" '(browse-at-remote :which-key "Browse repo's remote.")))
#+end_src

**** Magit Error Workaround

This is an annoying thing where I'm getting an error that ~seq-keep~ is not defined. There's an issue on GitHub for it, and I'll see if it still persists when I next update Emacs.

In the meantime, the workaround is to define ~seq-keep~ ourselves.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun seq-keep (function sequence)
      "Apply FUNCTION to SEQUENCE and return the list of all the non-nil results."
      (delq nil (seq-map function sequence))))
#+end_src

**** Magit As A Simple Cloud Save Feature

Here, we'll adapt Git for use not for its usual powerful version control abilities, but simply for saving to a remote repository. We're using Git, one of the most powerful and deep and flexible pieces of software ever created, as a dropbox.

Somewhere Linus Torvalds is crying, but, when you aren't really working on a serious project, this can be useful!

***** Our Cloud Save Function

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj-git-cloud-save ()
      "Adds, commits, and pushes without any further input from the user.

  Basically a way to use Git as an overpowered cloud save.

  Does 3 things:

  1. Adds all tracked files to the staging area.
  2. Creates a commit based on the project's root directory.
  3. Pushes the current branch to the push remote.

  Adapted from this SO answer: https://emacs.stackexchange.com/questions/21597/using-magit-for-the-most-basic-add-commit-push/64991#64991.

  Only major changes I made were:

  1. Removing the command to save all open buffers. We /could/ save the visited buffer only, though even that should likely be a discrete operation.
  2. Removing user input from the commit message altogether. It now composes a commit message using the current project name.
  3. Disabling the pop-up git status window. (It still shows in the minibuffer, as well as the buffer from the variable `shell-command-buffer-name-async'.)
  4. Makes every shell command async."
      (interactive)
      (magit-stage-modified)
      (let ((display-buffer-alist
             `((,shell-command-buffer-name-async display-buffer-no-window))))
        (async-shell-command
         (format
          "git commit -m \"Update %s.\" && git push"
          (project-root (project-current t)))))))
#+end_src

***** Some Shortcuts For This Workflow

Both the cloud save function above, as well as a simple git pull.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader
      "gp" '(crj-git-cloud-save :which-key "Add/commit/push tracked files to the remote.")
      "gf" '(magit-pull :which-key "Pull from the remote.")))
#+end_src

**** Magit Forge For Git Server Integration

This integrates Magit with Git servers like GitHub and GitLab.

Forge stores its data in a SQLite database, so we need to install that first.

This requires some Git configuration and storage of your credentials. See [[https://magit.vc/manual/forge/Getting-Started.html#Getting-Started][the Forge documentation]] for more details.

#+begin_src emacs-lisp :lexical yes
  (use-package sqlite3)

  (use-package forge
    :after magit)
#+end_src

**** YADM Integration

Yet Another Dotfiles Manager has been super helpful to managing my system configurations. It's a wrapper around Git that makes it easy to manage your dotfiles in a Git repo, and then use that repo to manage your dotfiles on a new machine.

Let's integrate it with Magit!

Only major change here is that I was experiencing some modeline issues with yadm buffers, so I turned the modeline off upon entering. Seems like too minor an issue to spend much time fixing, but maybe I will at some point.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (require 'tramp)
    (add-to-list 'tramp-methods
                 '("yadm"
                   (tramp-login-program "yadm")
                   (tramp-login-args (("enter")))
                   (tramp-login-env (("SHELL") ("/bin/sh")))
                   (tramp-remote-shell "/bin/sh")
                   (tramp-remote-shell-args ("-c"))))

    (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))

    (defun crj-yadm-magit-status ()
      (interactive)
       (setq mini-modeline-r-format '(" "))
       (magit-status "/yadm::"))

    :general
    (leader "gd" '(crj-yadm-magit-status :which-key "Launch Magit in YADM repo.")))
#+end_src

*** Dired

Dired is the fast and powerful file explorer in Emacs. Let's configure it! We'll:

1. Set it to group directories first.
2. Skip double-checking if we want to copy or delete all of a directory's contents.
3. Set it to omit unimportant details.
4. Set it to re-use the same buffer for each directory.
5. Add icons.
6. Set it up with an extra command to hide dotfiles.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :commands (dired dired-jump)

    :init
    (setq dired-listing-switches "-al --group-directories-first"
          dired-recursive-copies 'always
          dired-recursive-deletes 'always)

    (add-hook 'dired-mode-hook #'dired-omit-mode)
    (add-hook 'dired-mode-hook #'dired-hide-details-mode))

  (use-package dired-single
    :general
    (:keymaps 'dired-mode-map
     [remap dired-find-file] #'dired-single-buffer
     [remap dired-mouse-find-file-other-window] #'dired-single-buffer-mouse
     [remap dired-up-directory] #'dired-single-up-directory))

  (use-package dired-hacks
    :init
    (general-add-hook 'dired-mode-hook '(dired-collapse-mode))

    (defun dired-collapse-jump ()
    "Jump to the first parent directory with more than one file.

  This is opposite of \"drilling down\" through empty collapsed directories."
    (interactive)
    (let* ((file-name (or (buffer-file-name) default-directory))
           (path (or (f-parent file-name) default-directory))
           prev-path
           files)
      (while (and (file-directory-p path)
                  (file-readable-p path)
                  (setq files (f-entries path))
                  (= 1 (length files)))
        (setq prev-path path)
        (setq path (f-parent path)))
      (dired-jump nil prev-path)
      (dired-goto-file file-name)))

    :general
    ('dired-mode-map :states 'normal
      "-" #'dired-collapse-jump
      "_" #'dired-single-up-directory))

  (use-package all-the-icons)

  (use-package all-the-icons-dired
    :init
    (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

  (use-package dired-subtree
    :general
    (dired-mode-map
     :states 'normal
      "v" 'dired-subtree-toggle)

    :config
    (advice-add 'dired-subtree-toggle
                :after (lambda () (interactive)
                         (when all-the-icons-dired-mode
                           (revert-buffer)))))

  (use-package dired-hide-dotfiles
    :general
    (:keymaps 'dired-mode-map
     "H" 'dired-hide-dotfiles-mode))
#+end_src

*** Email with Mu4e

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (require 'mu4e))
#+end_src

** Under The Hood

Always confirm with a quick ~y~ or ~n~ instead of requiring a ~yes~ or ~no~ followed by ~RET~.

And never confirm to open a symlinked file under source control, which you do a /lot/ when exploring Emacs packages.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defalias 'yes-or-no-p 'y-or-n-p)
    (setq vc-follow-symlinks t))
#+end_src

Set Emacs to remember text copied to the system clipboard.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq save-interprogram-paste-before-kill t))

#+end_src

Set Emacs to remember recent files, as well as update buffers if the file changes on disk.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (recentf-mode 1)
    (setq recentf-max-saved-items 50)
    (global-auto-revert-mode 1)
    (setq global-auto-revert-non-file-buffers t))
#+end_src

Also remember our place in files.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (save-place-mode 1))
#+end_src

A better Emacs kill command binding to kill the Emacs server as well.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    ([remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)

    (leader "qq" '(save-buffers-kill-emacs :which-key "Quit emacs.")))
#+end_src

Save backups of files, every 10 idle seconds, to a backups folder in our main emacs directory.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (auto-save-mode 1)
    (setq auto-save-timeout 10
          auto-save-no-message t
          backup-directory-alist
          `(("." . ,(concat user-emacs-directory "/backups")))))
#+end_src

Increase the size of the garbage collector.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq gc-cons-threshold (* 100 1000 1000)))
#+end_src


#+begin_src emacs-lisp :lexical yes
#+end_src

*** Minibuffers

**** Save Minibuffer History

#+begin_src emacs-lisp :lexical yes
  (use-package savehist
    :init
    (savehist-mode))
#+end_src

**** Put Minibuffer at the top of the frame?

Not sure I'm using this right now, but it's an interesting idea!

If I do use it, I'll want to swap Vertico's orientation, which /would/ make ~vertico-reverse~ feel less helpful, opening up ~vertico-flat~ and ~vertico-grid~ options...

#+begin_src emacs-lisp :lexical yes
  (use-package mini-frame
    :disabled
    :init
    (mini-frame-mode))
#+end_src

**** Navigate That History More Easily

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (general-def minibuffer-mode-map
      "C-p" #'previous-line-or-history-element
      "C-n" #'next-line-or-history-element))
#+end_src

**** Allow Minibuffers Within Minibuffers

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq enable-recursive-minibuffers t))
#+end_src

**** Don't Show Keyboard Shortcuts Immediately

Set the current keyboard shortcut I'm typing to only show up after 3 seconds of inactivity. This is slightly longer than the ~which-key~ setting of 2 seconds, since I need to be /more/ lost to be unsure of what I just typed.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq echo-keystrokes 3))
#+end_src

*** Secrets

Oooh.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq auth-sources '("~/.netrc" "~/.authinfo.gpg")
          plstore-cache-passphrase-for-symmetric-encryption t)

    (setenv "SSH_ASKPASS" "x11-ssh-askpass"))

  (use-package ssh-agency
    :init
    (setq ssh-agency-askpass nil))

  (use-package password-store)

  (use-package auth-source-pass
    :init
    (auth-source-pass-enable))
#+end_src

*** Don't Yell At Me So Much

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq warning-suppress-types '((comp))
          ring-bell-function 'ignore))
#+end_src

*** Don't Mess With Custom System

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq custom-file "~/.emacs.d/emacs-custom-file.el")
    (unless (file-exists-p custom-file)
      (write-region "" nil custom-file)))
#+end_src

** Color Theme

*** Themes

**** Modus Themes

Modus Operandi is a fantastic theme for readability and accessibility, and even though I don't experience deuteranopia, I use the variant for those who do. Modus Operandi is about the uncoolest theme you can use, but... if you're using Emacs to be hip, you're doing it wrong.

#+begin_src emacs-lisp :lexical yes
  (use-package modus-themes
    :config
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-org-blocks 'gray-background
          modus-themes-completions (quote
                                    ((matches . (intense background underline bold))
                                     (selection . (accented intense bold))))

          modus-themes-headings '((0 . (variable-pitch  1.8))
                                  (1 . (variable-pitch  1.8))
                                  (2 . (variable-pitch  1.6))
                                  (3 . (variable-pitch  1.4))
                                  (4 . (variable-pitch  1.2)))

          modus-themes-common-palette-overrides modus-themes-preset-overrides-intense)

    (dolist (face '(modus-themes-prose-code modus-themes-fixed-pitch))
      (set-face-attribute face nil :family crj--fixed-pitch-font :height 1.0))

    (mapc #'disable-theme custom-enabled-themes)
    (load-theme 'modus-operandi-deuteranopia :no-confirm))
#+end_src

*** Syntax Coloring

**** Highlight Numbers And Quoted Symbols

Add a bit more splash of color by highlighting numbers and quoted Lisp symbols.

#+begin_src emacs-lisp :lexical yes
  (use-package highlight-numbers
    :init
    (add-hook 'prog-mode-hook #'highlight-numbers-mode))

  (use-package highlight-quoted
    :init
    (add-hook 'prog-mode-hook #'highlight-quoted-mode))

#+end_src

** Projects

Although having such great ability to switch files and buffers obviates the need for so many other ways to navigate (like tabs or file trees), it's still nice to narrow that down to the concept of a project.

Although =projectile= is a popular 3rd-party package as well, we'll use Emacs' built-in =project.el= library.

*** Project Customizations

Only one so far is to automatically run =project-find-file= upon switching to a new project.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq project-switch-commands 'project-find-file))

#+end_src

*** Project Keybindings

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader
      "pp" '(project-switch-project :which-key "Switch to new project.")
      "pk" '(project-kill-buffers :which-key "Kill all current project buffers.")
      "pa" '(project-remember-projects-under :which-key "Remember projects in and under directory.")
      "p," '(project-switch-to-buffer :which-key "Switch buffers in current project.")
      "pd" '(project-dired :which-key "Run dired in current project root.")
      "p." '(project-find-file :which-key "Find file in current project.")
      "p$" '(project-async-shell-command :which-key "Run command in current project root.")
      "pr" '(project-forget-project :which-key "Forget project.")))
#+end_src

** Text Editing

*** General Text Editing

**** Whitespace

***** Tabs Vs. Spaces

We'll go with spaces!

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (indent-tabs-mode -1))
#+end_src

***** Column Length

The default 70 is too low a number. 80 is the standard.

And let's visualize it!

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq-default fill-column 80)
    (add-hook 'prog-mode-hook #'display-fill-column-indicator-mode))
#+end_src

***** Whitespace Removal

This package removes whitespace from the ends of lines.

Conveniently, it only does it on lines you've edited. This way, if you're working with version control, you don't have a huge diff every time you save a file.

#+begin_src emacs-lisp :lexical yes
  (use-package ws-butler
    :diminish 'ws-butler-mode

    :config
    (ws-butler-global-mode))
#+end_src

And this built-in command removes all blank lines at point except one. Repeating it removes that one as well.

It seems handy, but since I'm not sure I'll remember the vanilla Emacs keybinding, I'm going to bind it to a more mnemonic (to me) leader keybinding of leader-m-w, for "markup whitespace"—markup kind of becoming "text" here, which is a bit of a concept creep, but… we'll see how that mnemonic feels.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :general
    (leader "mw" '(delete-blank-lines :which-key "Delete blank lines.")))
#+end_src

**** Undoing

***** Saving Undo History

Losing undos if you quit your editor is kind of a pain. Saving your undo history is just a great great idea.

Undo Fu Session is my solution here—it's meant to work with the Undo Fu package, but works just fine with vanilla Emacs' undo system.

#+begin_src emacs-lisp :lexical yes
  (use-package undo-fu-session
    :init
    (undo-fu-session-global-mode)

    :custom
    (undo-fu-session-file-limit 100000))
#+end_src

***** Visualizing Undo History

Vundo (Visualize Undo) takes Emac's very powerful and /very/ unintuitive undo system and gives you a nice navigable tree for it.

There are alternatives, but Vundo integrates nicely with Evil through the Evil Collection package, and also avoids changing anything about the actual undo system you use. Simple packages is better packages.

#+begin_src emacs-lisp :lexical yes
  (use-package vundo
    :general
    (leader "vu" '(vundo :which-key "Visualize undo.")))
#+end_src

**** Searching In Buffer

What I'm trying now is:

1. =evil-snipe= for short-range hops.
+2. =avy-goto-char-timer= for medium-range hops.+ (turns out I don't like Avy for in-buffer searches, but it might still be useful in the future for its more advanced features)
2. =evil-ex-search= for long-range hops.
3. =consult-line= for a more focused search.

Do I need +4+3 searches? /Probably not/. (I didn't!)

I'll figure out what workflow works for me in time.

***** Jumping By Character Pairs With Evil Snipe

I find that Evil-Snipe—an unfortunately named port of Vim-Sneak—is a great way to navigate over medium distances in an editor. You simply press ~s~ and then type in the two characters you want to jump to. Two characters is usually enough to identify where you want the cursor to be, at least over medium ranges. And when it isn't? You just press ~;~ to go to the next one.

Basically, it's a supercharged version of Vim's ~f~ command. It's fantastic, and I've missed it, and I'm only sorry I've taking this long to get to it.

#+begin_src emacs-lisp :lexical yes
  (use-package evil-snipe
    :diminish 'evil-snipe-local-mode

    :after evil

    :init
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1)
    :config
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode)
    (setq evil-snipe-scope 'buffer
          evil-snipe-smart-case t
          evil-snipe-char-fold t))
#+end_src

***** Avy

Avy config will be kept around for now, but I'm disabling it. Consider it "archived".

#+begin_src emacs-lisp :lexical yes
  (use-package avy
    :disabled
    :init
    (setq avy-timeout-seconds 0.5)

    :general
    (:keymaps '(evil-normal-state-map evil-motion-state-map)
     "/" #'avy-goto-char-timer
     "?" #'evil-ex-search-forward))
#+end_src

***** Evil Ex-Search and Consult-Line

are configured elsewhere!

***** Consult-Imenu

Thinking about giving this a try. It's a little less pretty than ~consult-org-heading~ when searching headings in org, but the latter's tailoring to Org means it loses the flexibility to work elsewhere. So let's give Imenu a try—it works in all files, whether markup or code.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq imenu-auto-rescan t
          imenu-use-popup-menu t)

    :general
    (leader "s." '(consult-imenu :which-key "Search buffer sections.")))
#+end_src
**** Multiple Cursors

 I used multiple cursors before learning Vim, which for the most part obviated the need for them. These days I use Evil Ex Commands, or writable occur buffers, or lsp-based renaming, but I'm bringing multiple cursors back to see if they have a place in my toolbox.

 one thing that I really like about the multi-cursors approach is that, like the writable occur buffers but unlike the other two listed above, you're still dealing with the buffer, and therefore have access to all your in-buffer text-editing tools, like Evil and the many tools I've built up around it, as well as the other great Emacs' editing tools (and those I've built around /those/).

 There are others I want to try too, such as the Evil-MC package, but I'm trying Henrik Lissner's Evil Multiedit package first, and it seems to be doing everything I want so far.

 Its default keybindings are pretty good, except for unnecessarily shadowing one of my oft-used Emacs quick-editing commands in ~kill-word~ and not binding its most useful command at all, ~evil-multiedit-match-all~.

#+begin_src emacs-lisp :lexical yes
  (use-package evil-multiedit
    :config
    (evil-multiedit-default-keybinds)
    (general-def 'insert
      "M-d" #'kill-word)

    (leader
      "icc" '(evil-multiedit-match-and-next :which-key "Add cursor at current/next match.")
      "icC" '(evil-multiedit-match-and-prev :which-key "Add cursor at current/previous match.")
      "ice" '(evil-multiedit-match-all :which-key "Add cursor to all matches.")))
#+end_src

*** Writing

**** Spell-Check With Flyspell

Flyspell is an /amazing/ built-into-Emacs spell-checker. And I have a ton of custom behavior in this section to make it even better.

I use the built-in binding of ~flyspell-auto-correct-previous-word~ for autocorrecting to the first suggestion without moving the cursor. It really feels like magic to correct a previous misspelling while continuing to write, all without missing a beat!

I get the same behavior for auto-adding the previous typo to my dictionary with a custom function.

If the first auto-correction wasn't what you wanted, the default behavior of cycling through the corrections is pretty slow—Flyspell doesn't have a great algorithm for choosing the order of suggestions—in which case I can use the below custom function to undo any previous auto-correction if applicable (so we have a misspelled word again) and choose from the full list interactively.

There's also going rapidly back without having to re-enter the keybinding, choosing from the selection each time, which can be achieved with an argument to ~flyspell-correct-wrapper~, so I've written and bound another custom function for doing that. This makes correcting multiple words /very/ fast (as soon as you're done correcting one, it jumps to the next), and /still/ restores the point afterwards.

This is all such a wonderful workflow.

That said, I have a couple minor quibbles I'll probably never get around to totally fixing:

- I /occasionally/ have to refresh spelling the visible window or entire buffer, as it doesn't always update if I undo correcting a word, It doesn't happen often, but it happens often enough that I'm adding a binding here for spell-checking those regions.
- Currently, my choices are between a kind of ugly popup for candidates right where I want them, or a better interface but one at the bottom of my screen, taking my eyes away from the action. I /could/ improve the popup's look if I stopped doing weird things with the font, true—but it would still be a bit ugly, and decidedly less ergonomic (I can't for example type in a correction in the popup). I'm sticking with the popup for now, since not-breaking-the-workflow is crucial.

Still, those are minor quibbles. Overall, this is an /amazing/ spell-checking system.

Which is good, as I make a /lot/ of spelling errors.

#+begin_src emacs-lisp :lexical yes
  (use-package flyspell
    :diminish 'flyspell-mode

    :after evil

    :demand t

    :init
    (defun crj--turn-on-flyspell ()
      (flyspell-mode 1))

    (defun crj-spellcheck-visible-window ()
      "Runs the spellchecker on the visible part of the window."
      (interactive)
      (flyspell-region (window-start) (window-end)))

    (defun crj-flyspell-add-previous-word-to-dictionary ()
      "Add the previous \"misspelled\" word to the dictionary."
      (interactive)
      (save-excursion
        (evil-prev-flyspell-error)
        (let ((current-location (point))
              (word (flyspell-get-word)))
          (when word
            (flyspell-do-correct
             'save
             nil
             (car word)
             current-location
             (cadr word)
             (caddr word)
             current-location)
            (message (format "%s saved to dictionary." (car word)))))))

    (add-hook 'text-mode-hook #'crj--turn-on-flyspell)
    (add-hook 'prog-mode-hook #'flyspell-prog-mode)
    (add-hook 'git-commit-mode-hook #'crj--turn-on-flyspell)
    (general-setq ispell-program-name "hunspell")

    :config
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic "en_US,en_CA,en_AU,en_GB,es_ES")
    (ispell-change-dictionary "en_US,en_CA,en_AU,en_GB,es_ES" t)

    :general
    (leader
      "bs" #'(crj-spellcheck-visible-window :which-key "Spellcheck visible window.")
      "bS" #'(flyspell-buffer :which-key "Spellcheck whole buffer."))

    ('(insert normal emacs)
     "C-M-;" #'crj-flyspell-add-previous-word-to-dictionary))

  (use-package flyspell-correct
    :init
    (defun crj-flyspell-correct-with-rapid-mode ()
      "Correct multiple words in a row."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'flyspell-correct-wrapper)))

    (defun crj-flyspell-correct-dwim ()
      "Correct previous word using candidate selection, first undoing any previous
  auto-correct.

  Inspired by alphapapa's function here:

  https://github.com/d12frosted/flyspell-correct/issues/30"
      (interactive)
      ;; If we've already auto-corrected, undo it.
      (when (equal flyspell-previous-command #'flyspell-auto-correct-previous-word)
        (progn
          (save-excursion
            (undo))
          (crj-spellcheck-visible-window)))

      ;; Either way, select a correction candidate.
      (call-interactively 'flyspell-correct-wrapper))

    :general
    ('(insert normal emacs)
     "C-:" #'crj-flyspell-correct-dwim
     "C-M-:" #'crj-flyspell-correct-with-rapid-mode))

  (use-package flyspell-correct-popup
    :after flyspell-correct)
#+end_src

*** Coding

Settings for... coding.

**** General

***** Coding Block Delimiters

Sometimes simply called "parens" or "brackets", delimiters are a big part of coding. This is particularly true in Lisp languages, but even the indentation-for-delimiting-code-blocks Python benefits from handling them well.

Whatever you call delimiters, let's make all these easy-to-mess-up character pairs easier to work with!

****** Auto-Close Delimiter Pairs

Use Emacs' built-in library for auto-closing your brackets, ~electric-pair-mode~. Auto-closing means that when you type an open-parens (or curly or square bracket), your editor adds a closing parens afterwards, keeping your cursor in the middle. The idea is to avoid ending up with unbalanced brackets.

Many experienced developers say auto-closing your brackets is counter-productive. Perhaps I'll give skipping it another go sometime, but every time I do, I miss it.

That said, I felt the same about using buffers as the main way to interact with text, but once I stopped relying on inefficient means like tabs, I saw how much better it was. And there are tons of other examples like that. So perhaps I'll someday see the light on this? We'll see!

Also, for some reason, electric pair mode does some weird stuff around auto-closing in Org mode—probably Org's fault, because it doesn't always play nicely with the rest of Emacs. So I've added a predicate to disable some problematic auto-closing there.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defconst crj--electric-pair-char-and-mode-block-list '(
                                                            (org-mode . "<\"")))

    (defun crj--should-avoid-auto-pairing-p (char)
      (and (assoc major-mode crj--electric-pair-char-and-mode-block-list)
           (seq-position
            (cdr (assoc major-mode crj--electric-pair-char-and-mode-block-list))
            char)))

    (setq electric-pair-inhibit-predicate #'crj--should-avoid-auto-pairing-p)
    (electric-pair-mode))
#+end_src

****** Highlighting Surrounding Delimiters

This next library highlights the delimiters of the block the cursor is currently in, providing a nice quick visual aid as to where you're /at/.

By default, it helps you see the blocks from your cursor to four delimiters outwards, but I find the next library we'll use a better fit for a larger-scale visual guide. Still, it's good to have a subtle visual indication as to exactly how deep you are currently, which is why I'm using a light Modus Theme color and it's matching light background.

#+begin_src emacs-lisp :lexical yes
  (use-package highlight-parentheses
    :diminish 'highlight-parentheses-mode

    :ghook 'prog-mode-hook
    :custom
    (highlight-parentheses-colors `(,(modus-themes-get-color-value 'fg-heading-4 t)))
    (highlight-parentheses-attributes `((:background ,(modus-themes-get-color-value 'bg-heading-4 t)))))
#+end_src

****** Using Different Colors For Different Depths With Rainbow Delimiters

Rainbow Delimiters uses a different color for each depth of delimiter, regardless of where your cursor is. So, in mine, the outer delimiter is a kind of dark blue-ish purple, the next delimiter pair inwards is a pinkish purple, the next a lighter blue, the next a blue-ish green, he next an orange-red, the next an intense red, and it keeps going like that in complementary cycles.

The color choices aren't mine, but, rather, taken from the great Modus Themes, and specifically from their headings. The code below sets ~rainbow-delimiters-depth-n~ to the color of my current Modus theme's ~fg-heading-n~ (the foreground color of the heading), where ~n~ is each number from 1-8.

The code above and below were fun coding challenges for me as I learn a bit more Lisp. There's some good learnings to be taken from how they work, from the use of ~`~ and ~,~ for evaluating code in a list to the way the ~dotimes~ loop works to the use of ~intern~ to convert a string to a Lisp symbol. Maybe you'll take something from them too!

#+begin_src emacs-lisp :lexical yes
  (use-package rainbow-delimiters
    :after modus-themes

    :ghook 'prog-mode-hook

    :config
    (dotimes (num 8)
      (set-face-attribute
       (intern (concat "rainbow-delimiters-depth-" (number-to-string (1+ num)) "-face"))
       nil
       :foreground (modus-themes-get-color-value (intern (concat "fg-heading-" (number-to-string (1+ num)))) t))))
#+end_src

**** Languages

Configurations specific to certain languages.

***** Lisps

The greatest language(s).

****** Keybindings

Some general Lisp bindings.

******* Editing Symexes In Evil-Flavored Emacs

First off, what is a "symex"? Well, I'm not going to explain what a symbolic expression is here, but you'll see the shortening "sexp" thrown around a lot in Lisp circles, and it's just /awful/. It's a terrible, terrible name.

"Symex" is a far better term, coined by a friend of the maker of the [[https://github.com/drym-org/symex.el][Symex package]]. I'll be using that term from now on, and if it never catches on, well, at least /I'm/ not using a terrible name for them.

So there are three approaches for an ex-Vim person to manipulate symexes in a Lisp language:

1. Go with basic Evil and its standard, amazing grammar. It doesn't align quite as well with Lisp as it does other languages, since Evil tends to be line-based, but you're using the exact same tools as in other languages, so there's no need to change the way you edit code depending on context. And Evil's standard tools are powerful tools!
2. Go with the above mostly, but supplement it with some lisp-specific motions like raising and splitting and slurping and barfing, and lisp-specific text objects, like forms and top-level forms. I've done this some, and I'm experimenting with it. I'd also like to expand it someday into a more feature-rich Lisp-specific editing language that simply extends Evil's language. You're an Evil user who finds that Evil doesn't have the nouns or verbs for Lisp? Well, let's make some new nouns and verbs, but keep the same grammar!
3. Go with a /different/ language that can be used either in insert mode (like paredit) or as another state you can go into, like Symex.

I'm back to approach #2 again after a lengthy experiment using Symex for approach #3. I still think

******** Adding Lisp Motions And Text Objects To Evil

This is /not/ the system I'm going with right now—see the configuration for Lispyville below for my current system. This was a custom configuration of Evil with a little bit of lisp manipulation from other libraries thrown in. I think there's still room to think about other using Evil with text objects and motions that better handle Lisp, and you can see some of the thoughts on how to do so below.

*Move By Symbols*

Set ~W~/~B~ movements ignore the many many delimiters Lisps use, so that we're not stopping on parens. If I want to go to a parens, ~f(~ is way clearer. I want to go by programming symbols!

This is part of the [[https://github.com/emacs-evil/evil-cleverparens][evil-cleverparens]] package.

The more I use this, the more I feel like we /all/ should have been using this all the time.

I'll have to give this more of a go, but it really seems like Vim's "big word" movements should /always/ have been traveling by symbols, and not just in Lisp languages.

Take this JavaScript, for example:

#+begin_src javascript :tangle no
  function greet({name}) {
    return `Hello, ${name}!`
  }
#+end_src

If you just changed the symbol ~greet~, there are three possible movements we could make with different versions of Vim/Evil's ~w~ movement:

1. move to the ~(~ using ~w~
2. move to the ~{~ using ~W~
3. move to the symbol ~name~ using Evil Cleverparens' version of ~W~

 Not only is #3 the overwhelmingly more likely use case to the point where this next part shouldn't matter, but you can also easily do the other 2 use cases with ~f(~ and ~f{~ (and sure, you could use ~fn~ for getting to the next symbol, but that a) isn't as much of a structural movement and b) can easily gotcha you momentarily if there's another ~n~ in the way).

 Basically, "words" should always be "words", not words and punctuation.

 The one use case for moving by words-with-punctuation is with multi-word symbols with punctuation, such as a variable in ~kebab-case~ or ~snake_case~. Little word movement ~w~ would move from ~kebab~ to ~case~, while ~W~ would move right to the next symbol. But Evil Cleverparens takes this into account, and still considers punctuation that simly signifies a new word /within/ a symbol as a little word that ~W~ goes right past.

 And this is where ~w~ really shines if you're talking about a /part/ of a symbol. If you want to move by little word within ~user-data~ or ~user_data~ or even ~userData~, you can do that as long as you turn on Emacs' great ~subword-mode~.

 And, of course, being not just movements but /text objects/, we can change and yank and delete and everything else using these /much/ more useful modalities.

 Okay, I still do need to use this more, so maybe I'll change my mind, but the more I think about it, the more obvious it seems that this is by far the best versions of ~w~ and ~W~ you can have.

*Move Up And Down Trees*

The Symex library gets away from Evil a little too much for me, but it has an /excellent/ way of moving up and down trees. See [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]] to see it in action!

This is what I'm thinking:

- ~+~ and ~-~ to move up and down trees
- ~M-h~ and ~M-l~ to move to the top and bottom of trees (already provbided by ~evil-cleverparens~)
- ~(~ and ~)~ to move up or down branches
- ~{~ and ~}~ to move to the start or end of a branch

*Keep Parens Balanced*

For example, if I delete a line with Evil's ~dd~, I usually don't want to delete the closing parens that is needed by an earlier line.

~evil-cleverparens~ will do this for us.

It's a weird thing, though. You spend a while adapting Evil for using with a Lisp, and you get away from using ~dd~ anyway. It's worth a try seeing if balancing the parens automatically brings it back as a tool, but... I don't know if I like using a distinctly Evil command, and giving it different behavior in Lisp contexts.

I think it feels better to simply be more precise with my commands in such contexts.

So I'm still not positive I want it, but I'm giving it a try!

*Manipulate Symexes*

Probably going to use ~evil-cleverparens~ for this, though there may be better ones out there.

In particular, I like:

- ~evil-cp-drag-forward~ and its backwards version, for moving symbols around. These are set to ~M-j~ and ~M-k~ by ~evil-cleverparens~.
- ~evil-cp->~ and ~evil-cp-<~ for a symex to increase/decrease its scope ("barfing" and "slurping"). These are set to ~<~ and ~>~ by ~evil-cleverparens~, and I'm resetting manual indentation to ~g>~ and ~g<~ in Lisp modes—I don't manually indent in Lisp modes much anyway.
- ~evil-cp-insert-at-beginning-of-form~ and the end version, for inserting/appending symbols in forms. These are set automatically to ~M-i~ and ~M-a~.
- Quoting and unquoting via Symex commands (/not/ wrapping in quotes, but the special Lisp concept of quoting/unquoting). Unfortunately, these commands require point to be at the start of the symbol, or the start of the quote/unquote if it already has it.

*Commands That Could Be Done Structurally*

I may at some point experiment with the following, all of which can be seen in [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]]:

- raising
- splitting
- merging

These motions don't have easy ways to do them with Evil.

For raise, I can probably do it with Evil Replace: I can yank the inner form, then go to the outer form, then run evil-replace. Not /too/ bad.

Merging is relatively easy with Evil, just hunting the opening and closing parens and using ~x~ to delete them... but possibly a command would be nice for this, so that I'm working structurally.

For splitting, I could... hmm... go to the place to split them (which you have to do with Symex's commands anyway), then enter insert state, type in the closing and opening parens, and exit back to normal state. And delete the extra parens if you have auto-pairing on.

All of those are /okay/ solutions, but if I find myself doing them more often, it may make sense to use more structural commands on them.

*Add More Text Objects*

This is something that a more advanced solution could give you (maybe Treesitter?)), but for now, ~evil-cleverparens~ gives you the following text objects to manipulate:

- ~f~ for a form (aka symex)
- ~d~ for a defun (aka a top-level symex, like a function)

*And, Finally, The Code That Does All That*

After all that, I've moved on to other systems, so this is merely historical. See the Lispyville section below for mycurrent system!

After all that, I've moved on to other systems, so this is merely historical. See the Lispyville section below for mycurrent system!

#+begin_src emacs-lisp :lexical yes :tangle no
  (use-package paredit)

  (use-package evil-cleverparens
    :general
    (leader
      "la" '(evil-cp-insert-at-end-of-form :which-key "Insert at end of form.")
      "li" '(evil-cp-insert-at-beginning-of-form :which-key "Insert at beginning of form.")
      "lf" '(evil-cp-drag-forward :which-key "Drag atom or form forwards.")
      "lb" '(evil-cp-drag-backward :which-key "Drag atom or form backwards."))

    (general-def 'normal
      "W" #'evil-cp-forward-symbol-begin
      "E" #'evil-cp-forward-symbol-end
      "B" #'evil-cp-backward-symbol-begin
      "gE" #'evil-cp-backward-symbol-end)

    (general-def 'normal (evil-inner-text-objects-map evil-outer-text-objects-map)
      "f" #'evil-cp-inner-form
      "d" #'evil-cp-inner-defun))

  (use-package on-parens
    :general
    (leader "lr" '(paredit-raise-sexp :which-key "Raise form."))

    (:keymaps '(paredit-mode-map symex-mode-map)
     ")" nil)

    (:keymaps '(emacs-lisp-mode-map racket-mode-map scheme-mode-map)
     :states 'normal
     "g<" #'evil-shift-left
     "g>" #'evil-shift-right)

    (:states '(normal motion operator)
     :keymaps '(emacs-lisp-mode-map racket-mode-map scheme-mode-map)
     "+" #'on-parens-down-sexp
     "-" #'on-parens-up-sexp
     "H" #'on-parens-backward-sexp-in-supersexp
     "L" #'on-parens-forward-sexp-in-supersexp
     "(" #'on-parens-backward-sexp
     ")" #'on-parens-forward-sexp
     "{" #'on-parens-backward-sexp-end
     "}" #'on-parens-forward-sexp-end
     "|" #'on-parens-split-supersexp
     "&" #'on-parens-join-neighbor-sexp
     "<" #'on-parens-backward-slurp
     ">" #'on-parens-forward-slurp
     "M-<" #'on-parens-backward-barf
     "M->" #'on-parens-forward-barf
     "_" #'paredit-raise-sexp))
#+end_src

*So Where To Next On This?*

Well, I've added some nice commands that are particular to Lisp that aren't easy to do in standard Evil, but it's still not very /Evil/. None of these are motions, and I've only added one text object I couldn't easily get elsewhere (the defun).

Basically, my choice appears to be:

- add some one-off shortcut commands, like the cycling quoting and the slurping/barfing. But these aren't integrated into the Evil editing language in any meaningful way.
- embrace a separate editing state to switch to for Evil, such as going full Symex, or the more popular [[https://github.com/noctuid/lispyville][Lispyville package]]. Again, not very Evil-y.

I've chosen the first one, but what I /want/ to exist is this third option:

- Evil motions and text objects for dealing with Lisp.

I'm really surprised and annoyed this doesn't exist, and I really want it to.

*How An Evil Lisp Language /Should/ Work*

I'm unlikely to have time ever to implement this, but here are some ideas:

*Motions*

- quote/unquote—this should probably be similar to the popular [[https://github.com/emacs-evil/evil-surround][Evil Surround package]], where we could change the quote on a symbol or form, or delete it. (It's possible this could simply be configured with Evil Surround.)
- traversing trees and branches as Symex does
- insert-at-start-of and append-at-end-of, but for forms
- change-rest, yank-rest, and delete-rest (like Evil's ~C~, ~D~, and ~Y~), but for forms
- emit/capture ("slurp" and "barf")
- merging
- transposing
- exchanging (possibly with evil-exchange)
- replacing (possibly with evil-replace)

*text objects*

- symbols
- lists
- defuns

*additional ideas*

- just like most text objects, a text object used without a motion should /default/ to traveling to the next such text object
- all motions should take counts
- we /could/ implement not just (i)n and (a)round but (o)uter
- and possibly (n)ext and (p)revious, as [[https://github.com/noctuid/targets.el][targets.el]] does.

*examples*

-

More later...

******** A Lisp-Specific Evil Editing State With Symex

I'm disabling Symex for now—or, rather, combining it with Lispyville, as you'll see below. But I'm leaving the commentary and configuration intact.

This is that approach #3 above: a separate Lisp-editing state. I'm using the great [[https://github.com/drym-org/symex.el][Symex]] package. Check it out, as well as the great visualizations in [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]].

So far, on my third or fourth attempt to work with Symex, it's going much better for some reason. Might simply be coming back to it with bit more Lisp practice, or more willingness to work with a different system than pure Evil. One thing that's definitely helping is that I'm slightly simplifying the keys used here to use fewer chords, delegate to Evil for things Evil is more appropriate for, and to emphasize the commands I use more often.

Here are the broad strokes of the changes I'm making, and I recommend checking out the Symex documentation to see what you can do with it by default!

- I removed /plenty/ of features I don't use too often in favor of the shadowed Evil bindings. You can see all the ~nil~ bindings below, where I disabled the Symex versions. In general, I kept the Symex commands that work on... symexes, since Evil doesn't handle that well. But I chose the Evil keybinding (removing or moving the Symex command) when the Evil command provides functionality Symex doesn't generally cover. This was either:
  - large-scale scrolling commands I use a lot, like ~zz~ or ~Ctrl-f~
  - single-character manipulation, like ~x~ and ~r~
- I made wrapping and line-whitespace-management slightly /less/ efficient in order to use normal-mode bindings of parens and angle brackets for slurping/barfing (or, as Symex puts it better, "emitting" and "capturing"). (And maybe "bubbling" and "ejecting" would be even better?)
- I reversed the "j" and "k" bindings to make more sense to me. Further into a nested form feels more "down" to me than "up"! The Symex guide indicates a couple of times that this is a common tweak to make. I wonder if it might even be the /more/ popular way to think about it—but either way, it's popular enough that it's in the docs.
- In a rare case, Symex left Evil's ~J~ line-joining command in place and put its own versions in alternate keybindings. I love their version and switched it.
- I tweaked a couple more /very/ minor things—things like using ~^~ for going to the first item in a list, which is slightly more efficient on my weird keyboards than 0. Feel free to check out the full keybinding config below if you want to dig into the very little tweaks.
- Fixed a bug (which might be just a load-order or compilation issue) with a hacky advising function

#+begin_src emacs-lisp :lexical yes :tangle no
  (use-package symex
    :disabled

    :init
    (defun crj--symex-remaining-length-but-using-save-excursion ()
      "This is an advising function for overriding the original `symex-remaining-length' function. It just replaces `symex-save-excursion' with regular `save-excursion', since Symex's version appears to not be known to Emacs for some reason.

    There are probably better fixes!

    Here's the original doc-string:

    Compute the remaining length of the current symex.

    This should be done via DSL computation semantics at some point."
      (save-excursion
        (let ((result (symex-execute-traversal symex--traversal-goto-last)))
          (1+ (length result)))))

    (advice-add 'symex--remaining-length :override #'crj--symex-remaining-length-but-using-save-excursion)

    :config
    (defun crj--switch-to-symex-state ()
      (if symex-mode
          (run-with-timer 0.25 nil #'symex-mode-interface)))

    (dolist (mode-name '(lisp-interaction-mode emacs-lisp-mode inferior-emacs-lisp-mode racket-mode racket-repl-mode clojure-mode clojurescript-mode clojurec-mode lisp-mode slime-repl-mode sly-mrepl-mode scheme-mode arc-mode))
      (let ((mode-hook (intern (concat (symbol-name mode-name)
                                       "-hook"))))
        (add-hook mode-hook 'symex-mode)))

    (add-hook 'symex-mode-hook #'crj--switch-to-symex-state)
    (add-hook 'evil-insert-state-exit-hook #'crj--switch-to-symex-state)

    (defconst crj--default-cursor-color (face-attribute 'cursor :background))
    (defun crj--switch-to-default-cursor ()
      (set-face-attribute 'cursor nil :background crj--default-cursor-color))

    (defun crj--switch-to-symex-state-cursor ()
      (set-face-attribute 'cursor nil :background (modus-themes-get-color-value 'mail-cite-2 t)))

    (add-hook 'evil-symex-state-entry-hook #'crj--switch-to-symex-state-cursor)
    (add-hook 'evil-symex-state-exit-hook #'crj--switch-to-default-cursor)

    (defun crj--switch-to-appopriate-cursor-with-delay ()
      (run-with-timer 0.25 nil '(lambda () (if evil-symex-state-minor-mode
                                               (crj--switch-to-symex-state-cursor)
                                             (crj--switch-to-default-cursor)))))

    (add-hook 'buffer-list-update-hook #'crj--switch-to-appopriate-cursor-with-delay)

    (setq symex--user-evil-keyspec
          '(("j" . symex-go-up)
            ("k" . symex-go-down)
            ("C-k" . symex-goto-lowest)
            ("^" . symex-goto-first)
            ("C-j" . evil-join)
            ("J" . symex-join-lines)
            ("M-j" . symex-append-newline)
            ("W" . symex-wrap-round)
            ("_" . paredit-raise-sexp)
            ("gh" . evil-backward-char)
            ("gl" . evil-forward-char)
            ("(" . symex-capture-backward)
            (")" . symex-capture-forward)
            ("<" . symex-emit-backward)
            (">" . symex-emit-forward)
            ("X" . symex-delete)
            ("x" . nil)
            ("f" . nil)
            ("t" . nil)
            ("s" . nil)
            ("S" . nil)
            ("=" . nil)
            ("r" . nil)
            ("K" . nil)
            ("[" . nil)
            ("]" . nil)
            ("w" . nil)
            ("C-f" . nil)
            ("C-b" . nil)
            ("z" . nil)))

    (symex-initialize)

    :custom
    (symex-quote-prefix-list (list "'" "#'" "`"))
    (symex-highlight-p nil)

    :general
    (:keymaps 'symex-editing-mode-map
     :states '(operator visual normal)
     :prefix "w"
     "[" #'symex-wrap-square
     "]" #'symex-wrap-square
     "(" #'symex-wrap-round
     ")" #'symex-wrap-round
     "{" #'symex-wrap-curly
     "}" #'symex-wrap-curly
     "<" #'symex-wrap-angled
     ">" #'symex-wrap-angled)

    (:keymaps '(emacs-lisp-mode-map racket-mode-map scheme-mode-map)
     :states 'normal
     "\\" #'symex-mode-interface) ; switch to Symex Mode with backslash

    (:keymaps 'symex-mode-map
     :states 'insert
     "<escape>" #'symex-mode-interface)) ; escape brings you from insert to Symex State—another escape brings you to Normal State
#+end_src

******** A Lisp-Specific Evil Editing State With Lispyville

My current system for editing Lisp. We'll see if I change it up again!

Symex's system strayed too far for me from Evil. Having a separate state meant that I had to think about what state I was in, and manage the context for that state.

I think staying in Evil Normal State is what I ideally want. The Lispyville package (a clever play on combining the Lispy package with Evil) lets you do just that, bringing new nouns and verbs to the Evil editing language, and for the most part only modifying existing commands so that they keep pairs balanced.

However, Symex has a /lot/ of great commands to navigate and manipulate Lisp code, and if they're bound to keypresses that (for the most part) don't shadow Evil keybindings, then I can have access to those great commands without losing Evil and Lispy's power.

You can see how I bind Lispyville commands below (though note that much of that work is done through the "key themes", which you can read about in the Lispyville documentation).

I'm also adding many Symex commands—again, avoiding shadowing most Evil bindings—which tend to be more lisp-tree-aware. For example, moving to the first or last symex at the current level, or acting on all remaining symexes in the current list—these are very useful when editing lisp! Check out [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][The Animated Guide To Symex]] for a great visualization of what the Symex commands I'm adding actually do.

#+begin_src emacs-lisp :lexical yes
  (use-package lispy
    :diminish

    :init
    (defun crj--start-lisp-setup ()
      (lispy-mode 1)
      (symex-initialize))

    (general-add-hook '(emacs-lisp-mode-hook
                        clojure-mode-hook
                        racket-mode-hook)
                      #'crj--start-lisp-setup))

  (use-package lispyville
    :diminish

    :ghook 'lispy-mode-hook

    :init
    (lispyville-set-key-theme
     '(operators
       c-w
       c-u
       prettify
       text-objects
       ;; the below makes motions like ~w~ affect words (and subwords in subword mode), while motions like ~W~ affect atoms
       (atom-motions t)
       commentary
       slurp/barf-cp
       additional-wrap
       additional-insert))

    :general
    (:keymaps '(lispy-mode-map
                lispy-mode-map-lispy
                lispy-mode-map-evilcp
                lispyville-mode-map
                evil-collection-lispy-mode-map)

     :states 'normal
     "g<" #'evil-shift-left
     "g>" #'evil-shift-right
     "g|" #'evil-goto-column
     "[" nil
     "]" nil
     ";" nil)

    (:keymaps '(evil-inner-text-objects-map evil-operator-state-map evil-visual-state-map)
     :states 'normal
     "a" #'lispyville-inner-atom
     "x" #'lispyville-inner-sexp
     "l" #'lispyville-inner-list
     "s" #'lispyville-inner-string)

    (:keymaps '(evil-outer-text-objects-map evil-operator-state-map evil-visual-state-map)
     :states 'normal
     "a" #'lispyville-outer-atom
     "x" #'lispyville-outer-sexp
     "l" #'lispyville-outer-list
     "s" #'lispyville-outer-string)

    (:keymaps 'lispyville-mode-map
     :states 'normal
     "W" #'lispyville-forward-atom-begin
     "B" #'lispyville-backward-atom-begin
     "M-i" #'lispyville-insert-at-beginning-of-list
     "M-a" #'lispyville-insert-at-end-of-list
     "M-h" #'lispyville-drag-backward
     "M-l" #'lispyville-drag-forward
     "U" #'lispyville-backward-up-list
     "_" #'lispy-raise-sexp
     "(" #'lispyville-previous-opening
     ")" #'lispyville-next-closing
     "&" #'lispy-join
     "|" #'lispy-split
     "M" #'lispy-convolute))

  (use-package symex
    :diminish

    :init
    (defun crj-delete-current-symex ()
      "Delete the current symex.

  This function adapts a symex function to work outside of Symex Mode.
  Symex Mode maintains the point at the start of a symex, so this function
  adjusts for more uncertainty of where point is."
      (interactive)
      (when (crj--point-is-past-start-of-thing-p 'sexp)
        (symex--execute-tree-move (symex-make-move -1 0)))
      (symex-delete 1))

    (defun crj-delete-previous-symex ()
      "Delete the previous symex.

  This function adapts a symex function to work outside of Symex Mode.
  Symex Mode maintains the point at the start of a symex, so this function
  adjusts for more uncertainty of where point is."
      (interactive)
      (when (crj--point-is-past-start-of-thing-p 'sexp)
        (symex--execute-tree-move (symex-make-move -1 0)))
      (symex-delete-backwards 1))

    (general-setq symex-highlight-p nil
                  symex-quote-prefix-list (list "'" "#'" "`"))

    (defun crj--symex-remaining-length-but-using-save-excursion ()
      "This is an advising function for overriding the original `symex-remaining-length' function. It just replaces `symex-save-excursion' with regular `save-excursion', since Symex's version appears to not be known to Emacs for some reason.

    There are probably better fixes!

    Here's the original doc-string:

    Compute the remaining length of the current symex.

    This should be done via DSL computation semantics at some point."
      (save-excursion
        (let ((result (symex-execute-traversal symex--traversal-goto-last)))
          (1+ (length result)))))

    (advice-add 'symex--remaining-length :override #'crj--symex-remaining-length-but-using-save-excursion)

    :general
    (:keymaps 'lispyville-mode-map
     :states 'normal
     "H" #'symex-go-backward
     "L" #'symex-go-forward
     "v" #'crj-delete-current-symex
     "V" #'crj-delete-previous-symex
     "{" #'symex-join-lines
     "}" #'symex-append-newline
     "(" #'symex-collapse-remaining
     ")" #'symex-unfurl-remaining
     "-" #'symex-goto-first
     "+" #'symex-goto-last
     "M-o" #'symex-open-line-after
     "M-O" #'symex-open-line-before
     "M-s" #'symex-delete
     "M-S" #'symex-delete-backwards
     "M-d" #'symex-delete-remaining
     "M-c" #'symex-change-remaining
     "M-y" #'symex-yank-remaining
     "C-'" #'symex-cycle-quote
     "C-," #'symex-cycle-unquote))

  (use-package evil-cleverparens
    :commands (evil-cp-inner-defun)

    :general
    (general-def 'normal (evil-inner-text-objects-map evil-outer-text-objects-map)
      "d" #'evil-cp-inner-defun))
#+end_src

******** Code To Test Lisp-Editing Systems On

#+begin_src emacs-lisp :lexical yes
  ;; (+ 1 2 (+ 3 4 5) (+ 6 7 8) (+ 9 10) 11 12)

  ;; (defconst new-list '(:keyword-1 some-value
  ;;                      :keyword-2 some-other-value
  ;;                      :keyword-3 yet-another))

  ;; (defconst lst '(colin
  ;;                 sarah
  ;;                 alice))

  ;; (defconst my-message "hello")
  ;; (defconst failure-message "not equal")

  ;; (defun lisp-playground-test-fun ()
  ;;   "Just a test function to play with some code."
  ;;   (interactive)
  ;;   (if (string-equal "hello" my-message)
  ;;       (message "they're equal")
  ;;     (message failure-message)))

  ;; (defun should-have-sharp-quote ()
  ;;   "Just testing."
  ;;   (interactive)
  ;;   (message "this should have a sharp quote"))

  ;; (leader
  ;;   "l" #'lisp-playground-test-fun
  ;;   "k" 'should-have-sharp-quote
  ;;   "bm" (lambda () (interactive) (message "test lambda")))
#+end_src

****** Lisp Indentation

It's the greatest of languages, but Emacs has a couple of weird opinions of how to indent.

This bit of code from Fuco1 on GitHub overrides some of that indentation behavior.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj--lisp-indent-function (indent-point state)
      "Taken from Fuco1 on GitHub.

  This function is being set as the new value for the variable
  `lisp-indent-function').

  The function `calculate-lisp-indent' calls this to determine
  if the arguments of a Lisp function call should be indented specially.

  This updated version allows for better indentation of keyword lists.

  INDENT-POINT is the position at which the line being indented begins.
  Point is located at the point to indent under (for default indentation);
  STATE is the `parse-partial-sexp' state for that position.


  If the current line is in a call to a Lisp function that has a non-nil
  property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
  it specifies how to indent.  The property value can be:


  ,* `defun', meaning indent `defun'-style
    \(this is also the case if there is no property and the function
    has a name that begins with \"def\", and three or more arguments);


  ,* an integer N, meaning indent the first N arguments specially
    (like ordinary function arguments), and then indent any further
    arguments like a body;


  ,* a function to call that returns the indentation (or nil).
    `lisp-indent-function' calls this function with the same two arguments
    that it itself received.


  This function returns either the indentation to use, or nil if the
  Lisp function does not specify a special indentation."
      (let ((normal-indent (current-column))
            (orig-point (point)))
        (goto-char (1+ (elt state 1)))
        (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
        (cond
         ;; car of form doesn't seem to be a symbol, or is a keyword
         ((and (elt state 2)
               (or (not (looking-at "\\sw\\|\\s_"))
                   (looking-at ":")))
          (if (not (> (save-excursion (forward-line 1) (point))
                      calculate-lisp-indent-last-sexp))
              (progn (goto-char calculate-lisp-indent-last-sexp)
                     (beginning-of-line)
                     (parse-partial-sexp (point)
                                         calculate-lisp-indent-last-sexp 0 t)))
          ;; Indent under the list or under the first sexp on the same
          ;; line as calculate-lisp-indent-last-sexp.  Note that first
          ;; thing on that line has to be complete sexp since we are
          ;; inside the innermost containing sexp.
          (backward-prefix-chars)
          (current-column))
         ((and (save-excursion
                 (goto-char indent-point)
                 (skip-syntax-forward " ")
                 (not (looking-at ":")))
               (save-excursion
                 (goto-char orig-point)
                 (looking-at ":")))
          (save-excursion
            (goto-char (+ 2 (elt state 1)))
            (current-column)))
         (t
          (let ((function (buffer-substring (point)
                                            (progn (forward-sexp 1) (point))))
                method)
            (setq method (or (function-get (intern-soft function)
                                           'lisp-indent-function)
                             (get (intern-soft function) 'lisp-indent-hook)))
            (cond ((or (eq method 'defun)
                       (and (null method)
                            (> (length function) 3)
                            (string-match "\\`def" function)))
                   (lisp-indent-defform state indent-point))
                  ((integerp method)
                   (lisp-indent-specform method state
                                         indent-point normal-indent))
                  (method
                   (funcall method indent-point state))))))))

    (setq lisp-indent-function #'crj--lisp-indent-function))
#+end_src

****** Emacs Lisp

******* Emacs Lisp Documentation Lookup

Better go-to-definition function for Emacs Lisp.

#+begin_src emacs-lisp :lexical yes
  (use-package elisp-def
    :diminish 'elisp-def-mode

    :init
    (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      (add-hook hook #'elisp-def-mode))

    :general
    (:keymaps 'org-mode-map :states 'normal
     "gd" '(elisp-def :which-key "Go to definition.")))
#+end_src

****** Scheme

I want to give learning Scheme a shot!

******* SICP

I'm starting with Structure and Interpretation of Computer Programs, a famous textbook on programming from MIT.

We can install the manual right into Emacs!

This'll also give me a good opportunity to learn the Info Mode keybindings.

#+begin_src emacs-lisp :lexical yes
  (use-package sicp)
#+end_src

****** Racket

#+begin_src emacs-lisp :lexical yes
  (use-package geiser)

  (use-package geiser-racket)

  (use-package racket-mode
    :mode "\\.rkt\\'"

    :gfhook #'racket-xp-mode)

#+end_src

****** Clojure

#+begin_src emacs-lisp :lexical yes
  (use-package clojure-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.clj.*$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojurescript-mode))
    (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode)))

  (use-package clj-refactor)

  (use-package cider)
#+end_src

***** CSV

#+begin_src emacs-lisp :lexical yes
  (use-package csv-mode)
#+end_src

***** JavaScript

Basic configuration for JS and JSX.

Only two things aren't easy to figure out here:

1. ~rjsx-mode~ and ~flyspell-mode~ are /not/ friends, so we turn ~flyspell-mode~ off in JS files. See [[https://github.com/felipeochoa/rjsx-mode/issues/68][this bug]].
2. The advice added to the ~rjsx-electric-gt~ function helps ~rjsx-mode~ to auto-close React JSX fragments. You can find [[https://github.com/felipeochoa/rjsx-mode/issues/112#issuecomment-773660200][the original code here]].

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq js-indent-level 2
          js2-strict-missing-semi-warning nil))

  (use-package rjsx-mode
    :gfhook #'turn-off-flyspell

    :init
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . rjsx-mode))

    :config
    (defun crj--rjsx-electric-gt-fragment-a (n)
      "Inserts matching JSX fragment.

      Credit: someone on the internet?"

      (if (or (/= n 1) (not (and (eq (char-before) ?<) (eq (char-after) ?/)))) 't
        (insert ?> ?<)
        (backward-char)))

    (defun crj--auto-close-jsx-fragments (n)
      (if (or (/= n 1) (not (and (eq (char-before) ?<) (eq (char-after) ?/)))) 't
        (insert ?> ?<)
        (backward-char)))

    (advice-add #'rjsx-electric-gt :before-while #'crj--auto-close-jsx-fragments))
#+end_src

***** TypeScript

#+begin_src emacs-lisp :lexical yes
  (use-package typescript-mode
    :init
    (setq typescript-indent-level 2)
    :mode
    (("\\.ts\\'" . typescript-mode)
     ("\\.tsx\\'" . typescript-mode)))
#+end_src

***** Using Prettier To Format Buffers

#+begin_src emacs-lisp :lexical yes
  (use-package prettier
    :init
    (defun crj-prettify-js-org-src-block ()
      "Run prettier on source block at point."
      (interactive)
      (org-edit-src-code)
      (prettier-prettify)
      (org-edit-src-exit))

    :general
    (leader "bf" '(prettier-prettify :which-key "Format buffer."))

    (leader "mf" '(crj-prettify-js-org-src-block :which-key "Format markdown block.")))
#+end_src

** Completion

Because so much in Emacs is driven by text, good completion is the difference between hard-to-use and effortless.

*** Minibuffer Completion

Minibuffer completion is a different beast than in-buffer completion, which is what most people mean when they talk about completion in other apps. The minibuffer is a kind of menu you get in Emacs, and it usually serves as a place to search for something.

In Emacs, minibuffer menus can be used to search for:

- a command you're looking to run
- a command you're looking to get more info on
- a file or directory you're looking to open
- a project to open
- a buffer to choose
- a Git branch to switch to
- a wi-fi network to join
- an emoji to insert
- and lots of other things I use every day

Other apps now have this equivalent—the one people know most developers know these days is the Command Palette in VS Code, which offers very good menu completion, but there are similar examples in Slack and Discord and Vivaldi and many other apps. But in Emacs land, because you can search for practically anything you do, having /one/ interface for searching for what you want to do next is incredibly powerful, and one of the main unique selling points of Emacs.

**** Some Basic Minibuffer Search Settings

Set Emacs to only include commands that are relevant to the current "major mode" (what you would call a file type outside of Emacs).

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (setq read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

**** Minibuffer Prettiness

Add icons!

#+begin_src emacs-lisp :lexical yes
  (use-package all-the-icons-completion
    :init
    (all-the-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))
#+end_src

**** Minibuffer Search Interface

Vertico and Marginalia together make an amazing interface for minibuffer search.

***** Marginalia

Marginalia gives you some more data in other columns in the list of results as you filter them. It's nice! Let's set it up!

#+begin_src emacs-lisp :lexical yes
  (use-package marginalia
    :general
    (:keymaps 'minibuffer-local-map
     "M-A" 'marginalia-cycle)

    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'right)

    :init
    (marginalia-mode))
#+end_src

***** Vertico

A popular Emacs minibuffer search interface is Vertico. It gives you a simple but powerful UI for accessing whatever you're looking to access, and it does it with a minimum of code, mostly focusing on extending the built-in Emacs interface. This makes it fast to use and, importantly, easy for the devs to debug.

What we'll do is:

- Install it.
- Turn it on.
- Tun on the ability to toggle interface setup.
- Set the results of searches to wrap from bottom to top.
- Set "reverse" as the default interface setup.
- Set Emacs to remember Vertico's history.
- Fix some weirdness caused by the interplay of directories and completion.
- Add the Vertico extension ~vertico-repeat~ and a keybinding to repeat previous searches.
- Add keybindings for more Vim-like ~j~/~k~ scrolling as well as scrolling by pages and going up a directory with a single delete.

Here that all is!

#+begin_src emacs-lisp :lexical yes
  (use-package vertico
    :straight
    (vertico :files (:defaults "extensions/*")
             :includes (vertico-repeat))

    :init

    (vertico-mode)
    (vertico-multiform-mode)

    :config
    (setq vertico-cycle t
          vertico-multiform-categories '((t reverse)))

    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

    (with-eval-after-load 'savehist
      (add-to-list 'savehist-additional-variables 'vertico-repeat-history))

    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

    :general
    (leader "'" '(vertico-repeat-select :which-key "Repeat previous vertico searches."))

    (:keymaps 'vertico-map
     "C-k" #'vertico-next
     "C-j" #'vertico-previous
     "C-S-p" #'vertico-scroll-up
     "C-S-n" #'vertico-scroll-down
     "C-S-k" #'vertico-scroll-up
     "C-S-j" #'vertico-scroll-down
     "RET" #'vertico-directory-enter
     "DEL" #'vertico-directory-delete-char
     "M-DEL" #'vertico-directory-delete-word))
#+end_src

***** Embark

#+begin_src emacs-lisp :lexical yes
  (use-package embark
    :bind
    (("C-." . embark-act)
     ("C->" . crj-embark-act-noquit))

    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    (defun crj-embark-act-noquit ()
      "Run action but don't quit the minibuffer afterwards."
      (interactive)
      (let ((embark-quit-after-action nil))
        (embark-act)))

    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
    The which-key help message will show the type and value of the
    current target followed by an ellipsis if there are further
    targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "…" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setq embark-indicators
          '(embark-which-key-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    :config
    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator)

    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    (defvar-keymap embark-help-actions
      :doc "Keymap for actions for help searches."
      :parent embark-general-map)
    (add-to-list 'embark-keymap-alist '(help . embark-help-actions))

    :general
    (general-def (embark-become-help-map embark-symbol-map)
      "x" #'execute-extended-command)

    (general-def (embark-command-map embark-function-map)
      "h" #'helpful-command)

    (general-def (embark-become-file+buffer-map)
      "d" #'delete-file)

    (leader "d" '(embark-act :which-key "Launch contextual menu for thing at point.")))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

****** Changing How Embark Displays Actions

I have not dived into /how/ this code from the Embark author works, but it integrates the actions better with ~which-key~. This makes the Embark actions popup look great instead of ugly. Huzzah!

#+begin_src emacs-lisp :lexical yes
  (use-package embark
    :init
    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "…" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setq embark-indicators
          '(embark-which-key-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    :config
    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator))
#+end_src

**** Minibuffer Search Data Sets

~consult~ is a library containing a set of functions that each search a different set of data. That sounds dry, but it's really not!

What it enables you to do is decide whether your search will be of:

- lines in the current buffer
- lines in any file in your project or directory
- titles of currently open buffers
- paths to recent files
- text in Emacs' clipboard history (the "kill ring")
- headings in a markup file (how I get around this document!)
- color themes
- manual pages for Unix commands

And that's not even all of them! Minibuffer searches are a /huge/ part of how you use Emacs, and Consult is just one of many ways to decide what to search through.

#+begin_src emacs-lisp :lexical yes
  (use-package consult
    :commands consult-line

    :general
    (leader "/" '(consult-line :which-key "Search in current buffer.")))
#+end_src

**** Minibuffer Search Filtering

The Orderless package is powerful and fascinating. It decides the data you're searching is filtered as you type, and you can even search in different ways in the same search.

Here's an example using the setup below. I can start typing the path of a file I want to open in a minibuffer search, then notice that most of the results are in a directory I want to exclude. So I type in a ~!~ (a pretty universal developer symbol for "not" and the name of that directory, and those results are filtered out. Then I realize I want the path to begin with the home directory, excluding everything in the ~/usr~ and ~/tmp~ and such directories. So I type ~^~ (developer for "starts with") and ~~~ (the alias for the home directory). Finally, I want only JavaScript files, so I type ~$~ (developer for "ends with") and then type ~js~, and boom!

Once you're used to this speedy filtering process, it /greatly/ cuts down on the time spent searching for whatever it is you want to do.

#+begin_src emacs-lisp :lexical yes
  (use-package orderless
    :init
    (defun crj--vertico-orderless-dispatch (pattern _index _total)
      "The set of dispatch commands I use for filtering searches.

  Taken from the Doom Emacs project, which has added so much useful configuration code to the Emacs world. Thanks, Doom contributors!"
      (cond
       ;; Ensure $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
        `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Without literal
       ((string-prefix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 1)))
       ;; Character folding
       ((string-prefix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 1)))
       ((string-suffix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 0 -1)))
       ;; Initialism matching
       ((string-prefix-p "`" pattern) `(orderless-initialism . ,(substring pattern 1)))
       ((string-suffix-p "`" pattern) `(orderless-initialism . ,(substring pattern 0 -1)))
       ;; Literal matching
       ((string-prefix-p "=" pattern) `(orderless-literal . ,(substring pattern 1)))
       ((string-suffix-p "=" pattern) `(orderless-literal . ,(substring pattern 0 -1)))
       ;; Flex matching
       ((string-prefix-p "~" pattern) `(orderless-flex . ,(substring pattern 1)))
       ((string-suffix-p "~" pattern) `(orderless-flex . ,(substring pattern 0 -1)))))

    (setq completion-ignore-case t
          completion-styles '(orderless basic)
          completion-category-defaults nil
          orderless-component-separator "#"
          orderless-style-dispatchers '(crj--vertico-orderless-dispatch)
          orderless-matching-styles '(orderless-flex orderless-literal orderless-regexp)
          completion-category-overrides '((file (styles partial-completion)))))

#+end_src

*** In-Buffer Completion

**** Corfu

Sets up:

- in-buffer completion
- cool icons for same

#+begin_src emacs-lisp :lexical yes
  (use-package corfu
    :straight
    (corfu :files (:defaults "extensions/*"))

    :init
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)
    (corfu-popupinfo-mode 1)
    (setq corfu-popupinfo-delay nil)

    :config
    (general-unbind corfu-map "RET")

    :general
    (:keymaps 'corfu-map
     :states 'insert
     "<escape>" nil
     "C-n" #'corfu-next
     "C-p" #'corfu-previous
     "C-S-n" #'corfu-scroll-up
     "C-S-p" #'corfu-scroll-down
     "C-S-j" #'corfu-scroll-up
     "C-S-k" #'corfu-scroll-down
     "C-G" #'corfu-quit
     "TAB" #'corfu-next
     [tab] #'corfu-next
     "S-TAB" #'corfu-previous
     [backtab] #'corfu-previous)

    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-separator ?#)
    (corfu-preview-current 'insert)
    (corfu-quit-at-boundary 'separator)
    (corfu-auto-prefix 1)
    (corfu-preselect 'prompt)
    (corfu-on-exact-match nil)

    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    :init
    (global-corfu-mode))

  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default)
    (kind-icon-blend-background nil)
    (kind-icon-blend-frac 0.08)

    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+end_src

And an extra package for completing Org blocks.

#+begin_src emacs-lisp :lexical yes
  (use-package org-block-capf
    :straight (:host github :repo "xenodium/org-block-capf")

    :init
    (add-hook 'org-mode-hook #'org-block-capf-add-to-completion-at-point-functions))
#+end_src

**** Hippie-Expand

Hippie-expand is a nice complete-everything-in-buffer command. It can complete form almost any source!

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (global-set-key (kbd "M-/") #'hippie-expand))
#+end_src

**** Eglot

Pretty typical setup here aside from a major advice hack to stop the annoying modeline numbers appearing and disappearing.

My advice: don't use ~advice~. Don't be like me!

Don't be like me.

#+begin_src emacs-lisp :lexical yes
  (use-package eglot
    :init
    (setq completion-category-overrides '((eglot (styles orderless))))
    (general-add-hook '(rjsx-mode-hook typescript-mode-hook clojure-mode-hook) #'eglot-ensure)

    ;; This advice might break things... copier beware!
    (defun crj--remove-eglot-modeline-extra-info ()
      (eglot-forget-pending-continuations (eglot-current-server)))

    (advice-add 'eglot--mode-line-format :before #'crj--remove-eglot-modeline-extra-info)

    :config
    (add-to-list 'eglot-server-programs
                 '((typescript-mode)
                   "typescript-language-server"
                   "--stdio"))

    :general
    (leader
      "cc" '(eglot :which-key "Run eglot in project root.")
      "cr" '(eglot-rename :which-key "Rename symbol in project.")))

  (use-package cape
    :after eglot

    :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster))
#+end_src

**** Copilot

GitHub Copilot provides AI-driven suggestions as to what you might want to insert next. This is absurdly powerful, but it's not always right. So we want to be able to accept or reject suggestions, do it granularly, and to see the suggestions in a separate window.

I also find it helpful to have a separate set of tab bindings for accepting Copilot suggestions, so I can use the normal tab bindings for standard completion.

Note that this feature only works if you have a GitHub Copilot account. If you have one, you can login using the ~copilot-login~ command.

#+begin_src emacs-lisp :lexical yes
  (use-package copilot
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))

    :general
    (leader
      "tc" '(global-copilot-mode :which-key "Toggle copilot globally.")
      "tC" '(copilot-mode :which-key "Toggle copilot for current buffer."))

    (:keymaps 'copilot-mode-map
     "M-RET" #'copilot-accept-completion
     "M-<tab>" #'copilot-next-completion
     "M-<iso-lefttab>" #'copilot-previous-completion
     "M-o" #'copilot-panel-complete
     "M-w" #'copilot-accept-completion-by-word
     "M-l" #'copilot-accept-completion-by-line
     "M-p" #'copilot-accept-completion-by-paragraph))
#+end_src



*** Flymake

A great error-navigation library

#+begin_src emacs-lisp :lexical yes
  (use-package flymake
    :diminish 'flymake-mode

    :hook (prog-mode . flymake-mode)

    :general
    (:keymaps 'normal
     "]e" '(flymake-goto-next-error
            :which-key "Go to next error.")
     "[e" '(flymake-goto-prev-error
            :which-key "Go to previous error."))

    (leader "cX" '(flymake-show-project-diagnostics :which-key "Show project diagnostics.")))
#+end_src

** AI

It's the robots!

*** First, a simple function to get my password.

#+begin_src emacs-lisp :lexical yes
  (defun crj--get-open-ai-api-key ()
    (auth-source-pass-get 'secret "ai/openai/key"))
#+end_src

*** Bing Chat

**** Main Bing Setup

#+begin_src emacs-lisp :lexical yes
  (use-package websocket)

  (use-package async-await)

  (use-package aichat
    :after '(websocket async-await)

    :straight (:host github :repo "xhcoding/emacs-aichat"))

  (use-package emacs
    :init
    (setq aichat-bingai-cookies-file "~/org-stuff/.bing-chat-cookies-file.json"
          aichat-bingai-chat-file "~/org-stuff/bing-chat.md")

    (defun crj-send-heading-to-bing-chat ()
      "Send the current heading to Bing chat.

    Additionally, perform some cleanup afterwards:

    - remove the now duplicative line we just sent (since `aichat-bingai-chat' prints the query)
    - and turn `markdown-hide-markup' back off."
      (interactive)
      (markdown-back-to-heading)
      (save-excursion
        (forward-word)
        (backward-word)
        (let ((query (buffer-substring (point) (line-end-position))))
          ;; (kill-whole-line -1)
          (aichat-bingai-chat query)))

      ;; (forward-line)

      (setq markdown-hide-markup nil))

    (defun crj-open-bing-chat-file ()
      (interactive)
      (find-file aichat-bingai-chat-file))

    :general
    (:keymaps 'markdown-mode-map
     "C-c C-c s" '(crj-send-heading-to-bing-chat :which-key "Send heading as Bing query."))

    (leader
      "aibs" '(crj-send-heading-to-bing-chat :which-key "Send heading as Bing query.")
      "aibf" '(crj-open-bing-chat-file :which-key "Open Bing chat file.")))
#+end_src

*** Simple queries in buffers with gptel

Interact with ChatGPT, either by sending text to query it with ~gptel-send~ or opening a dedicated buffer with ~gptel~ command. Requires an OpenAI API key.

#+begin_src emacs-lisp :lexical yes
  (use-package gptel
    :init
    (setq gptel-api-key (crj--get-open-ai-api-key)))
#+end_src


*** A Terminal-Like Interaction With chatgpt-shell

This one opens a dedicated shell buffer for ChatGPT interactions.

#+begin_src emacs-lisp :lexical yes
  (use-package shell-maker
    :straight (:host github
               :repo "xenodium/chatgpt-shell"
               :files ("shell-maker.el")))

  (use-package chatgpt-shell
    :requires shell-maker

    :straight (:host github
               :repo "xenodium/chatgpt-shell"
               :files ("chatgpt-shell.el"))

    :custom
    ((chatgpt-shell-openai-key (crj--get-open-ai-api-key))))
#+end_src

** Window Management

Emacs has windows, which are more like what you would call a "pane" anywhere else. Evil has some great keybindings, but they're on ~C-w~, and I also want them on my leader keys.

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (winner-mode 1)

    :general
    (leader
      "wd" '(evil-window-delete :which-key "Close window.")
      "wB" '(kill-buffer-and-window :which-key "Kill buffer and close window.")
      "wu" '(winner-undo :which-key "Undo last window setup change.")))
#+end_src

** Improving Help Commands With Helpful

Original description of Emacs From Scratch's equivalent section perfectly sums it up, so I'll let it do so:

#+BEGIN_QUOTE
[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' ~describe-~ command buffers. For example, if you use ~describe-function~, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.
#+end_quote

So Helpful dramatically improves the built-in help commands. Which were pretty great already.

I also do some configuring for the evil lookup function, replacing the standard one with Helpful's, but also rebinding the usual Evil lookup shortcut of ~K~ to a version that goes to the next symbol first.

A few more additions to the help menu:

- ~helpful-at-point~ is a great quick Emacs Lisp documentation lookup. With Evil, I can just press ~K~ on a function or variable and get its documentation and source code. It makes Emacs' amazing introspectability even easier.
- ~woman~ is for accessing Unix manual pages from within Emacs. Everything should be from within Emacs!
- ~consult-minor-mode-menu~ lets you search minor modes, both active and not, and even toggle them! You can use Embark from there to get documentation on any mode.
- ~embark-keybindings~ lets you search active keybindings, which is super sweet.
- ~shortdoc-display-group~ will help you with built-in elisp functions

#+begin_src emacs-lisp :lexical yes
  (use-package helpful
    :init
    (defun crj--set-elisp-lookup-function ()
      "Sets the documentation function for Emacs Lisp."
      (setq evil-lookup-func #'helpful-at-point))

    (defun crj-lookup-next-symbol ()
      "Look up the first symbol at or near point.

  Prefers forward, but will look backward if there's no match forward.

  Returns the point to its previous position when done."
      (interactive)
      (save-excursion
        (or
         (thing-at-point 'symbol)
         (re-search-forward "\\_<" nil t)
         (re-search-backward "\\_<" nil t))
        (evil-lookup)))

    (add-hook 'emacs-lisp-mode-hook #'crj--set-elisp-lookup-function)

    :commands
    (helpful-callable
     helpful-command
     helpful-variable
     helpful-at-point
     helpful-key
     helpful-face)

    :general
    (:states 'normal
     "K" #'crj-lookup-next-symbol)

    (leader
      "hv" '(helpful-variable :which-key "Describe variable.")
      "hp" '(find-library :which-key "Find Elisp library.")
      "hy" '(shortdoc-display-group :which-key "Elisp documentation.")
      "hB" '(embark-bindings  :which-key "Search active keybindings.")
      "hf" '(helpful-callable :which-key "Describe function.")
      "hF" '(describe-face :which-key "Describe face.")
      "hk" '(helpful-key :which-key "Describe key.")
      "hx" '(helpful-command :which-key "Describe command.")
      "hW" '(woman :which-key "Search for manual page.")
      "hg" '(customize-group :which-key "Search for customize group.")
      "hm" '(consult-minor-mode-menu :which-key "Search through minor modes.")
      "hM" '(describe-mode :which-key "Describe currently active modes."))

    ([remap describe-function] #'helpful-callable)
    ([remap describe-command] #'helpful-command)
    ([remap describe-variable] #'helpful-variable)
    ([remap describe-key] #'helpful-key))
#+end_src

** Utility Functions
Making my life easier!

#+begin_src emacs-lisp :lexical yes
  (use-package emacs
    :init
    (defun crj-cycle-setting (setting potential-values)
      "Cycle SETTING through POTENTIAL-VALUES.

      SETTING is a quoted symbol.

      POTENTIAL-VALUES is a list of values to cycle through.

  This is a very useful helper function for use when cycling a setting through potential values.

  See `crj-cycle-line-numbers' for an example usage."
      (let* ((i (cl-position (eval setting) potential-values))
             (next-i (1+ i))
             (new-value (if (eq next-i (length potential-values))
                            (car potential-values)
                          (nth next-i potential-values))))

        (set setting new-value))))
#+end_src

** Modeline

Modeline is in pretty good shape, and hopefully I don't futz with it more.

I've:

- Removed most of the minor modes from showing up using Diminish, added way higher up there.
- Configured what else shows up and doesn't with the ~crj--modeline-r-format~ variable below. Check the docstring of the variables it uses to learn what I've done.
- Hacked the LSP info so it doesn't constantly report on lag, which is honestly more distracting than LSP lag itself. See the Eglot section for how I did this.
- Merged the modeline and the minibuffer using the excellent Mini Modeline package. This gets you back some substantial screen estate, especially since the modeline is now on just the frame, not each individual window.
- Merging with the minibuffer /also/ means that when you change the format to have no info, you're really hiding the modeline entirely. I do that by default, but I can toggle it back on if I need to.

#+begin_src emacs-lisp :lexical yes
  (use-package mini-modeline
    :straight (:repo "kiennq/emacs-mini-modeline" :host github)

    :diminish 'mini-modeline-mode

    :init
    (defconst crj--modeline-r-on-format '("%e"
                                          mode-line-front-space
                                          mode-line-modified
                                          mode-line-remote
                                          " "
                                          mode-line-buffer-identification
                                          " "
                                          (:eval (car (vc-git-branches)))
                                          " "
                                          mode-line-percent-position
                                          " "
                                          evil-mode-line-tag
                                          (:eval
                                           (string-trim
                                            (format-mode-line mode-line-modes)))

                                          mode-line-misc-info))

    (setq mini-modeline-face-attr nil)
    (setq mini-modeline-r-format crj--modeline-r-on-format)

    (defun crj-toggle-modeline ()
      (interactive)
      (setq mini-modeline-r-format
            (if (eq mini-modeline-r-format crj--modeline-r-on-format)
                " "
              crj--modeline-r-on-format)))

    (mini-modeline-mode t)

    :general
    (leader "tm" '(crj-toggle-modeline :which-key "Toggle modeline.")))

#+end_src

** Putting It All Together

This is a list of noweb references with a preliminary load order. Eventually I'll use this to actually tangle the code to the file.

#+NAME: load-order
#+begin_src emacs-lisp :lexical yes :tangle no
  <<literate-config-setup>>
  <<start-with-messages>>
  <<package-system>>
#+end_src

** Config Changes Todos
*** restclient.el and ob-restclient
*** snippets - skeleton or tempo or tempel or yasnippet??
*** add evil-undo to v/V keybindings
*** make v/V work with WORDs
*** override C-/ in ChatGPT and POSSIBLY C-k/C-u in Slack and (more likely since it's less useful) C-k in ChatGPT

Here's some JS that we could try using tampermonkey(chrome) or greasemonkey (firefox) or user scripts (floorp) to get going:

#+begin_src javascript :tangle no
  document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.keyCode === /*desired key code*/) {
          e.stopPropagation();
      }
  }, true);
#+end_src

*** remove repeat from Symex movement commands
[[https://github.com/noctuid/evil-guide#command-properties][see here for how to do it I think!]]
*** clean up config file and add better commentary
*** understand jump list better
*** configure hippie-expand
*** check org mode setups from other evil configs
*** Save and kill buffer

More old code to revisit and reactivate maybe.

#+begin_src emacs-lisp :lexical yes :tangle no
  (setq crj/immortal-buffer-names '("*scratch*" "#emacs" "*Messages*" shell-command-buffer-name shell-command-buffer-name-async))

  (defun crj/kill-or-bury-current-buffer ()
    (interactive)
    (if (member (buffer-name (current-buffer)) crj/immortal-buffer-names)
        (bury-buffer)
      (kill-buffer (current-buffer))))

  (defun crj/save-and-kill-or-bury-current-buffer ()
    (interactive)
    (save-buffer)
    (if (member (buffer-name (current-buffer)) crj/immortal-buffer-names)
        (bury-buffer)
      (kill-buffer (current-buffer))))

  (map! :leader
    (:prefix ("b" . "+buffer")
     :desc "Save file and close buffer."
     :n "q"
     #'crj/save-and-kill-or-bury-current-buffer
     :desc "Kill buffer."
     :n "d"
     #'crj/kill-or-bury-current-buffer)
    (:prefix ("f" . "+file")
     :desc "Save file and close buffer."
     :n "q"
     #'crj/save-and-kill-or-bury-current-buffer))
#+end_src
*** Org vanilla C-c keybindings for clocking/timestamp management
*** org evil keybindings for clocking
*** add npm start prodigy command
*** one shortcut for all in-buffer semantic searches

- Maybe ~SPC s s~ for "search symbol"?
- Add them to specific mode maps for specific modes.
- could include:
  - ~counsel-outline~ for markdown
  - ~counsel-org-heading~ for org
  - ~counsel-imenu~ for prog mode

*** Add Evil Embrace
*** Look through some other config repos for inspiration
- [[https://github.com/patrickt/emacs]]
- [[https://www.lucacambiaghi.com/vanilla-emacs/readme.html]]
- [[https://config.daviwil.com/emacs]]
*** make sure we're always fullscreened
this might do it: ~(add-to-list 'default-frame-alist '(fullscreen . maximized))~
*** Set Up Debugging With Dap-Mode

Some code and docs to start with from Emacs From Scratch:

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]]. You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language. Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle no :lexical yes
  (use-package dap-mode
    Uncomment the config below if you want all UI panes to be hidden by default!
    :custom
    (lsp-enable-dap-auto-configure nil)
    :config
    (dap-ui-mode 1)
    :commands dap-debug
    :config
    Set up Node debugging
    (require 'dap-node)
    (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    Bind `C-c l d` to `dap-hydra` for easy access
    (general-define-key
     :keymaps 'lsp-mode-map
     :prefix lsp-keymap-prefix
     "d" '(dap-hydra t :wk "debugger")))
#+end_src

*** tagedit
*** get my custom delete-word-backward and delete-symex-backward functions to save and restore position in word
*** play with dired-ranger copy-and-paste and dired-dwim-target
*** timers
*** restore window configuration and kill Magit buffers on exit
[[https://www.reddit.com/r/emacs/comments/17af1q5/comment/k5e208o/?share_id=RCKIJthLX9VRYwvUxJM4F&utm_name=androidcss][This reddit comment has what you need!]]
*** post on Reddit about:
- evil replace/exchange/eval/title-case operators
- git-cloud-save
- Evil word setup
- Evil lisp setup
- delete word/delete last word
- Emacs in Vim in Emacs
*** redo this document to have load order at the bottom and re-organize the doc itself nicely
*** explore hippie-expand
*** add general's tools like gsetq and general-add-hook to clean up my config code
*** add filename cape to capfs
*** switch to Emacs 29
new features to check out once you do:

- built-in treesitter, use-package, eglot, and sqlite
- built-in vc-use-package as a stripped down straight—probably keep using straight, though
- switch init directories
- improved help window bindings
- pixel-scroll-precision-mode
- new build options
- better executable script settings
- better Eshell over TRAMP
- C-d will delete whole graphemes (i.e., emojis or other composite characters)
- better handling of long lines
- global font-size modification... maybe can get rid of my custom version! (or not if it can't handle the different fonts)
- new bindings for find-library (??), which apparently already exists you can bind with (find-function-setup-keys)... actually it seems pretty useful!
- new way to toggle between M-x and M-X, which seems pretty awesome
- rename-visited-file!
- delete-process
- restart-emacs
- set-message-functions for inhibiting messages
- better emoji insertion!
- help-window-keep-selected
- help-quick keyboard cheatsheet
- undelete-frame-mode!
- highlight-confusing-reorderings
- cycle-spacing for a more powerful just-one-space
- show-paren-context-when-offscreen!
- cusotmizable dired-omit-lines
- elisp-eval-region-or-buffer!
- scratch-buffer
- char-fold options, which might work with evil search, and allow you to... search for similar characters?
- proced-enable-color-flag!
- string-edit (for elisp functions/packages)
- define-key removal!
- keymap-set commands!

*** think about putting the minibuffer selection at the top (mini-frame-mode)
*** check out desktop-save-mode
*** try Combobulate
*** scroll-on-jump?
*** one command to prettify source code for markdown or emacs-lisp

*** remove old org mode config stuff

Anything useful here?

#+begin_src emacs-lisp :lexical yes :tangle no
  (use-package org
    :commands (org-capture org-agenda)
    :hook (org-mode . efs/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (setq org-agenda-files
          '("~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org"
            "~/Projects/Code/emacs-from-scratch/OrgFiles/Habits.org"
            "~/Projects/Code/emacs-from-scratch/OrgFiles/Birthdays.org"))

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
            (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    (setq org-refile-targets
          '(("Archive.org" :maxlevel . 1)
            ("Tasks.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
          '((:startgroup)
                                          ; Put mutually exclusive tags here
            (:endgroup)
            ("@errand" . ?E)
            ("@home" . ?H)
            ("@work" . ?W)
            ("agenda" . ?a)
            ("planning" . ?p)
            ("publish" . ?P)
            ("batch" . ?b)
            ("note" . ?n)
            ("idea" . ?i)))

    ;; Configure custom agenda views
    (setq org-agenda-custom-commands
          '(("d" "Dashboard"
             ((agenda "" ((org-deadline-warning-days 7)))
              (todo "NEXT"
                    ((org-agenda-overriding-header "Next Tasks")))
              (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

            ("n" "Next Tasks"
             ((todo "NEXT"
                    ((org-agenda-overriding-header "Next Tasks")))))

            ("W" "Work Tasks" tags-todo "+work-email")

            ;; Low-effort next actions
            ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
             ((org-agenda-overriding-header "Low Effort Tasks")
              (org-agenda-max-todos 20)
              (org-agenda-files org-agenda-files)))

            ("w" "Workflow Status"
             ((todo "WAIT"
                    ((org-agenda-overriding-header "Waiting on External")
                     (org-agenda-files org-agenda-files)))
              (todo "REVIEW"
                    ((org-agenda-overriding-header "In Review")
                     (org-agenda-files org-agenda-files)))
              (todo "PLAN"
                    ((org-agenda-overriding-header "In Planning")
                     (org-agenda-todo-list-sublevels nil)
                     (org-agenda-files org-agenda-files)))
              (todo "BACKLOG"
                    ((org-agenda-overriding-header "Project Backlog")
                     (org-agenda-todo-list-sublevels nil)
                     (org-agenda-files org-agenda-files)))
              (todo "READY"
                    ((org-agenda-overriding-header "Ready for Work")
                     (org-agenda-files org-agenda-files)))
              (todo "ACTIVE"
                    ((org-agenda-overriding-header "Active Projects")
                     (org-agenda-files org-agenda-files)))
              (todo "COMPLETED"
                    ((org-agenda-overriding-header "Completed Projects")
                     (org-agenda-files org-agenda-files)))
              (todo "CANC"
                    ((org-agenda-overriding-header "Cancelled Projects")
                     (org-agenda-files org-agenda-files)))))))

    (setq org-capture-templates
          `(("t" "Tasks / Projects")
            ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

            ("j" "Journal Entries")
            ("jj" "Journal" entry
             (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
             "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
             ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
             :clock-in :clock-resume
             :empty-lines 1)
            ("jm" "Meeting" entry
             (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
             "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
             :clock-in :clock-resume
             :empty-lines 1)

            ("w" "Workflows")
            ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
             "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

            ("m" "Metrics Capture")
            ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
             "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

    (define-key global-map (kbd "C-c j")
      (lambda () (interactive) (org-capture nil "jj")))

    (efs/org-font-setup)
    )

#+end_src

*** add bindings for org deadlines and schedules

*** add bindings for org-mode-src block movement
~[b~ and ~]b~?

*** redo font size to be calculated based on resolution

*** add way to run other Emacs with same init directory to check our init... maybe starting a different server, or a serverless Emacs?
*** shortcut to toggle eldoc-mode

*** make sure tabs are set correctly

Possibly use my own variable to hold my current favorite indentation amount.

And another one for the other popular one!

Some variables to check out:

#+begin_src emacs-lisp :lexical yes :tangle no
  (setq indentation-to-check-out '(indent-tabs-mode
                                   tab-width
                                   markdown-list-indent-width
                                   evil-shift-width
                                   css-indent-offset))
#+end_src
*** make line numbers increase in size at a lower rate. This command could be useful:

#+begin_src emacs-lisp :lexical yes
  (defun crj--reset-line-number-height ()
    (set-face-attribute 'line-number nil :height crj--default-font-size))
#+end_src

*** add ability to zoom to preset big size.

*** add zooming to new-buffer-hook to adjust to current text scale?

Would require that global-default-variable idea (or maybe reuse what exists?)

*** add "i" and "o" (or switch those with j/k?) to zoom in by larger increments

*** Figure out babel exporting

Some sample code:

#+begin_src emacs-lisp :lexical yes :tangle no
  (setq org-babel-default-header-args `((:results . "verbatim pp replace output")
                                        (:exports . "both")
                                        (:noweb . "strip-export")
                                        (:session . "none")
                                        (:padline . "no")))
#+end_src

*** See if any of this completion code is useful


**** Lots of completion settings to look over!

I'll need to look this stuff over at some point. Particularly if I ever want to return to using snippets.

#+begin_src emacs-lisp :tangle no :lexical yes
  snippet settings

  (defun crj--set-up-snippets ()
    (yas-global-mode)
    (setq yas-snippet-dirs '("~/.doom.d/snippets"))
    (yas-reload-all)
    ;; I like having a specific (non-tab) and easy key for expanding snippets
    (map! :i [M-tab] #'yas-expand
          :map yas-keymap "TAB" nil
          "<tab>" nil
          [M-tab] #'yas-next-field-or-maybe-expand))

  (require 'yasnippet)
  (after! yasnippet (crj--set-up-snippets))

  ;; don't add newlines to end of snippet files
  (defun no-final-newline-in-buffer ()
    (setq-local require-final-newline nil))
  (add-hook! 'snippet-mode-hook 'no-final-newline-in-buffer)

#+end_src

#+begin_src emacs-lisp :tangle no :lexical yes
  (map! :i [C-tab] nil)
  (map! :i [C-tab] #'emmet-expand-line)
  (map! :map emmet-mode-keymap "<tab>" nil)

#+end_src

This looks like something I'll want to implement too.

#+begin_src emacs-lisp :tangle no :lexical yes
  (defun toggle-eldoc-mode ()
    (interactive)
    (if eldoc-mode
        (eldoc-mode -1)
      (eldoc-mode 1)))

  (map!
   :leader
   (:prefix ("t" . "toggle")
    :desc "eldoc for current symbol" :n "k" #'eldoc
    :desc "eldoc mode." :n "K" #'toggle-eldoc-mode))

  #+end_src

  Might be some useful Embark stuff here, since I'll be setting that up soon.

  #+begin_src emacs-lisp :tangle no :lexical yes
    (use-package vertico
      :config
      embark act and resume completion
      (defun crj--embark-act-without-quitting ()
        (interactive)
        (let ((embark-quit-after-action nil))
          (embark-act)))
      (map! :map vertico-map "C-:" #'crj--embark-act-without-quitting)
      (map! :leader
            :desc "Select from previous completions." "\"" #'vertico-repeat-select)
      (map! :map vertico-map "C-S-P" #'vertico-scroll-down)
      (map! :map vertico-map "C-S-N" #'vertico-scroll-up))
#+end_src

These might be useful Corfu settings? check them out once I get Eglot going?

  #+begin_src emacs-lisp :tangle no :lexical yes
    (use-package corfu
      :config
      (define-key corfu-map (kbd "M-g") #'corfu-quit)
      (define-key corfu-map (kbd "C-n") #'corfu-next)
      (define-key corfu-map (kbd "C-j") #'corfu-next)
      (define-key corfu-map (kbd "C-p") #'corfu-previous)
      (define-key corfu-map (kbd "C-k") #'corfu-previous)
      (define-key corfu-map (kbd "C-S-n") #'corfu-scroll-up)
      (define-key corfu-map (kbd "C-S-j") #'corfu-scroll-up)
      (define-key corfu-map (kbd "C-S-p") #'corfu-scroll-down)
      (define-key corfu-map (kbd "C-S-k") #'corfu-scroll-down)
      (define-key corfu-map (kbd "RET") nil)
      (define-key corfu-map (kbd "RET") #'corfu-complete)
      (define-key corfu-map (kbd "TAB") nil)
      (define-key corfu-map (kbd "<tab>") nil)
      (define-key corfu-map (kbd "<tab>") #'corfu-insert)
      (define-key corfu-map (kbd "TAB") #'corfu-insert)
      (setq corfu-commit-predicate nil
            completion-category-overrides '((eglot (styles orderless)))
            corfu-auto t
            corfu-auto-prefix 1
            corfu-quit-no-match t
            corfu-cycle t))

    (after! projectile
            (add-to-list 'projectile-project-root-files ".git"))

    ;; I don't need the "symbol class" info in my documentation.
    (after! marginalia
            (setf (alist-get 'variable marginalia-annotator-registry)
                  '(crj--custom-marginalia-annotate-variable builtin none))
            (setf (alist-get 'symbol marginalia-annotator-registry)
                  '(crj--custom-marginalia-annotate-symbol builtin none))
            (setf (alist-get 'function marginalia-annotator-registry)
                  '(crj--custom-marginalia-annotate-function none)))

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)))
    (sql-mode . t)
    (racket . t)
    (python . t)
    (ipython . t)
    (bash . t)
    (sh . t)
    (js . t)
    (javascript . t)
    (sql . t)
    (go . t)


    (map! :leader
          :desc "Yank from kill ring with completion." :n "P" #'yank-from-kill-ring)

    ;; (map! :i "C-SPC" #'complete-symbol)

    (setq embark-prompter 'embark-completing-read-prompter)

  #+end_src

*** Add markup mode add-heading-above command

*** Set Up Eshell

This is Emacs From Scratch's code and documentation on it:

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp. It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (~ls~, ~rm~, ~mv~, ~grep~, etc). It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing ~vim~ to ~find-file~). Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well. However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- ~C-c C-p~ / ~C-c C-n~ - go back and forward in the buffer's prompts (also ~[[~ and ~]]~ with evil-mode)
- ~M-p~ / ~M-n~ - go back and forward in the input history
- ~C-c C-u~ - delete the current input string backwards up to the cursor
- ~counsel-esh-history~ - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp :tangle no :lexical yes
  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim"))))


#+end_src

*** configure modeline further

1. make minor modes opt-in - perhaps a custom list we can display?
2. buffer name or. file and parent directory
3. vc-git-branches
4. modified
5. percent position
   1. possibly with last line using ~line-number-at-pos~ and ~point-max~
   2. possibly with ~0%~ and ~100%~ instead of the nonparallel "Top" and "Bot"
6. maybe the ~mode-line-misc-info~, can maybe substitute our own instead?

*** rewrite symex section copy

*** switch to msgs buffer cmd

*** targets

*** evil show ex digraphs

*** ace link

*** file management

#+begin_src emacs-lisp :lexical yes :tangle no
  (setq! auto-save-default t)
  (setq backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist '(("." . "~/.emacs.d/backups/"))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)       ; use versioned backups
  (setq auto-save-file-name-transforms
        `((".*" "~/.emacs.d/backups/" t)))
#+end_src

*** org capture

*** org protocol capture

*** Better scratch buffers

Some old code to revisit and maybe put back into play!

#+begin_src emacs-lisp :lexical yes :tangle no
  (defun crj--get-new-scratch-buffer-mode (previous-mode read-only-p desired-mode)
    (cond (desired-mode desired-mode)
          ((not read-only-p) previous-mode)
          (t 'emacs-lisp-mode)))

  (defun crj/open-scratch-buffer (&optional new-buffer-p project-p same-window-p desired-mode)
    "Open a scratch buffer with the current buffer's mode applied.

  Passes on arguments to `doom/open-scratch-buffer'. See that function's doc string for the arguments used.

  Setting `doom-scratch-initial-major-mode' to `t' was supposed to handle the \"use the same mode\" part, but it does not appear to be working. So: hack."
    (interactive)
    (let ((new-mode (crj--get-new-scratch-buffer-mode major-mode buffer-read-only desired-mode)))
      (doom/open-scratch-buffer new-buffer-p project-p same-window-p)
      (funcall new-mode)))

  (defun crj/switch-to-scratch-buffer ()
    "Switch to the scratch buffer with the current mode applied."
    (interactive)
    (crj/open-scratch-buffer nil nil t))

  ;; Currently unused, but... here's how I'd do it if I brought it back.
  (defun crj/open-new-scratch-buffer ()
    "View a new scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer t))

  (defun crj/open-project-scratch-buffer ()
    "Open a project-specific scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer nil t))

  (defun crj/open-project-scratch-buffer-in-new-window ()
    "View a project-specific scratch buffer with the current buffer's mode applied."
    (interactive)
    (crj/open-scratch-buffer nil t t))

  (defun crj/open-scratch-buffer-in-emacs-lisp-mode ()
    "Open a scratch buffer in `emacs-lisp-mode.'"
    (interactive)
    (crj/open-scratch-buffer nil nil nil 'emacs-lisp-mode))

  (defun crj/open-scratch-buffer-in-a-js-mode ()
    "Open a scratch buffer in `rjsx-mode"
    (interactive)
    (crj/open-scratch-buffer nil nil nil 'rjsx-mode))

  (defun crj/switch-to-scratch-buffer-in-emacs-lisp-mode ()
    "Switch to a scratch buffer in `emacs-lisp-mode'."
    (interactive)
    (crj/open-scratch-buffer nil nil t 'emacs-lisp-mode))

  (defun crj/switch-to-scratch-buffer-in-a-js-mode ()
    "Switch to a scratch buffer in a JavaScript Mode

  Currently we're using `rjsx-mode'."
    (interactive)
    (crj/open-scratch-buffer nil nil t 'rjsx-mode))

  ;; Gotta remove doom's built-in ones first.
  (define-key doom-leader-map "x" nil)
  (define-key doom-leader-map "X" nil)

  (map! :leader
    (:prefix ("x" . "open scratch")
     :desc "Open a scratch buffer in current mode." :n "x" #'crj/open-scratch-buffer
     :desc "Open a scratch buffer in Emacs Lisp mode." :n "e" #'crj/open-scratch-buffer-in-emacs-lisp-mode
     :desc "Open a scratch buffer in a JS mode." :n "j" #'crj/open-scratch-buffer-in-a-js-mode)
    (:prefix ("X" . "switch to scratch")
     :desc "Open a scratch buffer in current mode." :n "x" #'crj/switch-to-scratch-buffer
     :desc "Open a scratch buffer in Emacs Lisp mode." :n "e" #'crj/switch-to-scratch-buffer-in-emacs-lisp-mode
     :desc "Open a scratch buffer in a JS mode." :n "j" #'crj/switch-to-scratch-buffer-in-a-js-mode))

  (setq doom-scratch-dir "~/Documents/work/playground/")
#+end_src

*** mu4e

*** Emacs as $EDITOR

And ~e~ in any terminal should open file in Emacs buffer.

*** Better window management

**** after window split, swap windows

**** windows wrap around

~windmove-wrap-around~

**** more window stuff

Yup, more old code I used to use.

#+begin_src emacs-lisp :lexical yes :tangle no
  (defun hydra-move-split-right-more (arg)
    "Move window split right by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 10)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'left))
          (shrink-window-horizontally movement-amount)
        (enlarge-window-horizontally movement-amount))))

  (defun hydra-move-split-left-more (arg)
    "Move window split left by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 10)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally movement-amount)
        (enlarge-window-horizontally movement-amount))))

  (defun hydra-move-split-up-more (arg)
    "Move window split up by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 5)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window movement-amount)
        (shrink-window movement-amount))))

  (defun hydra-move-split-down-more (arg)
    "Move window split down by a hardcoded higher amount."
    (interactive "p")
    (let ((movement-amount (* arg 5)))
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window movement-amount)
        (enlarge-window movement-amount))))

  (defhydra hydra/crj-window-nav (:hint nil)
    "
  Split: _v_ert  _s_:horz
  Delete: _c_lose  _o_nly
  Switch Window: _h_:left  _j_:down  _k_:up  _l_:right
  Resize: _H_:splitter left  _J_:splitter down  _K_:splitter up  _L_:splitter right
  Balance Windows: _=_
  Quit: _q_
  "

    ("s" +evil/window-split-and-follow)
    ("v" +evil/window-vsplit-and-follow)

    ("c" delete-window)
    ("o" delete-other-windows)

    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)

    ("H" hydra-move-split-left-more)
    ("J" hydra-move-split-down-more)
    ("K" hydra-move-split-up-more)
    ("L" hydra-move-split-right-more)

    ("=" balance-windows)
    ("q" nil))
#+end_src

*** setup bookmark

*** emacs-nm

*** parrot (rotate symbol at point)

*** add pulsar pulse command

*** keycast

*** search online

*** open file at point

*** org character marker toggle

*** ibuffer filters

*** jest mode

*** create wttrin library

*** eglot get info on symbol

*** show flymake project diagnostics

I used to like this one! Would take some digging into Doom though to find the original code.

#+begin_src emacs-lisp :lexical yes :tangle no
  (map! :leader
    (:prefix ("c" . "+code")
     :desc "Show diagnostics in buffer." :n "x" #'+default/diagnostics
     :desc "Show project diagnostics." :n "X" #'flymake-show-project-diagnostics))
#+end_src

*** Old eshell/vterm config

A /lot/ of terminal stuff I used ot have set up. Definitely revisit this if I start spending lots of time in terms again.

#+begin_src emacs-lisp :lexical yes :tangle no
  (require 'dwim-shell-commands)

  (defun crj/toggle-eshell-scrollback ()
    (interactive)
    (if (equal eshell-scroll-to-bottom-on-output 'all)
        (setq eshell-scroll-to-bottom-on-output nil)
      (setq eshell-scroll-to-bottom-on-output 'all)))

  ;; command to toggle scroll-on-output on or off
  (map! :map evil-normal-state :leader
    (:prefix ("z" . "more toggling")
     :desc "toggle terminal auto-scroll" "s" #'crj/toggle-eshell-scrollback
     :desc "read eshell history in" "r" #'eshell/r))


  (map! :leader
    (:prefix ("v" . "view")
     :desc "View available eshell buffers." :n "e" #'+eshell/switch-to))

  (defun open-vterm-other-frame ()
    (interactive)
    (make-frame-command)
    (let ((buf (current-buffer)))
      (switch-to-buffer buf)
      (switch-to-buffer-other-frame buf))
    (+vterm/here nil))

  (defun open-eshell-other-frame ()
    (interactive)
    (make-frame-command)
    (let ((buf (current-buffer)))
      (switch-to-buffer buf)
      (switch-to-buffer-other-frame buf))
    (+eshell/here))

  (defun crj/vterm-in-current-directory ()
    (interactive)
    (+vterm/here t))

  ;; set up did-you-mean suggestions
                                          ; (eshell-did-you-mean-setup)

  ;; open terminals
  (map! :leader
    (:prefix ("o" . "open")
     :desc "Open vterm buffer in current directory"
     :n "v" #'crj/vterm-in-current-directory
     :desc "Open vterm in other frame"
     :n "V" #'open-vterm-other-frame
     :desc "Open eshell buffer"
     :n "e" #'+eshell/here
     :desc "Open eshell in other frame"
     :n "E" #'open-eshell-other-frame))

  ;;; Toggleable vterm/eshell popups
  (map! :map evil-normal-state :leader
    (:prefix ("t" . "toggle")
     :desc "eshell popup" "e" #'+eshell/toggle
     :desc "vterm popup" "v" #'+vterm/toggle))

  ;; TODO switch eshell buffers

  ;; remember moar better
  (setq eshell-history-size 100000)

  ;; turn off their history saving so we can do it more often
  (setq eshell-save-history-on-exit nil)

  (defun crj/eshell-update-history ()
    "Append to eshell's command history and read it everywhere."
    (when eshell-history-ring
      (let ((newest-cmd-ring (make-ring 1)))
        (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
        (let ((eshell-history-ring newest-cmd-ring))
          (eshell-write-history eshell-history-file-name t)))))

  ;; always write to eshell history after every command
  (add-hook 'eshell-pre-command-hook 'crj/eshell-update-history)
  ;; When creating a new terminal, get the history of all previous terminals.
  (add-hook 'eshell-hist-load-hook 'eshell-read-history)

  (setq async-shell-command-buffer 'new-buffer)

  (defun crj/async-shell-command-no-window ()
    "A version of `async-shell-command' that won't create a window to display its
  output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'async-shell-command
     shell-command-buffer-name-async))

  (defun crj/shell-command-no-window ()
    "A version of `shell-command' that won't create a window to display its output
  buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'shell-command
     shell-command-buffer-name))

  (defun crj/projectile-run-shell-command-in-root-no-window ()
    "A version of `projectile-run-shell-command-in-root' that won't create a
  window to display its output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'projectile-run-shell-command-in-root
     shell-command-buffer-name))

  (defun crj/projectile-run-async-shell-command-in-root-no-window ()
    "A version of `projectile-run-async-shell-command-in-root' that won't create a
  window to display its output buffer."
    (interactive)
    (crj/call-and-bury-window-from-interactive-command
     #'projectile-run-async-shell-command-in-root
     shell-command-buffer-name-async))

  (map! :leader :n "7" #'crj/async-shell-command-no-window)
  (map! :leader :n "&" #'async-shell-command)
  (map! :leader :n "1" #'crj/shell-command-no-window)
  (map! :leader :n "!" #'shell-command)
  (map! :leader
    (:prefix "p"
     :desc "Run project async shell command without a window opening."
     :n "7" #'crj/projectile-run-async-shell-command-in-root-no-window
     :desc "Run project shell command without a window opening."
     :n "1" #'crj/projectile-run-shell-command-in-root-no-window))

  ;; TODO maybe this code can help?
  ;; (add-to-list 'display-buffer-alist
  ;; 	     (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
  (defun crj/call-and-bury-window-from-interactive-command (command window-name)
    "A helper function that calls COMMAND interactively while preventing any
    buffer with the name WINDOW-NAME from creating a window.

  This is useful for times when you want a command to create an output buffer
  without distracting the user."
    (let
        ((display-buffer-alist
          '(window-name '(#'display-buffer-no-window))))
      (call-interactively command)))
#+end_src

*** string inflection

This was occasionally useful, should be easy to get back

#+begin_src emacs-lisp :lexical yes :tangle no
  (map! :n "zc" nil)
  (map! (:prefix "z"
         :desc "Open all folds."
         :n "R" #'org-fold-show-all
         (:prefix ("c" . "Manage case")
          (:desc "Cycle Case" :n "z" #'string-inflection-all-cycle
           :desc "Switch to camelCase" :n "c" #'string-inflection-lower-camelcase
           :desc "Switch to PascalCase" :n "C" #'string-inflection-camelcase
           :desc "Switch to snake_case" :n "s" #'string-inflection-underscore
           :desc "Switch to kebab-case" :n "k" #'string-inflection-kebab-case))))
#+end_src

*** Forge PRs

Super easy to fix up for my current framework if I start checking out PRs again.

#+begin_src emacs-lisp :lexical yes :tangle no
  (map! :leader (:prefix "g" :desc "Checkout pull request." :n "v" #'forge-checkout-pullreq))
#+end_src

*** Elisp

Some old Elisp code, might be useful?

#+begin_src emacs-lisp :lexical yes :tangle no
  (defun crj/open-intro-to-elisp ()
    "Open the manual for \"An Introduction to Programming in Emacs Lisp\" (Info
    node '(eintr)'), re-using the current window."
    (interactive)
    (info "eintr")
    (delete-other-windows))

  (defun crj/open-elisp-reference-manual ()
    "Open the manual for the \"GNU Emacs Lisp Reference Manual\" (Info node
    '(elisp)'), re-using the current window."
    (interactive)
    (info "elisp")
    (delete-other-windows))

  (map!
   :leader
   (:prefix "o"
    :n "l" #'crj/open-elisp-reference-manual
    :n "L" #'crj/open-intro-to-elisp))

  ;;; Evaluating Elisp

  (map! :leader :n "e" #'+eval:region)
  (map! :leader :n "E" #'+eval:replace-region)

  (map!
   :leader
   (:prefix ("t" . "Toggle")
    :desc "debug during elisp errors."
    :n "B" #'toggle-debug-on-error))
#+end_src

*** check if org tangle now does what you want from your Doom Emacs config

*** rename buffers

**** add better shortcut for it

**** rename buffer with project name prefix

#+begin_src emacs-lisp :lexical yes :tangle no
  (defun rename-buffer-with-project-name-prefix ()
    "Prompts the user to rename the buffer, supplying the project prefix."
    (interactive)
    (let* ((project-prefix (concat (projectile-default-project-name (projectile-project-name)) "-"))
           (prompt (concat "New Buffer Name: " project-prefix))
           (name (concat project-prefix (read-string prompt))))
      (rename-buffer name)))
#+end_src

*** Check if THIS is a tangle we have natively now:

#+begin_src emacs-lisp :lexical yes :tangle no
  (defun org-babel-tangle-single-block (block-counter &optional only-this-block)
    "Collect the tangled source for current block.
  Return the list of block attributes needed by
  `org-babel-tangle-collect-blocks'.  When ONLY-THIS-BLOCK is
  non-nil, return the full association list to be used by
  `org-babel-tangle' directly."
    (let* ((info (org-babel-get-src-block-info))
           (start-line
            (save-restriction (widen)
                              (+ 1 (line-number-at-pos (point)))))
           (file (buffer-file-name (buffer-base-buffer)))
           (src-lang (nth 0 info))
           (params (nth 2 info))
           (extra (nth 3 info))
           (coderef (nth 6 info))
           (cref-regexp (org-src-coderef-regexp coderef))
           (link (org-babel-tangle--unbracketed-link params))
           (source-name
            (or (nth 4 info)
                (format "%s:%d"
                        (or (ignore-errors (nth 4 (org-heading-components)))
                            "No heading")
                        block-counter)))
           (expand-cmd (intern (concat "org-babel-expand-body:" src-lang)))
           (assignments-cmd
            (intern (concat "org-babel-variable-assignments:" src-lang)))
           (body
            ;; Run the tangle-body-hook.
            (let ((body (if (org-babel-noweb-p params :tangle)
                            (if (string= "strip-tangle" (cdr (assq :noweb (nth 2
                                                                               info))))
                                (replace-regexp-in-string (org-babel-noweb-wrap)
                                                          "" (nth 1 info))
                              (org-babel-expand-noweb-references info))
                          (nth 1 info))))
              (with-temp-buffer
                (insert
                 ;; Expand body in language specific manner.
                 (cond ((assq :no-expand params) body)
                       ((fboundp expand-cmd) (funcall expand-cmd body params))
                       (t
                        (org-babel-expand-body:generic
                         body params (and (fboundp assignments-cmd)
                                          (funcall assignments-cmd params))))))
                (when (string-match "-r" extra)
                  (goto-char (point-min))
                  (while (re-search-forward cref-regexp nil t)
                    (replace-match "")))
                (run-hooks 'org-babel-tangle-body-hook)
                (buffer-string))))
           (comment
            (when (or (string= "both" (cdr (assq :comments params)))
                      (string= "org" (cdr (assq :comments params))))
              ;; From the previous heading or code-block end
              (funcall
               org-babel-process-comment-text
               (buffer-substring
                (max (condition-case nil
                         (save-excursion
                           (org-back-to-heading t) ; Sets match data
                           (match-end 0))
                       (error (point-min)))
                     (save-excursion
                       (if (re-search-backward
                            org-babel-src-block-regexp nil t)
                           (match-end 0)
                         (point-min))))
                (point)))))
           (src-tfile (cdr (assq :tangle params)))
           (result
            (list start-line
                  (if org-babel-tangle-use-relative-file-links
                      (file-relative-name file)
                    file)
                  link
                  source-name
                  params
                  (if org-src-preserve-indentation
                      (org-trim body t)
                    (org-trim (org-remove-indentation body)))
                  comment)))
      (if only-this-block
          (let* ((file-name (org-babel-effective-tangled-filename
                             (nth 1 result) src-lang src-tfile)))
            (list (cons file-name (list (cons src-lang result)))))
        result)))

  (defun org-babel-noweb-p (params context)
    "Check if PARAMS require expansion in CONTEXT.
  CONTEXT may be one of :tangle, :export or :eval."
    (let ((allowed-values (cl-case context
                            (:tangle '("yes" "tangle" "no-export" "strip-export"
                                       "strip-tangle"))
                            (:eval   '("yes" "no-export" "strip-export" "eval"
                                       "strip-tangle"))
                            (:export '("yes" "strip-tangle")))))
      (cl-some (lambda (v) (member v allowed-values))
               (split-string (or (cdr (assq :noweb params)) "")))))
#+end_src
