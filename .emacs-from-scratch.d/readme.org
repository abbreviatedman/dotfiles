#+title:   Colin Jaffe's Literate Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :mkdirp yes :tangle init.el

* Colin Jaffe's Literate Config
** Introduction
 
Emacs is a text editor. Well, most people use it predominantly as a text editor, but at its nerdy awkward heart it's actually a Lisp programming environment. Setting Emacs' preferences and extending it with third-party code is all done through Lisp code that the Emacs user writes.

[[https://www.explainxkcd.com/wiki/index.php/297:_Lisp_Cycles][https://www.explainxkcd.com/wiki/images/e/eb/lisp_cycles.png]]

This is my code so far.

I've been using a popular third-party config (and config system) called Doom Emacs for a long time now, but it's grown /rather/ creaky, between their code, my code, and Emacs' code. I don't know what's going on under the hood an unfortunate amount of the time because of this three-way scrum. So I'm declaring configuration bankruptcy and starting over. (Though I'm not ready for this to be my main config yet. Still dooming it up for /work/ work until I can get this version up to speed.)

I'm basing this new config on the Emacs from Scratch repo, which is a lot more sparse. I'm currently changing this config considerably by:

1. Paring down the config I copied over from EFS.
2. Going to be going through Doom's vast built-in modules, taking the code I want.

So that's where we started and where we're going. Let's look at some code!

** Literate Config Setup

Literate programming is an approach where, instead of putting comments in code to explain things, we put code in the middle of prose. The document you're reading right now is an example of literate programming, often called a literate config when it's about configuring apps. All of the code blocks in this document are "tangled", which means that they are copied from this document to a code file. The code file itself is rarely edited directly—instead, the code is edited here, along with its explanation. This ensures that any code in here is documented... there's always a /reason/ for a block of code to exist. The documentation can't fall behind the code—the documentation /is/ the code.

You can read more on this subject... and I'll probably write more. But in the meantime: the function below simply ensures that any time this document is saved, it is automatically tangled to its matching code file. It's pretty sweet!

#+begin_src emacs-lisp
  (defun crafted--org-babel-tangle-config ()
    "Tangle code blocks from our init.org file on save.

  A nice little helper from Crafted Emacs.

  Thanks, Crafted!"
    (when (string-equal (buffer-file-name)
                        (expand-file-name "readme.org" user-emacs-directory))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'after-save-hook #'crafted--org-babel-tangle-config)))
#+end_src


** Package System

Settings for extending Emacs.

Emacs has a built in package manager, but it doesn't make it easy to automatically install packages on a new system the first time you pull down your configuration. =use-package= and =straight= are a really helpful package combination that makes it a lot easier to automate the installation and configuration of everything else we use.

Let's install =straight=.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

And turn off the built-in package manager. (This needs to go in =early-init.el=, but I can tangle it to there from this document with a header arg, which you can see if you're looking at this document as a raw =org-mode= file. If that sounds like a whole thing, well... it's also not terribly important detail! But I included it anyway! Not sure why!)

#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

Use =straight= to install =use-package=.

#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src

Tell =use-package= to install packages using =straight= whenever I declare a =use-package= block.

#+begin_src emacs-lisp
(use-package straight
  :custom
  (straight-use-package-by-default t))
#+end_src

Now every time I configure a package with =use-package=, =use-package= will use =straight= to install the package first.

This means that if you or I copy this configuration to another machine and launch Emacs, it will install the necessary packages automatically and configure them the exact same way. This is now a portable document capable of replicating my setup anywhere. And explaining it!

The only extra step necessary is that, because this file is actually an org document, you'll have to run Emacs, tangle this file, and then restart Emacs. But such is the price of being literate(ly configured).

** Keybindings

Like many Vimmers, I eventually realized that the things I personally liked about Vim were even more present in Emacs. This very much includes Vim keybindings, which are available through Evil Mode, In a lot of ways, Evil mode is /more Vim than Vim/. This is something I could argue at length, but... maybe not in this space. (Yet?)

*** Installing And Using General

Before we even get to the keybindings themselves, let's set up a good Vimmish system here. =general= is a great system for setting up keybindings. It integrates very well with =use-package=, =evil=, and =which-key=.

We can use =general-create-definer= to define a pair of leader keys  that we'll call =crj-leader-keys= (=M-SPC= everywhere, and =SPC= alone in Normal Mode—see the very next section for what these terms mean), and then define commands that start with those leader keys using =crj-leader-keys= as a function.

#+begin_src emacs-lisp
  (use-package general
    :init
    (defun crj-open-literate-config-file ()
      "Open the literate config file in the user directory."
      (interactive)
      (find-file (expand-file-name "readme.org" user-emacs-directory)))

    (general-create-definer crj-leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "M-SPC")

    (crj-leader-keys "fc" #'crj-open-literate-config-file))
#+end_src

*** General Emacs' Keybindings

Many of my keybindings are taken from Doom Emacs' well-thought-through keybindings—although part of this is certainly that I'm just used to using them for the last couple of years.

In Vanilla Emacs' keybinding land, the focus is on often elaborate key "chords", where you use a series of modifier key-letter pairs, while in Vim/Evil, most commands use a "leader" key.

For example, opening a file in Vanilla Emacs keybindings would be =C-x C-f=, which means to hold down the =Control= key, press =x=, then, still holding down =Control= (or re-pressing and holding it), press =f=. This can be a bit of a strain on your hand, although certainly less so if you follow best practices and swap =Control= and =Caps Lock=.

In Evil-Mode-style keybindings, the same command might be something like =SPC f o=, which means press the =spacebar=, then press the =f= key, then press the =o= key.

This works because in a modal editing system like Vim and Evil, pressing keys doesn't type anything into a file, but activates commands instead. For example, =/= begins a text search (like =C-f= or =Command-f= in many apps), and =dd= deletes the line the cursor is on.  To enter a text insertion state and actually type text, you have to use a command—in Evil/Vim, the classic command is =i= (for =i=nsert).

This system of different "modes" (Vim parlance) or "states" (Evil parlance, since "mode" has a different meaning in Emacs) gives you tons of freedom in your keybindings. If you /don't/ have non-typing states to unlock these fast editing commands, you need to use modifiers keys like =Control= and =Alt= and =Command= to differentiate commands from typing. In a modal system's "normal state"—so called because editing text is /more/ common than typing new text—you can use =SPC f o= to =o= pen a =f= ile. This opens you up to simpler keybindings that can be a little more mnemonic /without/ contorting your hands.

Let's see some examples!

The following binds =SPC f s= to save a file. It's nice and mnemonic, as well as just three quick presses.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
             "f" '(:ignore t
                    :which-key "file")
             "fs" '(save-buffer
                    :which-key "Save current buffer.")))
#+end_src

The =:prefix "SPC"= tells =general= that this is a "leader key", a key that leads off a set of commands. =:keymaps normal= indicates that this is a command for "normal state"—which makes sense, because in a typing state like insert state, you want the spacebar to actually type a space! The next line, the ="f"= one, creates a sort of menu for further commands, which will (soon) include keybound commands that have to do with files (maybe copy and rename/move will go there, for example). The =:which-key= keyword in that and the following line, where we finally bind the =save-buffer= command, tells =which-key= (see the "Which Key" section below) how to label the menu and commands for discoverability.

To see a good example of a menu with many commands in it, see the section on Helpful commands.

You don't always have to have commands in a deep hierarchy of sections. Here is a simple-if-not-mnemonic =SPC .= for opening or creating a file. (And you can also launch =dired= with it!) This is such a common command that it's good not to bury it.

#+begin_src emacs-lisp
    (use-package emacs
      :general
      (:prefix "SPC" :keymaps 'normal
              "." '(find-file
                    :which-key "Open or create file.")))
#+end_src

I think you get the basics—as I did with learning and writing this section! Let's throw a bunch of commonly-used universal Emacs keybindings together now!

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
              "," '(consult-buffer
                    :which-key "Switch buffer or open recent file.")
              "TAB" '(evil-switch-to-windows-last-buffer
                      :which-key "Previous buffer.")
              ";" '(execute-extended-command
                    :which-key "Run interactive command.")
              ":" '(eval-expression
                    :which-key "Evaluate expression.")
              "b" '(:ignore t
                      :which-key "buffer")
              "bd" '(crj--kill-or-bury-current-buffer
                     :which-key "Kill buffer.")
              "m" '(:ignore t
                      :which-key "markup")
              "m." '(consult-outline
                     :which-key "Search current headings.")))
#+end_src

*** Or Maybe Redo Keybindings To Be More Readable?

Check out this (useful!) keybinding.

#+begin_src emacs-lisp :tangle no
  (use-package emacs
    :general
    (:states 'insert "<S-backspace>" #'just-one-space))
#+end_src

See the <S-backspace> mapping? Well, it took me a good while to find the right way to write shift-backspace in the same syntax as the rest of it, and in the process, I happened upon this alternate syntax:

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (:states 'insert [(shift backspace)] #'just-one-space))
#+end_src

 It's /not/ a short way to write it, but I'm agreeing more and more these days with the idea that short-hands are a real time-saver for when you're entering commands all by yourself (perfect example is installing something globally via =npm= with =npm i -g [package name]= on your own machine by yourself), but if something's in a document, where someone (even just you several weeks later) needs to read and understand it, it should have the long-hand version—so with the previous example, you'd write the command in a document as =npm install --global [package name]=.

 So! Maybe this is how these mappings should be written? =[(control d)]= instead of ="C-d"=? Maybe! Bears thinking about, for sure.

** Evil Mode

Time to spend a vast amount of time thinking through Vim-style keybindings!

TODO Delete the =gj=/=j= bindings once I find the part of the Emacs For Scratch bindings where they're changing them.

*** Transposing Characters

Before we get to the Evil mode setup, this is a small function I wrote to transpose characters with one Vimmish atomic action. It's the first thing here in Evil Mode because, at some point, I want to get into why this is a very Vimmish function, since it might serve as a good introduction to this section.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defun crj-evil-transpose-chars ()
      "Transpose characters as one vim-style action.

  Wraps the function `transpose-chars' so that it's more in the style of Evil
  Mode/Vim. (See info node `(evil)Overview')

  - Acts on the current character and the one to the right, which is more in line
  with Vim's Normal Mode style.
  - Adds the entire process as one action, adding undo/repeat ability.

  This differs greatly from the more Emacs-like `transpose-chars', which allows
  you to drag a character forward as far as you want, using a count, but this
  author found that he preferred the atomicity of Normal Mode.

  See `transpose-chars' for more info on the original function."
      (interactive)
      (evil-with-undo
        (forward-char)
        (transpose-chars 1)
        (backward-char 2)))

    (crj-leader-keys "x" '(crj-evil-transpose-chars :which-key "Transpose characters.")))

#+end_src

*** Evil Mode Setup

There are just a ton of variables here that finely set how Evil Mode is configured. Look at the definition of any of them using =describe-variable= to see what they do and what their possible values are!

#+begin_src emacs-lisp
(use-package evil
  :init
  (global-subword-mode)
  (setq evil-want-integration t
        evil-ex-substitute-global t
        evil-want-keybinding nil
        sentence-end-double-space nil
        evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-undo-system 'undo-redo
        evil-want-fine-undo t
        evil-mode-line-format 'nil
        evil-symbol-word-search t
        evil-visual-state-cursor 'hollow
        evil-ex-interactive-search-highlight 'selected-window
        evil-kbd-macro-suppress-motion-error t
        evil-respect-visual-line-mode nil)

  :config
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (evil-mode 1)
  (evil-select-search-module 'evil-search-module 'evil-search)
  (evil-define-key '(normal visual) 'global
    "j" #'evil-next-line
    "gj" #'evil-next-visual-line
    "k" #'evil-previous-line
    "gk" #'evil-previous-visual-line
    "$" #'evil-end-of-line
    "g$" #'evil-end-of-visual-line)
  (evil-define-key '(normal visual) org-mode-map
    "gj" #'evil-next-visual-line
    "gk" #'evil-previous-visual-line)
  (dolist (mode '(custom-mode
                  eshell-mode
                  term-mode))
    (add-to-list 'evil-emacs-state-modes mode))

  :bind
  ("C-M-u" . universal-argument))

  #+end_src

Some extra Evil Mode stuff.

TODO I will definitely want to go through and pick what I like and don't. For now, I'm taking everything but =unimpaired=, but even that has some stuff I want from it.

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :custom
  (evil-collection-want-unimpaired-p nil)
  :init
  (evil-collection-init)
  (evil-collection-quickrun-setup))
#+end_src

*** Emacs In Vim In Emacs

Bringing back some Emacs commands to use in Insert State.

The short-range, simple Emacs commands are often easier to use when you don't want to switch to Normal State for editing and then back to Insert State to immediately get back to writing. Faster to type =C-w= to delete the word you're currently typing and then replace it, rather than =ESC ciw=. Or, worse, a situation where your editing doesn't bring you back to insert mode in the right place, like when the word /before/ your current word should be deleted—now you're talking about =ESC bb daw A= using Vim, but simply =M-b C-w C-e= with Vanilla Emacs bindings.

I'm still a /big/ fan of modal editing, since you spend so much time straight up editing, but sometimes, particularly when writing prose, you don't want a minor edit to break your flow.

[[./assets/funky-flow.gif]]

Also included is a nifty function that deletes everything but one space before the cursor, super useful if you've accidentally got a bunch of accidental whitespace. Very occasionally super useful.

#+begin_src emacs-lisp
  (use-package evil
    :general
    (:states 'insert
             "C-n" #'next-line
             "C-p" #'previous-line
             "C-e" #'end-of-visual-line
             "C-a" #'beginning-of-visual-line
             "C-d" #'delete-char
             "<S-backspace>" #'just-one-space))
#+end_src

**** TODOS
***** TODO add =C-K= and =C-u=
***** TODO add commands to minibuffer editing

*** Visualizing Evil Commands

=evil-goggles= helps you to visualize the text object you just worked on. Particularly useful for Evil yanks.

#+begin_src emacs-lisp
  (use-package evil-goggles
    :init
    (setq evil-goggles-duration 0.3
          evil-goggles-pulse nil
          evil-goggles-enable-delete nil
          evil-goggles-enable-change nil)

    :config
    (evil-goggles-mode))
#+end_src

*** Working With Surrounding Text In Evil

This library is amazing for working with surrounding text. Changing double quotes to single, parens to square brackets, etc., and also wrapping and unwrapping: surround this line with square brackets, surround the surrounding curly brackets with parens, delete the surrounding curly brackets, and so on. Huge efficiency saver.

#+begin_src emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+end_src

**** TODO add Evil Embrace

*** Evil-Style Commenting

  Vim-style commenting.

  #+begin_src emacs-lisp
      (use-package evil-nerd-commenter
        :config
        :general
        ([remap comment-line] #'evilnc-comment-or-uncomment-lines)
        (:keymaps 'normal :prefix "g"
                  "c" '(evilnc-comment-operator :which-key "Comment operator.")))
#+end_src

*** Jumping By Character Pairs In Evil

I find that Evil-Snipe—an unfortunately named port of Vim-Sneak—is a great way to navigate over medium distances in an editor. You simply press =s= and then type in the two characters you want to jump to. Two characters is usually enough to identify where you want the cursor to be, at least over medium ragnes. And when it isn't? You just press =;= to go to the next one.

Basically, it's a supercharged version of Vim's =f= command. It's fantastic, and I've missed it, and I'm only sorry I've taking this long to get to it.

#+begin_src emacs-lisp
  (use-package evil-snipe
    :init
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1)
    :config
    (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode)
    (setq evil-snipe-scope 'buffer
          evil-snipe-smart-case t
          evil-snipe-char-fold t))
#+end_src

*** Replace With Clipboard In Evil

This is an invaluable command, especially since it's a motion I can combine with a text object.

Being able to type =SPC r i )= to say "replace what's in these parens with what I just copied to the kill ring" is amazingly efficient text editing.

#+begin_src emacs-lisp
  (use-package evil-replace-with-register
    :general
    (crj-leader-keys
              "r" '(evil-replace-with-register
                    :which-key "Replace text with register.")))
#+end_src

*** Evil Motion For Exchanging Text

Another efficient text editing library. This one exchanges two bits of text in an extremely Evilly way.

#+begin_src emacs-lisp
  (use-package evil-exchange
    :general
    (:states '(normal visual)
             "gx" '(evil-exchange :which-key "Exchange text objects.")))
#+end_src

*** Evil Text Objects

This package gives you an Evil text object for XML/HTML attributes. It's helpful!

#+begin_src emacs-lisp
(use-package exato
  :commands (evil-outer-xml-attr evil-inner-xml-attr))
#+end_src

*** Evil Search From Visual Mode

Allows you to select some text in Visual State and then hit =*= or =#= to search for that text. Very occasionally very useful!

#+begin_src emacs-lisp
  (use-package evil-visualstar
    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backward)
    :init
    (global-evil-visualstar-mode))
#+end_src
**** TODO add more evil text objects
**** TODO add targets
**** TODO add treesitter in Emacs 29

*** Evil Motion For Diffing Text

Shows you the difference between two different bits of text. Another very occasionally very useful trick.

#+begin_src emacs-lisp
  (use-package evil-quick-diff
    :init (evil-quick-diff-install)

    :straight (evil-quick-diff
               :type git
               :repo "https://github.com/rgrinberg/evil-quick-diff")

    :commands (evil-quick-diff evil-quick-diff-cancel))
#+end_src

** Look and Feel

*** Basic UI Configuration

These are some sane defaults for getting rid of extra UI elements, like the menu bar and scroll bar.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq inhibit-startup-message t)
    (setq visible-bell t)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (set-fringe-mode 10)
    (menu-bar-mode -1)
    (global-visual-line-mode 1)
    (setq visible-bell t))
#+end_src

If you're just getting started in Emacs, the menu bar might be helpful so you can remove the =(menu-bar-mode -1)= line if you'd like to discover common commands. However, in terms of discovering things in Emacs, there are much better ways to do it, such as the =describe= functions, =which-key=, and, when you et there, reading source code. The single best thing about Emacs is how completely effortless it is to peek at the source code for almost every single thing you can do here. Learn how to dive as far as you want into how something works, and you'll be able to grow in your knowledge at your own learning pace, whether it's slow and steady or voracious.

*** Fonts

First, some definitions of the fonts I use. For Emacs in code, eventually, and for you—and future me!—in this document.

My overly arcane setup includes /three/ fonts, all /very/ different in their style and usage.

The font I see in Emacs as I write this text looks like this:

[[./assets/variable-pitch.png]]

That font is IBM Plex Serif, which is a standard-style variable-pitch serif font. It's "serif" because it's /fancy/. If you look close, you can see that some of the letters have extra little curly bits, called serifs—look at the capital "T" in the "The quick brown fox" line for an example. And, most relevantly, it's a "variable-pitch" font, which means that the characters vary in pitch (a.k.a. width). This is easiest to see in the "nnnnn" and "mmmmm" lines: the "n" line is much shorter than the "m" line because the latter character is wider than the former. This type of font is perfect for writing prose, where the letters are given the breathing room we're used to seeing them in.

In my Emacs setup, this font is /only/ used in text and markup documents like Org Mode and Markdown, where I'm doing lots of classic writing and reading.

The second font I use is Hack, which is a "fixed pitch" font—more often called a "monospace" font. Here is a similar font in a terminal:

[[./assets/fixed-pitch.png]]

Most people use a fixed-pitch font for code for several reasons, but we'll get to those in a second. The main feature of a fixed-pitch font is that the width doesn't vary. You'll notice in the sample above that the "nnnnn" and "mmmmm" lines are the same length. Having all characters be the exact same width makes alignment easier, which many developers use to keep similar columns of code lined up just so.

The last font is Input, which is another variable pitch font, but one that's very, very different than most. You can see it in the Emacs terminal pictured below:

[[./assets/variable-pitch-coding-font.png]]

If you look closely at Input, it's variable-pitch, no question. The "mmmmm" line is longer than the "nnnnn" line, and the characters are generally less squished-in. Since developers swear by fixed-pitch coding fonts, no respected developer would use this font as a coding font.

I am not a respected developer.

I use Input for coding because when I head about a minority of developers using a variable pitch font for coding, I read up on it, and the few articles I read in defense of it were pretty convincing.

See, many developers will tell you that the big difference between the two types of fonts, besides alignment, is that a variable-pitch font doesn't give enough space to coding symbols like parentheses and curly brackets and =!= and =:= and =/=,  characters that a fixed-pitch font gives equal width to (because fixed-pitch fonts give /everything/ the same length) And it's true that if I try to write code in my prose font (see first sample!), it's much harder to make out the important-to-code characters.

But variable-pitch fonts don't /have/ to give coding symbols short shrift. Look at the Input sample above—the coding characters are given plenty of width! You see, fixed-pitch fonts give everything the same width, whether it's a =!= or an =n= or an =m=. In that way, they're making the decision that every character is equally important and needs the same amount of width. It's a shortcut solution, treating all characters the same to give coding characters with the space they need, but it's not making an actual /decision/ as to what to prioritize.

Coding fonts should prioritize code symbols, and prose fonts should prioritize letters more. But /why not both/.

[[./assets/why-not-both.gif]]

Why not a font that gives code symbols plenty of space to make them properly stand out for their syntactic meaning, without bizarrely deciding that alignment is more important than letter readability? Why not a font that makes /everything/ readable? When your wide letters like "m" and "w" and "c" are squished in while skinny letters like "t" and "l" and "i" are weirdly widened, what you get is a one-size-fits-all approach that prioritizes... nothing in particular. Except trying not to deprioritize anything.

When reading and writing, priorities matter. You want symbols to be readable, because you /definitely/ don't want to miss them as you're reading the code, but you /also/ want to be able to read those function and variable names. A variable-pitch font designed carefully to create a great coding experience unsurprisingly beats a font that is designed simply /not/ to deprioritize symbols.

There's actually even more to say about this than I thought going in, but I'll leave it here for now.

So how do I use these fonts? Well, I still do use my fixed-pitch Hack font for a few places, where alignment can super matter. For files where the columns matter, like spreadsheets and tables, I still use them. I also use them for line numbers, so as to keep the left margin aligned. Otherwise, though, it's Input for coding, and IBM Plex Mono (my variable-pitch serif font) for writing.

Final thing before I get to the code: yes, this is a lot of work for fonts. And I'm not even a font expert! I /do/ think readability matters quite a great deal. But I think there are two related elements of my character that have lead me down this path.

The desire to make my system my own. To craft an app I can live in every day, that I can not only code in but write emails in and use to check the weather and browse the web and manage my local files and manage my cloud files and write blog posts and chat with friends and organize my life, and to /keep/ crafting that personalized app, spending a fair amount of my valuable time making the rest of my work time fun enough to get me through the day.

But the other, and related reason, is that everyone likes to be a little different and weird and have opinions that make you feel smart, even if the end result is just that you have a bizarre font choice that on-lookers likely won't even notice.

The desire to be just a bit of an iconoclast.

[[./assets/iconoclast.gif]]

It's important to make fun of yourself for doing so, but that doesn't change the fact that it feels /good/ to be that weird guy who always wears hats or learned Esperanto or decided Vim was somehow /too mainstream/.

That guy's me, and you're welcome, and I'm sorry.

Here are my font settings.

#+begin_src emacs-lisp
  (defvar crj--fixed-pitch-font "Hack")
  (defvar crj--variable-pitch-coding-font "Input")
  (defvar crj--variable-pitch-font "IBM Plex Serif")
  (defvar crj--coding-font crj--variable-pitch-coding-font)
  (defvar crj--default-font-size 110)

  (use-package emacs
    :config
    (set-face-attribute 'default nil
                        :font crj--coding-font
                        :height crj--default-font-size)
    (set-face-attribute 'fixed-pitch nil
                        :font crj--coding-font
                        :height 1.0)
    (set-face-attribute 'variable-pitch nil
                        :font crj--variable-pitch-font
                        :height 1.0
                        :weight 'regular))
#+end_src

And a picture of what my setup actually looks like:

[[./assets/font-setup-screenshot.png]]

**** TODO redo font size as calculated based on resolution

**** Using Fixed Pitch In Some Buffers

#+begin_src emacs-lisp
  (defface crj--monospace
    '((t
       :family "Hack"
       :foundry unspecified
       :width normal
       :height 1.0
       :weight normal
       :slant normal
       :foreground "#505050"
       :distantForeground unspecified
       :background "#f8f8f8"
       :underline nil
       :overline nil
       :strike-through nil
       :box nil
       :inverse nil
       :stipple nil
       :font "Hack"
       :fontset unspecified
       :extend nil))

    "Face for monospace fonts.")

  (defun crj--use-fixed-pitch ()
    "Makes the current buffer use a fixed pitch.

  Sometimes I really do want fixed-pitch for alignment, such as with terminals."
    (interactive)
    (set (make-local-variable 'buffer-face-mode-face) 'crj--monospace)
    (buffer-face-mode t))

  ;; Hooks for modes I want to use fixed pitch in.
  (setq crj--fixed-pitch-mode-hooks
        '(vterm-mode-hook
          calendar-mode-hook
          proced-mode-hook
          cfw:calendar-mode-hook
          minibuffer-setup-hook
          mu4e-headers-mode-hook))

  ;; Add the fixed-pitch function for each mode.
  (dolist (hook crj--fixed-pitch-mode-hooks)
    (add-hook hook #'crj--use-fixed-pitch))
#+end_src


*** Zooming Text

Zooming in and out in Emacs is... tricky. Part of this is because fonts in general are tricky! And part of it is that Emacs gives you so much control over your fonts that there are a /lot/ of moving parts, making it trickier still. And the last part is that Emacs' font system is hugely unintuitive.

Still, I've got a /pretty/ good system for zooming fonts up and down, here. It's split into zooming per-buffer and zooming globally, depending on your needs. It's easy to zoom more or less for fine-grained refinement, while also being easy to zoom by huge amounts in one go with a count.

There are some edge cases here, though, so I'll probably be returning to it.

First, some functions to zoom and reset one buffer:

#+begin_src emacs-lisp
      (defun crj--zoom-in (arg)
    "Incease text size in current buffer.

  ARG is a count—increase the count to zoom in more."
	(interactive "p")
	(text-scale-increase arg))

      (defun crj--zoom-out (arg)
    "Decrease text size in current buffer.

  ARG is a count—increase the count to zoom out more."
	(interactive "p")
	(text-scale-increase (* arg -1)))

      (defun crj--zoom-reset (arg)
  "Reset current buffer's text size."
	(interactive "p")
	(text-scale-increase 0))
#+end_src

From there, I can use those to zoom in on all current buffers. These functions simply loop through all the buffers in the =buffer-list= and run the above functions in each.

#+begin_src emacs-lisp
  ;; I will add these eventually if I work further on the current-zoom-level-as-a-global-variable idea.
  ;; (defvar current-text-scale 0)
  ;; (defun crj-match-new-buffer-to-current-text-scale ()
  ;;   (interactive)
  ;;   (text-scale-increase 0)
  ;;   (text-scale-increase text-scale-mode-amount))
  ;; (add-hook 'after-set-visited-file-name-hook #'crj-match-new-buffer-to-current-text-scale)

  (defun crj--zoom-in-all-buffers (arg)
    "Zooms in on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj--zoom-in arg))))

  (defun crj--zoom-out-all-buffers (arg)
    "Zooms out on all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj--zoom-out arg))))

  (defun crj--zoom-reset-all-buffers (arg)
    "Resets zoom for all current buffers."
    (interactive "p")
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (crj--zoom-reset arg))))
#+end_src

This package, =default-text-scale=, can handle things more robustly than the homegrown situation above, in that it change the font size for other existing "frames" (what every other program would call a window), and for new frames moving forward.

#+begin_src emacs-lisp :tangle no
  (use-package default-text-scale
    :init (default-text-scale-mode))
#+end_src

But since their solution causes the default font size to reset, along with every font that inherits from it, every time it hits a font size for the first time in an Emacs session, there's a slowdown where the screen goes blank for a jarring second. (Possibly exacerbated by how many disparate fonts  I have going on—see the Fonts section below.) It also doesn't have the ability to take a count, though there's probably a way to wrap the functions to make that happen.

All of this is to say that the many many different ways you can manipulate and work with multiple fonts in Emacs, across as many frames and buffers and windows as you've got open, makes zooming a bit of a complex mess. =defualt-text-scale= is the most powerful system I've seen for it, but... although external libraries by accomplished Emacs Lisp programmers are almost always better than what an okay-ish programmer like me can do, I think I'm going to stick with my simple and flexible system this time.

Next, we make some keybindings for them.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
              "z" '(:ignore t :which-key "zoom")
              "zj" '(crj--zoom-in-all-buffers :which-key "Zoom in globally.")
              "zk" '(crj--zoom-out-all-buffers :which-key "Zoom out globally.")
              "zb" '(crj--zoom-reset-all-buffers :which-key "Reset zoom globally.")
              "zJ" '(crj--zoom-in :which-key "Zoom in.")
              "zK" '(crj--zoom-out :which-key "Zoom out.")
              "zB" '(crj--zoom-reset :which-key "Reset zoom.")))
#+end_src

And finally, there's a special type of Emacs interface I don't use often, a third-party package called Hydra, that's perfect for an activity like zooming text. Once you've decided to zoom, you're entering a kind of session where you'll be entering related commands. You'll be zooming in a couple times, then zooming out if you've gone too far. And at that point that can even repeat, if you change your mind as to what zoom level you actually want. What Hydra does is enter an interface perfect for this kind of situation.

With the below code, the user (almost definitely me!) can type =SPC z z=, at which point, instead of entering complex keybindings, they can type =j= to zoom in, =k= to zoom out (these are meaningful letters to Vim users), do that as much as they want, and then get back to what they were doing by pressing =escape= or any other key that's not part of this system.

There are other, similar libraries (I've heard Transient is even better), but I highly recommend an interface like this. It's fantastic.

We'll install Hydra, define its interface, and then put that hydra command in our keybindings.

#+begin_src emacs-lisp
  (use-package hydra
    :config
    (defhydra crj--hydra/text-zoom (:hint nil :color red)
      "
	Global zoom: _j_:zoom in, _k_:zoom out, _b_:reset
	Buffer zoom: _J_:zoom in, _K_:zoom out, _B_:reset
  "
      ("J" crj--zoom-in)
      ("K" crj--zoom-out)
      ("B" crj--zoom-reset)
      ("j" crj--zoom-in-all-buffers)
      ("k" crj--zoom-out-all-buffers)
      ("b" crj--zoom-reset-all-buffers))
    :general
    (crj-leader-keys
	      "zz" '(crj--hydra/text-zoom/body :which-key "Zoom hydra interface.")))
#+end_src

**** TODO add ability to zoom to preset big size.
**** TODO add to new-buffer-hook to adjust to current text scale?
**** TODO add "i" and "o" (or switch those with j/k?) to zoom in by larger increments

*** Scrolling

This package makes scrolling big distances easier to follow by flashing the new line you've moved to.

#+begin_src emacs-lisp
  (use-package pulsar
    :init
    (setq pulsar-pulse t)
    (setq pulsar-delay .01)
    (setq pulsar-iterations 30)
    (setq pulsar-face 'pulsar-generic)
    :config
    (setq crj--far-jumping-functions '(evil-scroll-up
                                       evil-scroll-down
                                       evil-goto-line
                                       evil-beginend-prog-mode-goto-beginning
                                       evil-beginend-prog-mode-goto-end
                                       evil-beginend-org-mode-goto-beginning
                                       evil-beginend-org-mode-goto-end
                                       evil-beginend-dired-mode-goto-beginning
                                       evil-beginend-dired-mode-goto-end
                                       evil-beginend-message-mode-goto-beginning
                                       evil-beginend-message-mode-goto-end
                                       evil-beginend-org-agenda-mode-goto-beginning
                                       evil-beginend-org-agenda-mode-goto-end
                                       evil-beginend-compilation-mode-goto-beginning
                                       evil-beginend-compilation-mode-goto-end
                                       evil-beginend-magit-status-mode-goto-beginning
                                       evil-beginend-magit-status-mode-goto-end
                                       evil-beginend-magit-revision-mode-goto-beginning
                                       evil-beginend-magit-revision-mode-goto-end
                                       evil-goto-first-line
                                       evil-goto-mark-line
                                       evil-scroll-page-up
                                       evil-scroll-page-down
                                       bury-buffer
                                       kill-buffer
                                       crj--toggle-presentation-mode
                                       delete-other-windows
                                       winner-undo
                                       evil-window-up
                                       evil-window-down
                                       evil-window-left
                                       evil-window-right
                                       evil-window-new
                                       evil-window-vnew))

    (dolist (function crj--far-jumping-functions)
      (add-to-list 'pulsar-pulse-functions function))

    (pulsar-global-mode 1))
#+end_src

*** Line Numbers

Sets up line numbers to be (almost) everywhere.

Use relative line numbers to make line-wise work easy with Evil Mode.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq display-line-numbers-type 'relative
          magit-disable-line-numbers nil
          magit-section-disable-line-numbers nil)

    (global-display-line-numbers-mode t)

    (defun crj--turn-off-line-numbers ()
      (display-line-numbers-mode 0))

    (defconst crj--hooks-for-modes-without-line-numbers '(term-mode-hook
                                                        vterm-mode-hook
                                                        shell-mode-hook
                                                        treemacs-mode-hook
                                                        eshell-mode-hook))

    (dolist (hook crj--hooks-for-modes-without-line-numbers)
      (add-hook hook #'crj--turn-off-line-numbers)))
#+end_src

This next part is for making line numbers use a fixed pitch font. I like a variable pitch coding font, but line numbers get janky if they're not fixed pitch.

And by setting line numbers to an absolute size, we also avoid having them increase in size with everything else. Ideally I would increase their size too when zooming, just at a lesser rate. But this is good enough for now.

**** TODO do that thing

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq crj--line-number-faces '(line-number
                                   line-number-current-line
                                   line-number-major-tick
                                   line-number-minor-tick))

    (defun crj--make-line-number-face-monospace (&rest args)
      "Makes line numbers monospace and fixes them in size."
      (interactive)
      (dolist (face crj--line-number-faces)
          (set-face-attribute face nil :family crj--fixed-pitch-font :height crj--default-font-size))
      args)

    (add-hook 'emacs-startup-hook #'crj--make-line-number-face-monospace))
#+end_src

#+begin_src emacs-lisp
  (defun crj--reset-line-number-height ()
    (interactive)
    (set-face-attribute 'line-number nil :height crj--default-font-size))
#+end_src

** Applications

This section is for parts of Emacs that are well-integrated applications.

Let's set up a keybinding for applications, and then we can put these apps under it!

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys
      "a" '(:ignore t :which-key "applications")))
#+end_src

*** Vterm

Of the many types of terminals in Emacs, Vterm is the most faithful to the standard terminal emulator. Note that this does not mean it's the best, but it /does/ work the way folks expect if they're used to the standard terminal emulator experience.

Let's use a wrapper around it that allows multiple terminals.

#+begin_src emacs-lisp
  (use-package multi-vterm
    :init
    (setq vterm-max-scrollback 100000)
    :general
    (crj-leader-keys
      "av" '(multi-vterm :which-key "Open a Vterm terminal.")))
#+end_src
*** Org Agenda

Org Agenda is an amazing application that can take task data from different sources and produce an overview of your current tasks. It's powerful and efficient and customizable. It's one of the best things in Emacs.

We set up an agenda view, and then we set it as the easier-to-reach keybinding (=SPC aa=). The dashboard, which has a bunch of different potential views, is still available on =SPC aA=.

#+begin_src emacs-lisp
    (use-package emacs
      :init
      (defun crj-agenda () (interactive) (org-agenda t "g"))
      (setq org-agenda-start-day nil
            org-agenda-files '("~/org-stuff/inbox.org"
                               "~/org-stuff/gcal-ics.org"
                               "~/org-stuff/readme.org"
                               "~/org-stuff/personal.org"
                               "~/org-stuff/archive.org")

            org-agenda-custom-commands '(("g" "Daily agenda and top priority tasks"
                                          ((todo "WAIT"
                                                 ((org-agenda-overriding-header "Tasks On Hold\n")
                                                  (org-agenda-block-separator nil)))
                                           (agenda ""
                                                   ((org-agenda-span 1)
                                                    (org-deadline-warning-days 0)
                                                    (org-agenda-block-separator nil)
                                                    (org-scheduled-past-days 0)
                                                    (org-agenda-day-face-function (lambda (_) 'org-agenda-date))
                                                    (org-agenda-format-date "%A %-e %B %Y")
                                                    (org-agenda-overriding-header "\n Today's Agenda\n")))
                                           (agenda ""
                                                   ((org-agenda-start-on-weekday nil)
                                                    (org-agenda-start-day "+1d")
                                                    (org-agenda-span 3)
                                                    (org-deadline-warning-days 0)
                                                    (org-agenda-block-separator nil)
                                                    (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                    (org-agenda-overriding-header "\n Next Three Days After\n")))
                                           (agenda ""
                                                   ((org-agenda-start-on-weekday nil)
                                                    (org-agenda-tag-filter-preset '("-EVENT"))
                                                    (org-agenda-start-day "+4d")
                                                    (org-agenda-span 3)
                                                    (org-deadline-warning-days 0)
                                                    (org-agenda-block-separator nil)
                                                    (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "EVENT"))
                                                    (org-agenda-overriding-header "\n Further Calendar Events\n")))
                                           (agenda ""
                                                   ((org-agenda-time-grid nil)
                                                    (org-agenda-start-on-weekday nil)
                                                    (org-agenda-start-day "+4d")
                                                    (org-agenda-span 14)
                                                    (org-agenda-show-all-dates nil)
                                                    (org-deadline-warning-days 0)
                                                    (org-agenda-block-separator nil)
                                                    (org-agenda-entry-types '(:deadline))
                                                    (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                                                    (org-agenda-overriding-header "\n Upcoming Deadlines (+14d After)\n")))))))
      :general
      (crj-leader-keys
        "aA" '(org-agenda :which-key "Org Agenda dashboard.")
        "aa" '(crj-agenda :which-key "Custom Org Agenda view.")))

    (use-package evil-org
      :after org
      :init
      (add-hook 'org-mode-hook #'evil-org-mode)
      (add-hook 'org-agenda-mode-hook #'evil-org-mode)
      :config
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
#+end_src

*** Dired

Dired is the fast and powerful file explorer in Emacs. Let's configure it! We'll:

1. Set it to group directories first.
2 . Set it to omit unimportant details.
3. Set it up with an extra command to hide dotfiles.
4. Set it to re-use the same buffer for each directory.
5. Add icons.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq dired-listing-switches "-al --group-directories-first")
    (add-hook 'dired-mode-hook #'dired-omit-mode)
    (add-hook 'dired-mode-hook #'dired-hide-details-mode)
    :commands (dired dired-jump))

  (use-package dired-single
    :general
    (:keymaps 'dired-mode-map
              [remap dired-find-file] #'dired-single-buffer
              [remap dired-mouse-find-file-other-window] #'dired-single-buffer-mouse
              [remap dired-up-directory] #'dired-single-up-directory))

  (use-package all-the-icons-dired
    :ghook #'all-the-icons-dired-mode-hook)

  (use-package dired-hide-dotfiles
    :general
    (:keymaps 'dired-mode-map
              "H" 'dired-hide-dotfiles-mode))
#+end_src

** Under The Hood

Alwyas confirm with a quick =y= or =n= instead of requiring a =yes= or =no= followed by =RET=.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (defalias 'yes-or-no-p 'y-or-n-p))
#+end_src

Set Emacs to remember recent files, as well as update buffers if the file changes on disk.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (recentf-mode 1)
    (global-auto-revert-mode 1))
#+end_src

A better Emacs kill command binding to kill the Emacs server as well.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    ([remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)
    (crj-leader-keys
      "q" '(:ignore t :which-key "quit")
      "qq" '(save-buffers-kill-emacs :which-key "Quit emacs.")))
#+end_src

Save backups of files, every 10 idle seconds, to a backups folder in our  main emacs directory

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (auto-save-mode 1)
    (setq auto-save-timeout 10
          auto-save-no-message t
          backup-directory-alist
          `(("." . ,(concat user-emacs-directory "/backups")))))
#+end_src

Save minibuffer history.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

Increase the size of the garbage collector.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))
#+end_src

Measure startup time using an excellent bit of code taken from Emacs From Scratch.

#+begin_src emacs-lisp
(defun efs/display-startup-time ()
  "Display how long it took to start Emacs."
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

** Color Theme

Modus Operandi is a fantastic theme for readability and accessiblity, and even though I don't experience deuteranopia, I use the variant for those who do. Modus Operandi is about the uncoolest theme you can use, but... if you're using Emacs to be hip, you're doing it wrong.

#+begin_src emacs-lisp
  (use-package modus-themes
    :config
    (setq modus-themes-italic-constructs t
	  modus-themes-bold-constructs t
	  modus-themes-org-blocks 'gray-background
	  modus-themes-completions (quote
				    ((matches . (intense background underline bold))
				     (selection . (accented intense bold))))

	  modus-themes-headings '((0 . (variable-pitch  1.8))
				  (1 . (variable-pitch  1.8))
				   (2 . (variable-pitch  1.6))
				   (3 . (variable-pitch  1.4))
				   (4 . (variable-pitch  1.2)))

	  modus-themes-common-palette-overrides modus-themes-preset-overrides-intense)

    (load-theme 'modus-operandi-deuteranopia t))
#+end_src

** Writing

*** TODO add flyspell

** Coding

Settings for... coding.

*** General

Balance parentheses and switch to Smartparens for showing matching parens. (It's prettier.)

Also, experimentally, automatically insert and indent a newline when putting a newline between empty curlies.

#+begin_src emacs-lisp
    (use-package smartparens
      :init
      (require 'smartparens-config)
      (smartparens-global-mode)
      (show-smartparens-global-mode)

      :config
      (setq sp-show-pair-from-inside nil
            sp-highlight-pair-overlay nil))

    (use-package emacs
      :init
      (defun crj--create-newline-and-enter-sexp (&rest _ignored)
        "Open a new brace or bracket expression, with relevant newlines and indent. "
        (newline)
        (indent-according-to-mode)
        (forward-line -1)
        (indent-according-to-mode))

      (sp-local-pair 'prog-mode "{" nil :post-handlers '((crj--create-newline-and-enter-sexp "RET"))))
#+end_src

*** Languages
Configurations specific to certain languages.

**** Markdown

***** TODO configure markdown

**** Emacs Lisp

***** TODO configure elisp more
***** Symex Manipulation

#+begin_src emacs-lisp
(use-package on-parens)
#+end_src

****** TODO configure keybindings
****** TODO figure out evil keybindings for movement

***** Emacs Lisp Evaluation

#+begin_src emacs-lisp
  (use-package quickrun)
#+end_src
****** TODO figure out how to quickrun a region—see how doom package emacs-lisp module does it

***** Emacs Lisp Documentation Lookup

Better go-to-definition function for Emacs Lisp.
 
#+begin_src emacs-lisp
      (use-package elisp-def
        :init
        (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook #'elisp-def-mode))

        :general
        (:keymaps 'org-mode-map :states 'normal
                  "gd" '(elisp-def :which-key "Go to definition.")))
#+end_src

***** Emacs Lisp Highlight Quoted Mode
Don't remember what this one does.

#+begin_src emacs-lisp
  (use-package highlight-quoted
    :init
    (add-hook 'emacs-lisp-mode-hook 'highlight-quoted-mode))
#+end_src

****** TODO check what higlight-quoted mode does

**** JavaScript

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq js-indent-level 2))

  (use-package rjsx-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . rjsx-mode))
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . rjsx-mode))

    :config
    (defun crj--rjsx-electric-gt-fragment-a (n)
      (if (or (/= n 1) (not (and (eq (char-before) ?<) (eq (char-after) ?/)))) 't
        (insert ?> ?<)
        (backward-char)))

    (advice-add #'rjsx-electric-gt :before-while #'crj--rjsx-electric-gt-fragment-a))
#+end_src

** Completion

Because so much in Emacs is driven by text, good completion is the difference between hard-to-use and effortless.

*** Minibuffer Completion 

Minibuffer completion is a different beast than in-buffer completion, which is what most people mean when they talk about completion in other apps. The minibuffer is a kind of menu you get in Emacs, and it usually serves as a place to search for something. 

In Emacs, minibuffer menus can be used to search for:

- a command you're looking to run
- a command you're looking to get more info on
- a file or directory you're looking to open
- a project to open
- a buffer to choose
- a Git branch to switch to
- a wi-fi network to join
- an emoji to insert
- and lots of other things I use every day

Other apps now have this equivalent—the one people know most developers know these days is the Comand Palette in VS Code, which offers very good menu completion, but there are similar examples in Slack and Discord and Vivaldi and many other apps. But in Emacs land, because you can search for practically anything you do, having /one/ interface for searching for what you want to do next is incredibly powerful, and one of the main unique selling points of Emacs.

**** Some Basic Minibuffer SeachSettings

Set Emacs to only include commands that are relevant to the current "major mode" (what you would call a file type outside of Emacs).

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

**** Minibuffer Search Interface

Vertico and Marginalia togethr make an amazing interface for minibuffer search.

***** Marginalia

Marginalia gives you some more data in other columns in the list of results as you filter them. It's nice! Let's set it up!

#+begin_src emacs-lisp
  (use-package marginalia
    :general
    (:keymaps 'minibuffer-local-map
              "M-A" 'marginalia-cycle)

    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'right)

    :init
    (marginalia-mode))
#+end_src

***** Vertico

A popular Emacs minibuffer search interface is Vertico. It gives you a simple but powerful UI for accessing whatever you're looking to access, and it does it with a minimum of code, mostly focusing on extending the built-in Emacs interface. This makes it fast to use and, importantly, easy for the devs to debug.

What we'll do is:

- Install it.
- Turn it on.
- Tun on the ability to toggle interface setup.
- Set the results of searches to wrap from bottom to top.
- Set "reverse" as the default interface setup.
- Set Emacs to remember Vertico's history.
- Fix some weirdness caused by the interplay of directories and completion.
- Add the Vertico extension =vertico-repeat= and a keybinding to repeat previous searches.
- Add keybindings for more Vim-like =j=/=k= scrolling as well as scrolling by pages and going up a directory with a single delte.

Here that all is!

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    (vertico-multiform-mode)

    :config
    (setq vertico-cycle t
          vertico-multiform-categories '((t reverse)))

    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (with-eval-after-load 'savehist
      (add-to-list 'savehist-additional-variables 'vertico-repeat-history))

    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-repeat))

    :general
    (crj-leader-keys
      "'" '(vertico-repeat-select
            :which-key "Repeat previous vertico searches."))

    (:keymaps 'vertico-map
              "C-k" #'vertico-next
              "C-j" #'vertico-previous
              "C-S-p" #'vertico-scroll-up
              "C-S-n" #'vertico-scroll-down
              "C-S-k" #'vertico-scroll-up
              "C-S-j" #'vertico-scroll-down
              "RET" #'vertico-directory-enter
              "DEL" #'vertico-directory-delete-char
              "M-DEL" #'vertico-directory-delete-word))
#+end_src

**** Minibuffer Search Data Sets

=consult= is a library containing a set of functions that each search a different set of data. That sounds dry, but it's really not!

What it enables you to do is decide whether your search will be of:

- lines in the current buffer
- lines in any file in your project or directory
- titles of currently open buffers
- paths to recent files
- text in Emacs' clipboard history (the "kill ring")
- headings in a markup file (how I get around this document!)
- color themes
- manual pages for Unix commands

And that's not even all of them! Minibuffer searches are a /huge/ part of how you use Emacs, and Consult is just one of many ways to decide what to search through.

#+begin_src emacs-lisp
  (use-package consult
  :commands consult-line
    :general
    (crj-leader-keys "/" '(consult-line :which-key "Search in current buffer.")))
#+end_src

***** TODO add bindings for Consult seraches for grep and project search and maybe others?

**** Minibuffer Search Filtering

The Orderless package is powerful and fascinating. It decides the data you're searching is filtered as you type, and you can even search in different ways in the same search.

Here's an example using the setup below. I can start typing the path of a file I want to open in a minibuffer search, then notice that ost of the results are in a directory I want to exclude. So I type in a =!= (a pretty universal developer symbol for "not" and the name of that directory, and those results are filtered out. Then I realize I want the path to begin with the home directory, excluding everything in the =/usr= and =/tmp= and such directories. So I type =^= (developer for "starts with") and =~= (the alias for the home directory). Finally, I want only JavaScript files, so I type =$= (developer for "ends with") and then type =js=, and boom!

Once you're used to this speedy filtering process, it /greatly/ cuts down on the time spent searching for whatever it is you want to do.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (defun crj--vertico-orderless-dispatch (pattern _index _total)
      "The set of dispatch commands I use for filtering searches.

  Taken from the Doom Emacs project, which has added so much useful configuration code to the Emacs world. Thanks, Doom contributors!"
      (cond
       ;; Ensure $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
        `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x200000-\x300000]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Without literal
       ((string-prefix-p "!" pattern) `(orderless-without-literal . ,(substring pattern 1)))
       ;; Character folding
       ((string-prefix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 1)))
       ((string-suffix-p "%" pattern) `(char-fold-to-regexp . ,(substring pattern 0 -1)))
       ;; Initialism matching
       ((string-prefix-p "`" pattern) `(orderless-initialism . ,(substring pattern 1)))
       ((string-suffix-p "`" pattern) `(orderless-initialism . ,(substring pattern 0 -1)))
       ;; Literal matching
       ((string-prefix-p "=" pattern) `(orderless-literal . ,(substring pattern 1)))
       ((string-suffix-p "=" pattern) `(orderless-literal . ,(substring pattern 0 -1)))
       ;; Flex matching
       ((string-prefix-p "~" pattern) `(orderless-flex . ,(substring pattern 1)))
       ((string-suffix-p "~" pattern) `(orderless-flex . ,(substring pattern 0 -1)))))

    (setq completion-ignore-case t
          completion-styles '(orderless basic)
          completion-category-defaults nil
          orderless-component-separator "#"
          orderless-style-dispatchers '(crj--vertico-orderless-dispatch)
          orderless-matching-styles '(orderless-flex orderless-literal orderless-regexp)
          completion-category-overrides '((file (styles partial-completion)))))

#+end_src

**** Lots of completion settings to look over!

#+begin_src emacs-lisp
  ;; snippet settings

  ;; (defun crj--set-up-snippets ()
  ;;   (yas-global-mode)
  ;;   (setq yas-snippet-dirs '("~/.doom.d/snippets"))
  ;;   (yas-reload-all)
  ;;   ;; I like having a specific (non-tab) and easy key for expanding snippets
  ;;   (map! :i [M-tab] #'yas-expand
  ;; 	:map yas-keymap "TAB" nil
  ;; 	"<tab>" nil
  ;; 	[M-tab] #'yas-next-field-or-maybe-expand))

  ;; (require 'yasnippet)
  ;; (after! yasnippet (crj--set-up-snippets))

  ;; ;; don't add newlines to end of snippet files
  ;; (defun no-final-newline-in-buffer ()
  ;;   (setq-local require-final-newline nil))
  ;; (add-hook! 'snippet-mode-hook 'no-final-newline-in-buffer)

#+end_src

****** TODO set up Emmet

#+begin_src emacs-lisp
  ;; (map! :i [C-tab] nil)
  ;; (map! :i [C-tab] #'emmet-expand-line)
  ;; (map! :map emmet-mode-keymap "<tab>" nil)

#+end_src

This looks like something I'll want to implement too.

#+begin_src emacs-lisp
  ;; (defun toggle-eldoc-mode ()
  ;;   (interactive)
  ;;   (if eldoc-mode
  ;;       (eldoc-mode -1)
  ;;     (eldoc-mode 1)))

  ;; (map!
  ;;  :leader
  ;;  (:prefix ("t" . "toggle")
  ;; 	  :desc "eldoc for current symbol" :n "k" #'eldoc
  ;; 	  :desc "eldoc mode." :n "K" #'toggle-eldoc-mode))

  #+end_src

  Might be some useful Embark stuff here, since I'll be setting that up soon.
  #+begin_src emacs-lisp
  ;; (use-package vertico
  ;;   :config
  ;;   embark act and resume completion
  ;;   (defun crj--embark-act-without-quitting ()
  ;;     (interactive)
  ;;     (let ((embark-quit-after-action nil))
  ;;       (embark-act)))
  ;;   (map! :map vertico-map "C-:" #'crj--embark-act-without-quitting)
  ;;   (map! :leader
  ;; 	:desc "Select from previous completions." "\"" #'vertico-repeat-select)
  ;;   (map! :map vertico-map "C-S-P" #'vertico-scroll-down)
  ;;   (map! :map vertico-map "C-S-N" #'vertico-scroll-up))
#+end_src


These might be useful Corfu settings? check them out once I get Eglot going?

  #+begin_src emacs-lisp
	    ;; (use-package corfu
	    ;;   :config
	    ;;   (define-key corfu-map (kbd "M-g") #'corfu-quit)
	    ;;   (define-key corfu-map (kbd "C-n") #'corfu-next)
	    ;;   (define-key corfu-map (kbd "C-j") #'corfu-next)
	      ;; (define-key corfu-map (kbd "C-p") #'corfu-previous)
	      ;; (define-key corfu-map (kbd "C-k") #'corfu-previous)
	      ;; (define-key corfu-map (kbd "C-S-n") #'corfu-scroll-up)
	      ;; (define-key corfu-map (kbd "C-S-j") #'corfu-scroll-up)
	      ;; (define-key corfu-map (kbd "C-S-p") #'corfu-scroll-down)
	    ;;   (define-key corfu-map (kbd "C-S-k") #'corfu-scroll-down)
	    ;;   (define-key corfu-map (kbd "RET") nil)
	    ;;   (define-key corfu-map (kbd "RET") #'corfu-complete)
	    ;;   (define-key corfu-map (kbd "TAB") nil)
	    ;;   (define-key corfu-map (kbd "<tab>") nil)
	    ;;   (define-key corfu-map (kbd "<tab>") #'corfu-insert)
	    ;;   (define-key corfu-map (kbd "TAB") #'corfu-insert)
	      ;; (setq corfu-commit-predicate nil
	      ;; 	completion-category-overrides '((eglot (styles orderless)))
	    ;; 	corfu-auto t
	    ;; 	corfu-auto-prefix 1
	    ;; 	corfu-quit-no-match t
	    ;; 	corfu-cycle t))

	    ;; (after! projectile
	    ;; 	(add-to-list 'projectile-project-root-files ".git"))

	    ;; ;; I don't need the "symbol class" info in my documentation.
	    ;; (after! marginalia
	    ;; 	(setf (alist-get 'variable marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-variable builtin none))
	    ;; 	(setf (alist-get 'symbol marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-symbol builtin none))
	    ;; 	(setf (alist-get 'function marginalia-annotator-registry)
	    ;; 	      '(crj--custom-marginalia-annotate-function none)))

	    ;; (org-babel-do-load-languages
	     ;; 'org-babel-load-languages
	     ;; '((emacs-lisp . t)))
	       ;; (sql-mode . t)
	       ;; (racket . t)
	       ;; (python . t)
	       ;; (ipython . t)
	       ;; (bash . t)
	       ;; (sh . t)
	       ;; (js . t)
	       ;; (javascript . t)
	       ;; (sql . t)
	       ;; (go . t)


	    ;; (map! :leader
	    ;;       :desc "Yank from kill ring with completion." :n "P" #'yank-from-kill-ring)

	    ;; ;; (map! :i "C-SPC" #'complete-symbol)

	    ;; (setq embark-prompter 'embark-completing-read-prompter)
  #+end_src
**** In-Buffer Completion

***** Corfu

#+begin_src emacs-lisp
  (use-package corfu
    :config
    (general-unbind corfu-map "RET")
    :general
    (:keymaps 'corfu-map :states 'insert
              "C-n" #'corfu-next
              "C-p" #'corfu-previous
              "M-g" #'corfu-quit
              "TAB" #'corfu-next
              [tab] #'corfu-next
              "S-TAB" #'corfu-previous
              [backtab] #'corfu-previous
              "M-d" #'corfu-show-documentation
              "M-l" #'corfu-show-location)
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-separator ?#)
    (corfu-preview-current 'insert)
    (corfu-quit-at-boundary 'separator)
    (corfu-auto-prefix 1)
    (corfu-preselect 'prompt)
    (corfu-on-exact-match nil)

    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    :init
    (global-corfu-mode))

  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+end_src

***** Eglot

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (setq completion-category-overrides '((eglot (styles orderless)))))

  (use-package cape
    :after eglot
    :config
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster))
#+end_src

*** Flymake

  A great error-navigation library.
  
  #+begin_src emacs-lisp

    (use-package flymake
      :hook (prog-mode . flymake-mode)
      :general
      (:keymaps 'normal
                "]e" '(flymake-goto-next-error
                       :which-key "Go to next error.")
                "[e" '(flymake-goto-prev-error
                       :which-key "Go to previous error."))
      (crj-leader-keys
                "c" '(:ignore t
                        :which-key "code")
                "cX" '(flymake-show-project-diagnostics
                       :which-key "Describe variable.")))
      #+end_src
** Window Management

Emacs has windows, which are more like what you would call a "pane" anywhere else. Evil has some great keybindings, but they're on =C-w=, and I also want them on my leader keys.

#+begin_src emacs-lisp
  (use-package emacs
    :general
    (crj-leader-keys "w" '(:keymap evil-window-map :which-key "window")))
#+end_src

*** TODO include a 

** EFS/Better Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line configuration for Emacs.  The default configuration is quite good but you can check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that mode line icons display correctly.

#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))
#+end_src


** EFS/Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp

  (use-package which-key
    :defer 0
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 2))

#+end_src

** EFS/Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each item.

#+begin_src emacs-lisp

  ;; (use-package ivy
  ;;   :diminish
  ;;   :bind (("C-s" . swiper)
  ;;          :map ivy-minibuffer-map
  ;;          ("TAB" . ivy-alt-done)
  ;;          ("C-l" . ivy-alt-done)
  ;; ("C-j" . ivy-next-line)
  ;; ("C-k" . ivy-previous-line)
  ;;        :map ivy-switch-buffer-map
  ;;        ("C-k" . ivy-previous-line)
  ;;        ("C-l" . ivy-done)
  ;;        ("C-d" . ivy-switch-buffer-kill)
  ;;        :map ivy-reverse-i-search-map
  ;;        ("C-k" . ivy-previous-line)
  ;;        ("C-d" . ivy-reverse-i-search-kill))
  ;; :config
  ;; (ivy-mode 1))

  ;; (use-package ivy-rich
  ;;   :after ivy
  ;;   :init
  ;;   (ivy-rich-mode 1))

  ;; (use-package counsel
  ;;   :bind (("C-M-j" . 'counsel-switch-buffer)
  ;;          :map minibuffer-local-map
  ;;          ("C-r" . 'counsel-minibuffer-history))
  ;;   :custom
  ;; (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  ;; :config
  ;; (counsel-mode 1))

#+end_src

*** Improved Candidate Sorting with prescient.el

prescient.el provides some helpful behavior for sorting Ivy completion candidates based on how recently or frequently you select them.  This can be especially helpful when using =M-x= to run commands that you don't have bound to a key but still need to access occasionally.

This Prescient configuration is optimized for use in System Crafters videos and streams, check out the [[https://youtu.be/T9kygXveEz0][video on prescient.el]] for more details on how to configure it!

#+begin_src emacs-lisp

  ;; (use-package ivy-prescient
  ;;   :after counsel
  ;;   :custom
  ;; (ivy-prescient-enable-filtering nil)
  ;; :config
  ;; ;; Uncomment the following line to have sorting remembered across sessions!
  ;;                                       ;(prescient-persist-mode 1)
  ;; (ivy-prescient-mode 1))

#+end_src

** Improving Help Commands

Original description of Emacs From Scratch's equivalent section perfectly sums it up, so I'll let it do so:

#+begin_quote
[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.
#+end_quote

Besides different keybindings, I've only added a couple extra configuraitons here:

- =woman= is for accessing Unix manual pages from within Emacs. Everything should be from within Emacs!
- =helpful-at-point= is a great quick Emacs Lisp documentation lookup. With Evil, I can just press =K= on a function or variable and get its documentation and source code. It makes Emacs' amazing introspectability even easier.

#+begin_src emacs-lisp
    (use-package helpful
      :init
      (defun crj--set-elisp-lookup-function ()
        "Sets the documentation function for Emacs Lisp."
        (setq evil-lookup-func #'helpful-at-point))
      (add-hook 'emacs-lisp-mode-hook #'crj--set-elisp-lookup-function)

      :commands (helpful-callable
                 helpful-command
                 helpful-variable
                 helpful-at-point
                 helpful-key
                 helpful-face)

      :general
      (crj-leader-keys
                "h" '(:ignore t
                              :which-key "help")
                "hv" '(helpful-variable
                       :which-key "Describe variable.")
                "hf" '(helpful-callable
                       :which-key "Describe function.")
                "hF" '(describe-face
                       :which-key "Describe face.")
                "hk" '(helpful-key
                       :which-key "Describe key.")
                "hx" '(helpful-command
                       :which-key "Describe command.")
                "hW" '(woman
                       :which-key "Search for manual page.")
                "hg" '(customize-group
                       :which-key "Search for customize group.")
                "hm" '(describe-mode
                       :which-key "Describe currently active modes."))
      ([remap describe-function] #'helpful-callable)
      ([remap describe-command] #'helpful-command)
      ([remap describe-variable] #'helpful-variable)
      ([remap describe-key] #'helpful-key)
      ("C-h g" #'customize-group)
      ("C-h F" #'describe-face))
#+end_src

** EFS/Text Scaling

This is an example of using [[https://github.com/abo-abo/hydra][Hydra]] to design a transient key binding for quickly adjusting the scale of the text on screen.  We define a hydra that is bound to =C-s t s= and, once activated, =j= and =k= increase and decrease the text scale.  You can press any other key (or =f= specifically) to exit the transient key map.

#+begin_src emacs-lisp

  (use-package hydra
    :defer t)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  (crj-leader-keys
    "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

** Org Mode

[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

*** TODO add << and >> bindings for =org-do-promote= and =org-do-demote=, respectively
*** TODO change =M-h= and =M-l= to the above functions

*** Better Font Faces

The =efs/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp
  (defun my/buffer-face-mode-variable ()
    "Set font to a variable width (proportional) fonts in current buffer"
    (interactive)
    (setq buffer-face-mode-face '(:family crj--variable-pitch-font
                                  :height 120
                                  :width normal))
    (buffer-face-mode))

    (defun my/set-general-faces-org ()
      (my/buffer-face-mode-variable)
      (setq line-spacing 0.1
            org-pretty-entities t
            org-startup-indented t
            org-adapt-indentation nil)
      (variable-pitch-mode +1)
      (mapc
       (lambda (face) ;; Other fonts that require it are set to fixed-pitch.
         (set-face-attribute face nil :inherit 'fixed-pitch))
       (list 'org-block
             'org-table
             'org-verbatim
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-date
             'org-drawer
             'org-property-value
             'org-special-keyword
             'org-document-info-keyword))
      (mapc ;; This sets the fonts to a smaller size
       (lambda (face)
         (set-face-attribute face nil :height 0.8))
       (list 'org-document-info-keyword
             'org-block-begin-line
             'org-block-end-line
             'org-meta-line
             'org-drawer
             'org-property-value
             )))

      (defun efs/org-font-setup ()
        ;; Replace list hyphen with dot
        (font-lock-add-keywords 'org-mode
                                '(("^ *\\([-]\\) "
                                   (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

        ;; Ensure that anything that should be fixed-pitch in Org files appears that way
        (set-face-attribute 'org-block nil    :foreground nil :font crj--coding-font)
        (set-face-attribute 'org-table nil    :font crj--coding-font)
        (set-face-attribute 'org-formula nil  :font crj--coding-font)
        (set-face-attribute 'org-code nil     :font crj--coding-font)
        (set-face-attribute 'org-table nil    :font crj--coding-font)
        (set-face-attribute 'org-verbatim nil :font crj--coding-font)
        (set-face-attribute 'org-special-keyword nil :font crj--coding-font)
        (set-face-attribute 'org-meta-line nil :font crj--coding-font)
        (set-face-attribute 'org-checkbox nil  :font crj--coding-font))

#+end_src

*** Basic Config

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.  There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.

#+begin_src emacs-lisp
  (defun efs/org-mode-setup ()
    (org-indent-mode)
    ;; (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :hook
    (org-mode . efs/org-mode-setup)
    (org-mode . my/set-general-faces-org)
    ;; :config (efs/org-font-setup)
    :general
    (:keymaps 'org-mode-map :states 'insert
              "M-h" #'org-promote-subtree
              "M-l" #'org-demote-subtree))

  ;; (use-package org
  ;;   :commands (org-capture org-agenda)
  ;;   :hook (org-mode . efs/org-mode-setup)
  ;;   :config
  ;;   (setq org-ellipsis " ▾")

  ;;   (setq org-agenda-start-with-log-mode t)
  ;;   (setq org-log-done 'time)
  ;;   (setq org-log-into-drawer t)

  ;;   (setq org-agenda-files
  ;;         '("~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org"
  ;;           "~/Projects/Code/emacs-from-scratch/OrgFiles/Habits.org"
  ;;           "~/Projects/Code/emacs-from-scratch/OrgFiles/Birthdays.org"))

  ;;   (require 'org-habit)
  ;;   (add-to-list 'org-modules 'org-habit)
  ;;   (setq org-habit-graph-column 60)

  ;;   (setq org-todo-keywords
  ;;         '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
  ;;           (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  ;;   (setq org-refile-targets
  ;;         '(("Archive.org" :maxlevel . 1)
  ;;           ("Tasks.org" :maxlevel . 1)))

  ;;   ;; Save Org buffers after refiling!
  ;;   (advice-add 'org-refile :after 'org-save-all-org-buffers)

  ;;   (setq org-tag-alist
  ;;         '((:startgroup)
  ;;                                         ; Put mutually exclusive tags here
  ;;           (:endgroup)
    ;;         ("@errand" . ?E)
    ;;         ("@home" . ?H)
    ;;         ("@work" . ?W)
    ;;         ("agenda" . ?a)
    ;;         ("planning" . ?p)
    ;;         ("publish" . ?P)
    ;;         ("batch" . ?b)
    ;;         ("note" . ?n)
    ;;         ("idea" . ?i)))

    ;; ;; Configure custom agenda views
    ;; (setq org-agenda-custom-commands
    ;;       '(("d" "Dashboard"
    ;;          ((agenda "" ((org-deadline-warning-days 7)))
    ;;           (todo "NEXT"
    ;;                 ((org-agenda-overriding-header "Next Tasks")))
    ;;           (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

    ;;         ("n" "Next Tasks"
    ;;          ((todo "NEXT"
    ;;                 ((org-agenda-overriding-header "Next Tasks")))))

    ;;         ("W" "Work Tasks" tags-todo "+work-email")

    ;;         ;; Low-effort next actions
    ;;         ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
    ;;          ((org-agenda-overriding-header "Low Effort Tasks")
    ;;           (org-agenda-max-todos 20)
    ;;           (org-agenda-files org-agenda-files)))

    ;;         ("w" "Workflow Status"
    ;;          ((todo "WAIT"
    ;;                 ((org-agenda-overriding-header "Waiting on External")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "REVIEW"
    ;;                 ((org-agenda-overriding-header "In Review")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "PLAN"
    ;;                 ((org-agenda-overriding-header "In Planning")
    ;;                  (org-agenda-todo-list-sublevels nil)
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "BACKLOG"
    ;;                 ((org-agenda-overriding-header "Project Backlog")
    ;;                  (org-agenda-todo-list-sublevels nil)
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "READY"
    ;;                 ((org-agenda-overriding-header "Ready for Work")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "ACTIVE"
    ;;                 ((org-agenda-overriding-header "Active Projects")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "COMPLETED"
    ;;                 ((org-agenda-overriding-header "Completed Projects")
    ;;                  (org-agenda-files org-agenda-files)))
    ;;           (todo "CANC"
    ;;                 ((org-agenda-overriding-header "Cancelled Projects")
    ;;                  (org-agenda-files org-agenda-files)))))))

    ;; (setq org-capture-templates
    ;;       `(("t" "Tasks / Projects")
    ;;         ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
    ;;          "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

    ;;         ("j" "Journal Entries")
    ;;         ("jj" "Journal" entry
    ;;          (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
    ;;          ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
    ;;          :clock-in :clock-resume
    ;;          :empty-lines 1)
    ;;         ("jm" "Meeting" entry
    ;;          (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
    ;;          :clock-in :clock-resume
    ;;          :empty-lines 1)

    ;;         ("w" "Workflows")
    ;;         ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    ;;          "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

    ;;         ("m" "Metrics Capture")
    ;;         ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
    ;;          "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

    ;; (define-key global-map (kbd "C-c j")
    ;;   (lambda () (interactive) (org-capture nil "jj")))

    ;; (efs/org-font-setup)
    ;; )

#+end_src

**** Nicer Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in =org-mode= buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.

#+begin_src emacs-lisp

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

** EFS/Configure Babel Languages

To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp

  ;; (with-eval-after-load 'org
    ;; (org-babel-do-load-languages
     ;; 'org-babel-load-languages
     ;; '((emacs-lisp . t)
       ;; (python . t)))

    ;; (push '("conf-unix" . conf-unix) org-src-lang-modes))

#+end_src

** EFS/Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))

#+end_src

** EFS/Languages

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp

  ;; (defun efs/lsp-mode-setup ()
  ;;   (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  ;;   (lsp-headerline-breadcrumb-mode))

  ;; (use-package lsp-mode
  ;;   :commands (lsp lsp-deferred)
  ;;   :hook (lsp-mode . efs/lsp-mode-setup)
  ;;   :init
  ;;   (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
  ;;   :config
  ;;   (lsp-enable-which-key-integration t))

#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp

  ;; (use-package lsp-ui
  ;;   :hook (lsp-mode . lsp-ui-mode)
  ;;   :custom
  ;;   (lsp-ui-doc-position 'bottom))

#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp

  ;; (use-package lsp-treemacs
  ;;   :after lsp)

#+end_src

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things by name in your code.  When you run these commands, a prompt will appear in the minibuffer allowing you to type part of the name of a symbol in your code.  Results will be populated in the minibuffer so that you can find what you're looking for and jump to that location in the code upon selecting the result.

Try these commands with =M-x=:

- =lsp-ivy-workspace-symbol= - Search for a symbol name in the current project workspace
- =lsp-ivy-global-workspace-symbol= - Search for a symbol name in all active project workspaces

#+begin_src emacs-lisp

  ;; (use-package lsp-ivy
    ;; :after lsp)

#+end_src

*** Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp

  ;; (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
    ;; :commands dap-debug
    ;; :config
    ;; Set up Node debugging
    ;; (require 'dap-node)
    ;; (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    ;; Bind `C-c l d` to `dap-hydra` for easy access
    ;; (general-define-key
     ;; :keymaps 'lsp-mode-map
     ;; :prefix lsp-keymap-prefix
     ;; "d" '(dap-hydra t :wk "debugger")))

#+end_src

*** TypeScript

This is a basic configuration for the TypeScript language so that =.ts= files activate =typescript-mode= when opened.  We're also adding a hook to =typescript-mode-hook= to call =lsp-deferred= so that we activate =lsp-mode= to get LSP features every time we edit TypeScript code.

#+begin_src emacs-lisp

  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2))

#+end_src

*Important note!*  For =lsp-mode= to work with TypeScript (and JavaScript) you will need to install a language server on your machine.  If you have Node.js installed, the easiest way to do that is by running the following command:

#+begin_src shell :tangle no

  npm install -g typescript-language-server typescript

#+end_src

This will install the [[https://github.com/theia-ide/typescript-language-server][typescript-language-server]] and the TypeScript compiler package.

*** Python

We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no

  pip install --user "python-language-server[all]"

#+end_src

There are a number of other language servers for Python so if you find that =pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

#+begin_src emacs-lisp

  ;; (use-package python-mode
  ;;   :ensure t
  ;;   :hook (python-mode . lsp-deferred)
  ;;   :custom
  ;;   ;; NOTE: Set these if Python 3 is called "python3" on your system!
  ;;   ;; (python-shell-interpreter "python3")
  ;;   ;; (dap-python-executable "python3")
  ;;   (dap-python-debugger 'debugpy)
  ;;   :config
  ;;   (require 'dap-python))


#+end_src

You can use the pyvenv package to use =virtualenv= environments in Emacs.  The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and =dap-mode= to use the virtual environment when they are loaded, just select the path to your virtual environment before loading your project.

#+begin_src emacs-lisp

  ;; (use-package pyvenv
  ;;   :after python-mode
  ;;   :config
  ;;   (pyvenv-mode 1))

#+end_src

** EFS/Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp

  ;; (use-package company
  ;;   :after lsp-mode
  ;;   :hook (lsp-mode . company-mode)
  ;;   :bind (:map company-active-map
  ;;               ("<tab>" . company-complete-selection))
  ;;   (:map lsp-mode-map
  ;;         ("<tab>" . company-indent-or-complete-common))
  ;;   :custom
  ;;   (company-minimum-prefix-length 1)
  ;;   (company-idle-delay 0.0))

  ;; (use-package company-box
  ;;   :hook (company-mode . company-box-mode))

#+end_src

** EFS/Projectile

[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp

  ;; (use-package projectile
  ;;   :diminish projectile-mode
  ;;   :config (projectile-mode)
  ;;   ;; :custom ((projectile-completion-system 'ivy))
  ;;   :bind-keymap
  ;;   ("C-c p" . projectile-command-map)
  ;;   :init
  ;;   ;; NOTE: Set this to the folder where you keep your Git repos!
  ;;   (when (file-directory-p "~/Projects/Code")
  ;;     (setq projectile-project-search-path '("~/Projects/Code")))
  ;;   (setq projectile-switch-project-action #'projectile-dired))

  ;; (use-package counsel-projectile
  ;;   :after projectile
  ;;   :config (counsel-projectile-mode))

#+end_src

** EFS/Magit

[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge
    :after magit)

#+end_src

** EFS/Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** EFS/Terminals

** EFS/term-mode

=term-mode= is a built-in terminal emulator in Emacs.  Because it is written in Emacs Lisp, you can start using it immediately with very little configuration.  If you are on Linux or macOS, =term-mode= is a great choice to get started because it supports fairly complex terminal applications (=htop=, =vim=, etc) and works pretty reliably.  However, because it is written in Emacs Lisp, it can be slower than other options like =vterm=.  The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is =line-mode= versus =char-mode=.  =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal.  While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings.  If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=).  You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp

  (use-package term
    :commands term
    :config
    (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
    ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

#+end_src

*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to.  Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program.  Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp

  (use-package eterm-256color
    :hook (term-mode . eterm-256color-mode))

#+end_src

** EFS/shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

#+begin_src emacs-lisp

  (when (eq system-type 'windows-nt)
    (setq explicit-shell-file-name "powershell.exe")
    (setq explicit-powershell.exe-args '()))

#+end_src

** EFS/Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp

  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))

    (eshell-git-prompt-use-theme 'powerline))


#+end_src

** EFS/Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings

**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** Configuration

#+begin_src emacs-lisp
  ;; (use-package emacs
  ;;   :commands (dired dired-jump)
  ;;   :bind (("C-x C-j" . dired-jump))
  ;;   :custom ((dired-listing-switches "-ah --group-directories-first"))
  ;;   :config
  ;;   (evil-collection-define-key 'normal 'dired-mode-map
  ;;     "h" 'dired-single-up-directory
  ;;     "l" 'dired-single-buffer))

  ;; (use-package dired-single
  ;;   :commands (dired dired-jump))

  ;; (use-package all-the-icons-dired
  ;;   :hook (dired-mode . all-the-icons-dired-mode))

  ;; (use-package dired-open
  ;;   :commands (dired dired-jump)
  ;;   :config
  ;;   (setq dired-open-extensions '(("html" . "google-chrome-stable")
  ;;                                 ("mkv" . "mpv"))))

  ;; (use-package dired-hide-dotfiles
  ;;   :config
  ;;   (evil-collection-define-key 'normal 'dired-mode-map
  ;;     "H" 'dired-hide-dotfiles-mode))
#+end_src

** EFS/Applications

** EFS/Some App

This is an example of configuring another non-Emacs application using org-mode.  Not only do we write out the configuration at =.config/some-app/config=, we also compute the value that gets stored in this configuration from the Emacs Lisp block above it.

#+NAME: the-value
#+begin_src emacs-lisp :tangle no

  (+ 55 100)

#+end_src

*NOTE*: Set the =:tangle= parameter below to =.config/some-app/config= for this to work!

#+begin_src conf :tangle no :noweb yes

  value=<<the-value()>>

#+end_src

** EFS/Utility Functions
Making my life easier!

#+begin_src emacs-lisp
  (defun crj--cycle-setting (setting potential-values)
    "Cycle SETTING through POTENTIAL-VALUES.

  SETTING is a quoted symbol.

  POTENTIAL-VALUES is a list of values to cycle through."
    (let ((i (cl-position (eval setting) potential-values)))
      (set setting (if (eq (1+ i) (length potential-values))
                       (car potential-values)
                     (nth (1+ i) potential-values)))))
#+end_src

#+begin_src emacs-lisp
  (defvar crj--immortal-buffer-names '("*scratch*"
                                      "#emacs"
                                      "*Messages*"
                                      shell-command-buffer-name shell-command-buffer-name-async))

  (defun crj--kill-or-bury-current-buffer ()
    "Kill the current buffer.

  Unless it's a buffer we should always keep alive, in which case we just bury it in the buffer list."
    (interactive)
    (if (member (buffer-name (current-buffer)) crj--immortal-buffer-names)
        (bury-buffer)
      (kill-buffer (current-buffer))))
#+end_src
